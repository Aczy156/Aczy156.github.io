<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aczy156</title>
    <link>http://www.chenranfei.site/</link>
    <description>Recent content on Aczy156</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Aczy156</copyright>
    <lastBuildDate>Sun, 02 May 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://www.chenranfei.site/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Academic Profile</title>
      <link>http://www.chenranfei.site/posts/academic/</link>
      <pubDate>Sun, 02 May 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.chenranfei.site/posts/academic/</guid>
      <description>Introduction I’m a junior undergraduate student studying Software Engineering at Central South University (CSU). I’m expected to graduate in 2022.
My real name is Ranfei Chen.
Experience  More Resources  Projects &amp;nbsp;
&amp;nbsp;
 Academic Status  First 2.5 years GPA: 90.28/100 (Rank: 15/199)   A+ courses  courses  course1   Others  etc.     Honors and Awards </description>
    </item>
    
    <item>
      <title>Algorithm1.0 字符串基本</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E6%9C%AC/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E6%9C%AC/</guid>
      <description>[TOC]
字符串基本 数字字符串的排序 (直接用数字排序即可) https://www.luogu.com.cn/problem/P3955
思路：首先按照长度排序，然后如果长度相等了，在直接字符串比较大小
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 1e3+9; int n, q, l; string s[maxn], sq; #include &amp;lt;algorithm&amp;gt; bool cmp(string s1, string s2) { if (s1.length() == s2.length()) return s1 &amp;lt; s2; return s1.length() &amp;lt; s2.length(); } int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;q); for (int i = 1; i &amp;lt;= n; ++i) cin&amp;gt;&amp;gt;s[i]; sort(s+1, s+1+n, cmp); for (int i = 1; i &amp;lt;= q; ++i) { cin&amp;gt;&amp;gt;l&amp;gt;&amp;gt;sq; int fd = 0; for (int j = 1; j &amp;lt;= n; ++j) { if (l &amp;gt; s[j].</description>
    </item>
    
    <item>
      <title>Algorithm1.1 字符串-map匹配</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E6%9C%AC%E6%98%A0%E5%B0%84%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E6%9C%AC%E6%98%A0%E5%B0%84%E5%8C%B9%E9%85%8D/</guid>
      <description>[TOC]
字符串映射 利用map进行字串匹配、替换 https://www.luogu.com.cn/problem/P1603
题目大意：给六个字符串，然后如果有映射的进行映射为数字，没有的就不映射。输出最后映射完的结果
1、准备数据结构：用于匹配的map字典=&amp;gt;将字符串与数字进行映射
2、易错：第一位随便匹配，后面的位数如果是1位的话，拼接到一起之前要补0，例如如果是5，要输出05。
声明字符串映射的数据结构map
// 声明map map&amp;lt;string, int&amp;gt; mp; // 进行映射 mp[&amp;#34;one&amp;#34;] = 1; mp[&amp;#34;two&amp;#34;] = 2; /* ……*/ mp[&amp;#34;nineteen&amp;#34;] = 19; mp[&amp;#34;twenty&amp;#34;] = 20; mp[&amp;#34;one&amp;#34;] = 1; 进行匹配：
int main() { for (int i = 0; i &amp;lt; 6; ++i) { cin&amp;gt;&amp;gt;str; if (mp[str]){ int cnt = mp[str]*mp[str]%100; if (!cnt) continue; ans[idx++] = cnt; } } sort(ans, ans+idx); printf(&amp;#34;%d&amp;#34;, ans[0]); for (int i = 1; i &amp;lt; idx; ++i) { if (ans[i] &amp;lt; 10) printf(&amp;#34;0&amp;#34;); printf(&amp;#34;%d&amp;#34;, ans[i]); } return 0; } 两个map进行正向反向映射 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm1.2 字符串数据结构 Trie树</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84trie%E6%A0%91/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84trie%E6%A0%91/</guid>
      <description>[TOC]
字符串 数据结构 Trie树  工程开发中的应用：浏览器的搜索框内容提示功能
demo：Trie树维护的字典：[he, his, hers, she]，要从字典里查到的单词：ahishers
构建Trie树：
 node节点结构体：  当前节点的值 存放指向下一层node节点指针的List（最多26个=&amp;gt;26个字母）   bool数组：标记某一个节点是否是尾部节点【例如下图中的trie树双层圈的都是】  通过root往下查询某一个待测字串：
 查找正确：  到双层圈的节点 =&amp;gt; 完成完全匹配 未到双层圈的节点 =&amp;gt; 完成部分(前缀)匹配   查找错误：  空指针 =&amp;gt; 直接从root根节点就无法匹配 未找到双层圈的节点 =&amp;gt; 完成部分(前缀)匹配     [模版] 点名问题 https://www.luogu.com.cn/problem/P2580
题目大意：给出若干个人的名字，多次询问看某个询问是否是第一次出现 &amp;amp; 重复出现【字典树最基本的应用】 &amp;amp; 错误名字
1、数据结构：
ch[maxn][字符串的涉及字符空间]，一般字典树第二维都是26，26个字母
val[maxn]用来记录索引到这个点的值，例如学生名字是索引的字典，这个学生的各个成绩就是val这个值，exist[maxn]用来记录是否存在或者重复访问
2、常用操作：
插入insert：
查找query：
 是否存在或者重复访问，访问exist数组 字符串对应的值，访问val数组  AC代码：只需访问exist，看是否存在或者重复访问
#include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;lt;cstring&amp;gt;#define maxn 500010struct trie { int nex[maxn][26], cnt; int exist[maxn]; // 0 没出现；1 第一出现；2 重复出现  int val[maxn]; // -1 查不到这个人的对应的值  void insert(char *s) { int p = 0, l = strlen(s); for (int i = 0; i &amp;lt; l; i++) { int c = s[i] - &amp;#39;a&amp;#39;; if (!</description>
    </item>
    
    <item>
      <title>Algorithm1.3 KMP</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.3-kmp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.3-kmp/</guid>
      <description>[TOC]
字符串 KMP  工程开发中的应用：浏览器的搜索框内容提示功能
demo：Trie树维护的字典：[he, his, hers, she]，要从字典里查到的单词：his
构建Trie树：利用一个bool数组来标记某一个节点是否是尾部节点【例如下图中的trie树双层圈的都是】
通过root往下查询某一个待测字串：
 查找正确：  到双层圈的节点 =&amp;gt; 完成完全匹配 未到双层圈的节点 =&amp;gt; 完成部分(前缀)匹配   查找错误：  空指针 =&amp;gt; 直接从root根节点就无法匹配 未找到双层圈的节点 =&amp;gt; 完成部分(前缀)匹配     [模版] 点名问题 https://www.luogu.com.cn/problem/P2580
题目大意：给出若干个人的名字，多次询问看某个询问是否是第一次出现 &amp;amp; 重复出现【字典树最基本的应用】 &amp;amp; 错误名字
1、数据结构：
ch[maxn][字符串的涉及字符空间]，一般字典树第二维都是26，26个字母
val[maxn]用来记录索引到这个点的值，例如学生名字是索引的字典，这个学生的各个成绩就是val这个值，exist[maxn]用来记录是否存在或者重复访问
2、常用操作：
插入insert：
查找query：
 是否存在或者重复访问，访问exist数组 字符串对应的值，访问val数组  AC代码：只需访问exist，看是否存在或者重复访问
#include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;lt;cstring&amp;gt;#define maxn 500010struct trie { int nex[maxn][26], cnt; int exist[maxn]; // 0 没出现；1 第一出现；2 重复出现  int val[maxn]; // -1 查不到这个人的对应的值  void insert(char *s) { int p = 0, l = strlen(s); for (int i = 0; i &amp;lt; l; i++) { int c = s[i] - &amp;#39;a&amp;#39;; if (!</description>
    </item>
    
    <item>
      <title>Algorithm1.4 AC自动机</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.4-ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/algorithm1.4-ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</guid>
      <description>[TOC]
字符串 AC自动机  demo：AC自动机维护：[he, his, hers, she]，要查询的单词：ahishers
过程一：构建Trie树：
 node节点结构体：  当前节点的值 存放指向下一层node节点指针的List（最多26个=&amp;gt;26个字母） fail失效指针：用来找最长相同后缀，节省从头查找的时间 【特殊】对于是某一个p的结尾节点的，这个特殊的节点储存更多信息   利用一个bool数组来标记某一个节点是否是尾部节点【例如下图中的trie树双层圈的都是】  过程二：构建AC自动机
完善fail指针
过程三：输入待测字串进行测试
通过root往下查询某一个待测字串：
 查找正确：  到双层圈的节点 =&amp;gt; 完成完全匹配 未到双层圈的节点 =&amp;gt; 完成部分(前缀)匹配   查找错误：  空指针 =&amp;gt; 直接从root根节点就无法匹配 未找到双层圈的节点 =&amp;gt; 完成部分(前缀)匹配     方法一：利用链表实现
数据结构：结构体和指向结构体的指针
方法二：利用数组实现
1、初始化trie树「trie[][]树，cnt[]数组判定节点是否是字典终止节点」
对应位置初始化上值，cnt数组进行初始化
2、初始化fail指针「当前节点nw，遍历到的当前节点nw的儿子pos」
对于当前节点，那么他的所有儿子节点就是for(i~[0, 26]) pos = trie[nw][i]表示所有儿子的值。
 如果当前儿子为真儿子，那么trie[nw][i]不为0 =&amp;gt; fail[pos] = trie[fail[nw]][i];对于当前节点nw的fail指针是已知的，所以就要利用当前nw节点的fail指针来更新他的所有儿子节点的fail指针 =&amp;gt; 真儿子的fail指针指向当前节点的fail指针对应的指向方向的节点  if (!fail[pos]) fail[pos] = 1; 此时刷新出来的指向的方向不一定有值，也就是说有可能指向的那个也是空 =&amp;gt; 就要替换成父节点 else就正常赋值就好，赋成当前节点的fail指针指向的节点的对应方向   如果当前儿子为假儿子，可以将fail指针指向的节点相同方向的值赋过去（fail指针指向的节点有值是最好的，没有值也无所谓）相当于把fail指针指向的节点那棵树嫁接在了这个节点下边  3、利用AC自动机进行搜索「当前节点nw，pos」</description>
    </item>
    
    <item>
      <title>Algorithm10 二分</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm10-%E4%BA%8C%E5%88%86/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm10-%E4%BA%8C%E5%88%86/</guid>
      <description>[TOC]
二分  查找的几种：
 暴力遍历：O(n) 折半查找/二分查找：O(log2n) 哈希：O(1)  其中，二分就是折半查找。
 关键点：等于号的选取、l/r的区间范围的更改、check函数
整数二分
1 =&amp;gt; l &amp;lt;= r
while (l &amp;lt;= r) { mid = (l+r)&amp;gt;&amp;gt;1; if (mid == 0) {ans = mid;break;} if (check(mid)) l = (ans=mid)+1; else r = mid-1; } 2 =&amp;gt; l+1 &amp;lt; r
while (l + 1 &amp;lt; r) { mid = (l + r) / 2; if (f(mid)) l = mid; else r = mid; } cout &amp;lt;&amp;lt; l &amp;lt;&amp;lt; endl; https://www.</description>
    </item>
    
    <item>
      <title>Algorithm11.0 数据结构 线性表</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>[TOC]
数据结构 线性表 约瑟夫问题 https://www.luogu.com.cn/problem/P1996
题目大意：有规则抽取特定位置索引
1、删除、首尾添加、排序等等 =&amp;gt; vector
#include &amp;lt;iostream&amp;gt;using namespace std; int n, m, idx=0; #include &amp;lt;vector&amp;gt;vector&amp;lt;int&amp;gt; b; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) b.push_back(i); while (b.size() &amp;gt; 1) { idx = (idx+m-1)%b.size(); printf(&amp;#34;%d &amp;#34;, b[idx]); b.erase(b.begin()+idx); } printf(&amp;#34;%d\n&amp;#34;, b[0]); return 0; } 前&amp;amp;中&amp;amp;后缀 https://www.luogu.com.cn/problem/P1449
题目大意：解析前、中、后缀表达式，然后得到表达式的值的意思
1、前缀中缀后缀，表达式 =&amp;gt; 栈
#include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;lt;stack&amp;gt;char ch; int a, b, store; stack&amp;lt;int&amp;gt; s; int main() { while (ch !</description>
    </item>
    
    <item>
      <title>Algorithm11.1 数据结构 链表</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</guid>
      <description>[TOC]
数据结构 线性表 - 链表  1、STL库中的list，直接可以使用的链表
补：手写链表的基本结构以及名词区分：
基本结构就是指向第一个元素的指针（包含有第一个元素地址的变量）+后面一串的包含后序节点地址的节点
区分头指针、头节点、首元素节点
 头指针就是存放第一个节点的地址的变量，无论第一个节点是头节点（用来填补回圈的）还是首元素节点，都是第一个节点的地址（也就是指向第一个节点） 头节点：一个存首元素节点地址的一个节点，这个节点的数据域没有实际意义，为了拼凑地址而存在 首元素节点：第一个存实际数值的节点  2、手写链表
 单向链表  两个部分「数据域+指针域」+一个指针{记录链表第一个节点的地址}   单向链表双指针【主要用于用链接表模拟队列】  两个部分「数据域+指针域」+两个指针{记录链表第一个节点的地址front 和 记录链表最后一个节点的地址rear}   双向链表  三个部分「数据域+两个指针域」+两个指针{记录正方向链表的第一个节点的地址 和 记录反方向链表的第一个节点的地址}   循环链表  两个部分「数据域+指针域」+一个指针{记录链表第一个节点头节点的地址}+用于初始化回圈的头节点 注意：  需要用一个头节点组成回圈。 此时头指针初始化的位置是在循环链表的尾部，原因就是如果把它首尾相接的话，那么最后尾节点按理就是存放的首节点的地址，头指针就是指第一个节点的地址，所以头指针就相当于在尾节点的位置。     双向循环链表  三个部分「数据域+两个指针域」+两个指针{记录正方向链表的第一个节点的地址 和 记录反方向链表的第一个节点的地址}     队列排队问题 - 利用STL库中的链表进行实现 https://www.luogu.com.cn/problem/P1160
题目大意：在特定位置添加、插入成员，从而建立一个队列；然后通过调整相关的前后顺序位置，得到最后的队列
1、特定位置插入、前后顺序（相邻位置）调整 =&amp;gt; 链表 // 双向链表
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 100010int n, m, idx, tp; #include &amp;lt;list&amp;gt;list&amp;lt;int&amp;gt; l; using Iterator = list&amp;lt;int&amp;gt;::iterator; Iterator pos[maxn]; // 用于存储索引关系 bool erased[maxn]; int main() { // init  l.</description>
    </item>
    
    <item>
      <title>Algorithm11.2 数据结构 堆</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</guid>
      <description>[TOC]
数据结构 堆 &amp;amp; 手写堆  堆：
 分类：最大堆、最小堆 过程：首先按照完全二叉树的形式，将序列填补到初始的堆中  （堆-附加：利用堆的性质来判断是否是堆：「PAT1147」，判断方法就是直接对给定的层次遍历的序列来判断，是否满足a[i] &amp;gt; a[2&amp;lt;&amp;lt;i] &amp;amp;&amp;amp; a[i] &amp;gt; a[2&amp;lt;&amp;lt;i|1]或者a[i] &amp;lt; a[2&amp;lt;&amp;lt;i] &amp;amp;&amp;amp; a[i] &amp;lt; a[2&amp;lt;&amp;lt;i|1] ，来查看是否是最大堆或者最小堆
用到堆优化的思路不一定是用堆，也可能是通过利用优先队列进行优化【堆的优化的应用场景：解决重复排序问题，每添加一个新的元素【在线更新】，都要重新排一次序 =&amp;gt; 可以用堆进行优化】
用到堆的方式：
 手写堆：「例如下面的P3378手写堆 // P1631RMQ问题」的up/down方法来维护堆 直接利用优先队列来优化复杂度，优化的方式就是直接拿堆顶，进而取堆顶得到最大最小 或者 堆结构带来的排序「P2085取前最小」的每次拿堆顶，然后在线插入新的元素之后重新自动排序获取下一次的堆顶。   判断堆是否为最大堆、最小堆 https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648
1、判断是否是最大堆最小堆：直接判断父节点与两个子节点的的大小关系。
可以通过维护两个变量is_max = 1 / is_min = 1，当存在有子节点小于父节点=&amp;gt;不满足最小堆了把is_min = 0；当存在有子节点大于父节点=&amp;gt;不满足最小堆了把is_max = 0
最后看is_max和is_min两个变量，是否是最大最小堆。
// 从底部往上遍历 for (int j = 2; j &amp;lt;= m; ++j) { if (a[j] &amp;gt; a[j/2]) is_big = 0; else is_small = 0; } https://www.</description>
    </item>
    
    <item>
      <title>Algorithm11.3 数据结构 栈</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</guid>
      <description>[TOC]
数据结构 线性表 - 栈  1、通过STL库中的stack，直接可以使用的链表
2、通过手写栈
 利用「顺序表」实现：用数组来模拟容器，用变量来作为栈顶 利用「链接表』实现：用链表实现  链首做为栈底，链尾做为栈顶：栈顶添加O(n)，查看栈顶O(n)，栈顶移除O(n) 链首做为栈顶，链尾做为栈底：栈顶添加O(1)，查看栈顶O(1)，栈顶移除O(1)     进出栈顺序问题 - 利用STL库中的栈进行实现 https://www.luogu.com.cn/problem/P4387
题目大意：给定进栈顺序和出栈顺序，根据进栈顺序来比对出栈顺序是否正确
1、push、pop、empty
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 100010int t, len, in[maxn], out[maxn], idx_out; #include &amp;lt;stack&amp;gt;stack&amp;lt;int&amp;gt; s; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { // init  idx_out = 1; scanf(&amp;#34;%d&amp;#34;, &amp;amp;len); for (int i = 1; i &amp;lt;= len; ++i) scanf(&amp;#34;%d&amp;#34;, &amp;amp;in[i]); for (int i = 1; i &amp;lt;= len; ++i) scanf(&amp;#34;%d&amp;#34;, &amp;amp;out[i]); for (int i = 1; i &amp;lt;= len; ++i) { s.</description>
    </item>
    
    <item>
      <title>Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>[TOC]
数据结构 树 二叉树 性质 建树、前中后序遍历  树相关 遍历操作：
 【递归】先根遍历、后根遍历。看所有儿子节点和根节点的遍历顺序 【非递归】也是用队列先进先出作为数据结构来存    二叉树相关 两种实现方式：（基本的树结构是两种，如果转换为图进行储存也是可以的）
  「顺序表」结构体数组实现
  「链接表」二叉链表实现
  拓展方法：通过图方式进行存储
  树结构性质：
  对于各种二叉树都有的性质：各种类型的节点个数之间的关系
 叶子结点个数=度为2的节点个数+1（推导：连线个数=2*n2+1*n1+0*n0，节点个数=n2+n1+n0，连线个数+1=节点个数 =&amp;gt; n2+1 = n0）    对于完全二叉树：高度相关，pow(2, k-1) &amp;lt; n &amp;lt; pow(2, k)，这样可以反推出k的范围。
  遍历操作：
 基本的三种前中后序「主要根据碰到根节点的三个时机，分出了前中后序遍历」  【递归实现】 【非递归实现】通过 栈 模拟函数调用栈先进后出 来 模拟 递归前中后序遍历   【非递归】层次遍历：通过维护一个先进先出  遍历性质：
 前序 中序 后序 dfs序 相关性质 给出两个，推第三个  给出前+后【不带中】 =&amp;gt; 中序不一定唯一 给出中+前【带中】 =&amp;gt; 后序唯一 给出中+后【带中】 =&amp;gt; 前序唯一      树与二叉树之间转换 兄弟节点法，把当前节点的同层的右边节点按次顺到右儿子，一直这样下去。</description>
    </item>
    
    <item>
      <title>Algorithm11.5 数据结构 二叉类型相关树结构-哈夫曼树/二叉搜索树/红黑树/B&#43;树</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%A0%91%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91b&#43;%E6%A0%91/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E6%A0%91%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91b&#43;%E6%A0%91/</guid>
      <description>[TOC]
二叉类型相关数据结构 哈夫曼树 性质 实现-二叉链表 二叉链表实现 - 利用链表来链接起树的结构
1、节点中有两个指向叶子结点的指针。结构体的因为是二叉链表，所以和二叉树的类似。
struct node(){ int data; node * lchild; node * rchild; } *huffmantree, huffman[maxn];; 2、新增的数据结构：也就是huffman[maxn]，起作用就是储存所有的节点的。
对应的思路，每次挑出节点中值最小的两个，然后把这两个节点合成一个，然后进行排序，并把新产生的节点放到优先队列中，然后再选出两个最小的，一直这么迭代下去。
 通过一个vis数组，来将右儿子给闭掉，然后将左儿子的值更新为他们所形成的父亲节点的值。  node * HuffmanTree() { for (int i = 0; i &amp;lt; n - 1; i++) { for (int j = 0; j &amp;lt; n; ++j) if (!vis[j]) pq.push({huffman[j].data, j}); ll = pq.top().idx;pq.pop(); rr = pq.top().idx; while (!pq.empty()) pq.pop(); vis[rr] = 1; node * lnode = new node {huffman[ll].</description>
    </item>
    
    <item>
      <title>Algorithm11.6 数据结构 队列</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</guid>
      <description>[TOC]
数据结构 线性表 - 队列  1、STL库中的queue
2、手写队列
 利用「顺序表」实现：用数组来模拟容器，用front来作为队首，用rear来作为队尾 利用「链接表」实现：用链表实现  链首做为队首，链尾做为队尾：队尾添加O(n)，查看队首O(1)，栈顶移除O(1) 链首做为队尾，链尾做为队首：栈顶添加O(1)，查看栈顶O(n)，栈顶移除O(n)    3、利用「顺序表」手写队列的溢出问题
 假溢出「仅限于用顺序表/数组实现的队列」  出现的原因：由于队首front和队尾rear两个索引在一直往后推延，这样前面用过的地址空间就无法重复使用，在量巨大的情况下就会导致超过地址本来可承受的。 解决方案：通过搞成循环队列，这样原来用过的地址就可以进行重复利用，也不用回收   真溢出「仅限于循环队列，无论是哪种方式实现的」  出现的原因：循环队列不是普通队列的固定长度，所以一直往里边添加的话总会有溢出的时候。     </description>
    </item>
    
    <item>
      <title>Algorithm11.7 数据结构 ST表</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-st%E8%A1%A8/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-st%E8%A1%A8/</guid>
      <description>[TOC]
ST表-可重复贡献问题 // RMQ（Min/Max） // 区间gcd 区间min/max/gcd 区分与线段树 ？？？
https://www.luogu.com.cn/problem/P3865
模版 - ST表 题目大意：得到范围内（Range）最大值（Max）的若干次查询（Query）=&amp;gt;RMQ问题
1、倍增思想，核心就是二倍二倍的获取最大值，类似于二叉树结构的遍历过程，复杂度为O(nlogn)。
maxx[i][j]二维数组：维护的数据结构，表示[i, i+pow(2, j)-1]区间的最大值。=&amp;gt;i表示区间的起点，j表示倍增的倍数。所以在初始化的时候j所需要max的就是两个j-1倍数的区间来比较最大值(其中两个区间的起点分别是i和i+1&amp;lt;&amp;lt;(j-1))，也就是在这个倍增的倍数情况下，需要把起点往后挪的长度。
maxx[i][j] = max(maxx[i][j-1], max[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); 2、查询的时候反向解析
利用query函数来进行解析：先找到该区间对应的倍数，然后再顺着区间的右边界找到对应的查找区间，可以考虑到这个区间不一定是刚好划分好的二倍的区间，所以可以通过拼接子区间来获取最大的
int k = log2(r-l+1); return max(maxx[l][k], maxx[r-(1&amp;lt;&amp;lt;k)+1][k]); 3、注意数组不要开太大，因为倍增最多也就是21倍，2的21次方这么大的区间长度
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 1000010int n, m, a[maxn], maxx[maxn][21], ta, tb; // maxx[i][j]表示[i, i+pow(2, j)-1]的区间的最大值  inline int read() { char c=getchar();int x=0,f=1; while(c&amp;lt;&amp;#39;0&amp;#39;||c&amp;gt;&amp;#39;9&amp;#39;){if(c==&amp;#39;-&amp;#39;)f=-1;c=getchar();} while(c&amp;gt;=&amp;#39;0&amp;#39;&amp;amp;&amp;amp;c&amp;lt;=&amp;#39;9&amp;#39;){x=x*10+c-&amp;#39;0&amp;#39;;c=getchar();} return x*f; } // init maxx数组，通过迭代j来2倍率的速度进行初始化=&amp;gt;填补maxx数组 void init() { for (int i = 1; i &amp;lt;= n; ++i) maxx[i][0] = a[i]; for (int j = 1; j &amp;lt;= 21; ++j) for (int i = 1; i+(1&amp;lt;&amp;lt;j)-1 &amp;lt;= n; ++i) maxx[i][j] = max(maxx[i][j-1], maxx[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } int query(int l, int r) { int k = log2(r-l+1); return max(maxx[l][k], maxx[r-(1&amp;lt;&amp;lt;k)+1][k]); } int main() { n = read();m = read(); for (int i = 1; i &amp;lt;= n; ++i) a[i] = read(); init(); while (m--) { ta = read();tb = read(); printf(&amp;#34;%d\n&amp;#34;, query(ta, tb)); } return 0; } RMQ模版-最大和最小都有 【类似https://www.</description>
    </item>
    
    <item>
      <title>Algorithm11.8 数据结构 树状数组</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      <description>[TOC]
数据结构 树状数组 https://www.luogu.com.cn/problem/P3374
模版-区间求和(查询)、单点修改(操作) 0、lowbit()看当前节点的归属情况/看当前节点所管辖的节点的个数
eg：8(10) &amp;amp; -8(10) = 8 =&amp;gt; 根据树状数组结构图，就是8个节点
eg：4(10) &amp;amp; -4(10) = 4 =&amp;gt; 根据树状数组结构图，就是4个节点
eg：6(10) &amp;amp; -6(10) = 2 =&amp;gt; 根据树状数组结构图，就是2个节点
![image-20210308181959879](/Users/aczy156/Library/Application Support/typora-user-images/image-20210308181959879.png)
1、单点修改
=&amp;gt; 自下而上修改 =&amp;gt; c数组的索引pos从1开始往上找，但是要限定永远≤n =&amp;gt; 从下往上找的话，看当前的节点归属那个父节点范围，则需要pos+=lowbit(pos)，此时就可以直接爬升到父节点。
void single_add(int pos, int k) { while(pos &amp;lt;= n) { c[pos] += k; pos += lowbit(pos); } } 2、区间求和「注意这个区间求的是前缀和，也就是1到pos的和。如果区间和的话，可以通过两个前缀和相减得到」
=&amp;gt; 自上而下累加 =&amp;gt; c数组的索引pos从target目标开始往下找，但是要限定下限，不能让下限爆掉，pos≥1 =&amp;gt; 从上往下累加的话，看当前的节点归属那个的子节点，则需要pos-=lowbit(pos)，此时就可以直接下降到子节点。
int getsum(int pos) { int ans = 0; while(pos &amp;gt;= 1) { ans += c[pos]; pos -= lowbit(pos); } } #include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 500010int n, m, tm, tp, ta, tb, c[maxn]; int lowbit(int x) {return x &amp;amp; (-x);} void single_add(int pos, int k) { while (pos &amp;lt;= n) { c[pos] += k; pos += lowbit(pos); } } int getsum(int pos) { int ans = 0; while (pos &amp;gt;= 1) { ans += c[pos]; pos -= lowbit(pos); } return ans; } int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;tm);single_add(i, tm);} while (m--) { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;tp, &amp;amp;ta, &amp;amp;tb); if (tp-1) printf(&amp;#34;%d\n&amp;#34;, getsum(tb)-getsum(ta-1)); else single_add(ta, tb); } return 0; } 模版-区间修改(操作)、单点求和(查询) 区间修改+单点求和 模版：https://www.</description>
    </item>
    
    <item>
      <title>Algorithm12 并查集</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm12-%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm12-%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>[TOC]
并查集 模版-查看两个元素是否在一个集合中 https://www.luogu.com.cn/problem/P1551
题目大意：
1、findfa写法：return fa[x]==x?x:findfa(fa[x]);
 如果fa[x] == x，则代表这个节点就是代表这个集合的中心。 如果fa[x] != x，继续递归往上找，findfa(fa[x])  「路径压缩，把一条线的树结构给压缩成一个矮宽胖的类似于dom树结构的样式」：return fa[x]==x?x:fa[x]=findfa(fa[x]);
 通过在路径中对fa进行赋值，来保证路径上的fa都是那个父亲节点 可以看出指向关系的根。（类似题目找到某个节点的最终指向）  2、存放同个集合的关系：如果findfa(a)!=findafa(b)=&amp;gt;就可以直接让找到的顶上的直接赋给另一个的顶上。也即fa[findfa(a)]=findafa(b)或者fa[findfa(b)]=findafa(a)
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 5005int n, m, p, fa[maxn], ta, tb; int findfa(int x){return fa[x] == x?x:findfa(fa[x]);} int main() { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;n, &amp;amp;m, &amp;amp;p); // init  for (int i = 1; i &amp;lt;= n; ++i) fa[i]=i; for (int i = 1; i &amp;lt;= m; ++i) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;ta, &amp;amp;tb); if (findfa(ta) !</description>
    </item>
    
    <item>
      <title>Algorithm13 前缀和与差分</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm13-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm13-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</guid>
      <description>[TOC]
前缀和与差分  压缩时间复杂度：只要降一个等级的复杂度即可达到题解的情况
 经典情景：
 求和 计算个数   【下边的时间复杂度分析只针对选取左上和右下的端点】
O(n^2) =&amp;gt; O(n) ：一维上选取和最大的子区间
O(n^4) =&amp;gt; O(n^3) ：二维上选取区域和最大的子区间
O(n^5) =&amp;gt; O(n^4) ：定位了子区间之后，再加上一层遍历的点
 一维的 最大子区间和 https://www.luogu.com.cn/problem/P1115
题目大意：一维数组，求最大子区间的和
（一）、前缀和思想：维护一个sum来描述当前索引位置之前的是否要存留。大于零就存储，小于零就归零。
#include &amp;lt;iostream&amp;gt;using namespace std; int n, prefix, tem, ans=1&amp;lt;&amp;lt;31; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;prefix); while (--n) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;tem); prefix += tem; ans = max(ans, prefix); if (prefix &amp;lt; 0) prefix = 0; } printf(&amp;#34;%d\n&amp;#34;, ans); return 0; } （二）、dp思想</description>
    </item>
    
    <item>
      <title>Algorithm14.0 图论 数据结构存储形式</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.0-%E5%9B%BE%E8%AE%BA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.0-%E5%9B%BE%E8%AE%BA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F/</guid>
      <description>[TOC]
图论 四种数据结构存储形式 存纯边【无点集的一点关系】 // 数据结构：结构体「起点、终点、权重」 struct node { int from, to, cost; bool operator &amp;lt; (const node n) const{return cost &amp;lt; n.cost;} // kruskal初始化 =&amp;gt; 边权排序 }edge[maxedge]; // 遍历 for (int i = 1; i &amp;lt;= number_of_edge; i++) { int from = edge[i].from, to = edge[i].to, cost = edge[i].cost; } 邻接矩阵 // 数据结构：二维数组 int mp[maxpoint][maxpoint]; // 遍历 for (int i = 1; i &amp;lt;= number_of_point; i++) { for (int j = 1; j &amp;lt;= number_of_point; j++) { int from = i, to = j, cost = mp[i][j]; } } 邻接表 // 数据结构：向量+结构体「终点、权重」 struct node { int to, cost; }; vector&amp;lt;node&amp;gt; b[maxpoint]; // 遍历 for (int i = 1; i &amp;lt;= number_of_point; i++) { for (int j = 0; j &amp;lt; b[i].</description>
    </item>
    
    <item>
      <title>Algorithm14.1.1 Dijkstra</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.1.1-dijkstra/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.1.1-dijkstra/</guid>
      <description>[TOC]
最短路  博客引流：我的CSDN博客，关于最短路优化历程，洛谷P3379和P4779的优化历程
我的CSDN博客 洛谷P3371、P4779 最短路Dijikstra优化历程(邻接矩阵-＞邻接表-＞链式前向星-＞堆优化)
 Dijkstra+邻接矩阵【用mp[maxn][maxn]二维矩阵储存】 #include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 10010typedef long long ll; ll n, m, bg, dis[maxn], vis[maxn], mp[maxn][maxn], ta, tb, tc, tem, v; const int INF = (1&amp;lt;&amp;lt;31)-1; void dijkstra(){ for (int i = 1; i &amp;lt;= n; ++i) dis[i] = mp[bg][i]; vis[bg] = 1; for (int i = 1; i &amp;lt;= n; ++i) { tem = INF,v = 0; for (int j = 1; j &amp;lt;= n; ++j) if (!</description>
    </item>
    
    <item>
      <title>Algorithm14.1.2 Floyd</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.1.2-floyd/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.1.2-floyd/</guid>
      <description>[TOC]
最短路-Floyd Floyd - 最短路 （已经经过滚动数组优化，d数组只有两个维度，不需要k这个维度）+邻接矩阵【用mp[maxn][maxn]二维矩阵储存】
 核心数据结构：只需要一个d数组，经过滚动数组优化之后，只需要两个维度。 核心遍历过程：遍历一个中间分割点k，然后遍历两个节点i、j =&amp;gt; 分别时d数组的两个维度，来进行遍历 最后的结果全部储存在d数组中，包括任意点和任意点的最短路。  #include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 105; const int inf = (1&amp;lt;&amp;lt;31)-1; int n, m, d[maxn][maxn], ta, tb, tc; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= n; ++j) if (i != j) d[i][j] = inf; for (int i = 1; i &amp;lt;= m; ++i) { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;ta, &amp;amp;tb, &amp;amp;tc); d[ta][tb] = d[tb][ta] = tc; } for (int k = 1; k &amp;lt;= n; ++k) for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); return 0; } // 测试用例 // 输入 4 6 1 2 2 2 3 2 2 4 1 1 3 5 3 4 3 1 4 4 // 输出 =&amp;gt; 可以得到所有节点之间的距离 0 2 4 3 2 0 2 1 4 2 0 3 3 1 3 0 Floyd - 最小环 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm14.1.3 SPFA</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.1.3-spfa/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.1.3-spfa/</guid>
      <description>[TOC]
最短路-SPFA SPFA  数据结构类似于Dijkstra，也是d数组和vi/vis数组 首先起点入队，标记已达 开始循环遍历队列，此时不用判断是否已是vis。（Dijkstra是需要判断两次的） 出队，标记未达 遍历到之后再次给标记已达。  int d[maxpoint], vi[maxpoint]; queue&amp;lt;nd&amp;gt; spf; void spfa(int s) { for (int i = 1; i &amp;lt;= n; ++i) d[i] = INF;d[s] = 0; spf.push({0, s});vi[s] = 1; while (!spf.empty()) { nd nw = spf.front();spf.pop(); int nwpos = nw.pos; vi[nwpos] = 0; for (int i = head[nwpos]; i; i=edge[i].next) { int to = edge[i].to; if (d[to] &amp;gt; d[nwpos]+edge[i].cost) { d[to] = d[nwpos]+edge[i].</description>
    </item>
    
    <item>
      <title>Algorithm14.2 最小生成树</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.2-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.2-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>[TOC]
最小生成树  几种数据给出形式以及对应的解决方案
1、点a 点b 边ab权值 =&amp;gt; 邻接表vector来存 =&amp;gt; 优先kruskal
2、一个矩阵 =&amp;gt; 邻接矩阵来存【适合存点少线多的，也就是稠密图，如果稀疏的话，空间就爆炸了】 =&amp;gt; 优先prim（当然也可以手动提取，但是这样提取会很麻烦，因为边很多，有多少点就要考虑点个数平方个的边）
两种解决方案的大致思路：
1、kruskal克鲁斯卡尔：以边为核心，每次提取权值最小的边，判断是否要这个边的依据就是看这个边的两个端点是否已经在同一个树中
2、prim普里姆：以点为核心，每次拓展 树点集 和 外部点 之间的最小值，从而把外部点拉入到树点集中去
 https://www.luogu.com.cn/problem/P3366
模版 - Prim解法 &amp;ndash; 邻接矩阵 #include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 5005int n, m, dis[maxn], vis[maxn], mp[maxn][maxn], tem, v, ta, tb, tc, sum; const int INF = 0x3f3f3f; void dijkstra(){ for (int i = 1; i &amp;lt;= n; ++i) dis[i] = mp[1][i]; for (int i = 2; i &amp;lt;= n; ++i) { tem = INF; v = 1;vis[1] = 1; for (int j = 2; j &amp;lt;= n; ++j) if (!</description>
    </item>
    
    <item>
      <title>Algorithm14.3 拓扑图</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.3-%E6%8B%93%E6%89%91%E5%9B%BE/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.3-%E6%8B%93%E6%89%91%E5%9B%BE/</guid>
      <description>[TOC]
拓扑图 https://www.luogu.com.cn/problem/P4017
1、图存储的数据结构：邻接矩阵，mp[a][b]，等于1的时候表示的是
2、根据入度、出度来看是否添加进入队列。
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 5005int n, m, mp[maxn][maxn], in[maxn], out[maxn], ta, tb, ans[maxn], final; #include &amp;lt;queue&amp;gt;queue&amp;lt;int&amp;gt; q; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= m; ++i) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;ta, &amp;amp;tb); mp[ta][tb] = 1; out[ta]++;in[tb]++; } for (int i = 1; i &amp;lt;= n; ++i) if (!in[i]) {ans[i] = 1;q.push(i);} while (!q.empty()) { int nw = q.front();q.pop(); for (int i = 1; i &amp;lt;= n; ++i){ if (mp[nw][i]) { ans[i] += ans[nw];ans[i] %= 80112002; in[i]--; if (!</description>
    </item>
    
    <item>
      <title>Algorithm14.4 最近公共祖先(LCA)</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.4-lca%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.4-lca%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>[TOC]
LCA最近公共祖先 dfs深搜
 更新depth深度数组 depth[maxpoint] 更新p爬升数组 p[maxpoint][21]  LCA
 利用depth深度数组来进行爬升之前的微调 =&amp;gt; 将两个节点调整到同一高度 利用p数组来进行爬升，获取最近公共祖先  模版 LCA https://www.luogu.com.cn/problem/P3379
1、数据结构：
 链式前向星储存图结构：  用结构体储存to和next，类似于可延展的vector所描述的邻接表
struct node { int to, next; }edge[maxpoint&amp;lt;&amp;lt;1]; int head[maxpoint], tot; // 注意：edge边的数量要开到二倍，因为 添加边 =&amp;gt;利用tot全局索引指引。
void addedge(int from, int to) { edge[++tot].to = to; edge[tot].next = head[from]; head[from] = tot; }  LCA的数据结构：depth[maxpoint]和p[maxpoint][21]  dfs构造depth深度数组和p爬升数组
void dfs(int from, int fa) { depth[from] = depth[fa] + 1; // 更新depth深度数组  for (int i = 1; (1&amp;lt;&amp;lt;i) &amp;lt;= depth[from]; ++i) p[from][i] = p[p[from][i-1]][i-1]; // 更新p爬升数组  for (int i = head[from]; i; i=edge[i].</description>
    </item>
    
    <item>
      <title>Algorithm14.5 二分图-最大匹配</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</guid>
      <description>[TOC]
二分图 最大匹配 模版 https://www.luogu.com.cn/problem/P3386
二分图变式 关押罪犯：两个监狱，
https://www.luogu.com.cn/problem/P1525</description>
    </item>
    
    <item>
      <title>Algorithm14.5.1 二分图-染色</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.5.1-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.5.1-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2/</guid>
      <description>[TOC]
二分图 最大匹配 模版 https://www.luogu.com.cn/problem/P3386
二分图变式 关押罪犯：两个监狱，
https://www.luogu.com.cn/problem/P1525</description>
    </item>
    
    <item>
      <title>Algorithm14.6 图的遍历与搜索</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.6-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.6-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E6%90%9C%E7%B4%A2/</guid>
      <description>[TOC]
图的遍历与搜索 模版 dfs &amp;amp; bfs https://www.luogu.com.cn/problem/P5318
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxpoint 100010#define maxedge 1000010int n, m, ta, tb, vis[maxpoint]; struct ed { int from, to; bool operator &amp;lt; (const ed e) const { if (from == e.from) return to &amp;gt; e.to;return from &amp;gt;e.from;} }t[maxedge]; struct node { int to, next; }edge[maxedge];int head[maxpoint], tot; #include &amp;lt;queue&amp;gt;queue&amp;lt;int&amp;gt;pq; #include &amp;lt;cstring&amp;gt;#define cl(a, b) memset(a, b, sizeof(a))#include &amp;lt;algorithm&amp;gt; void addedge(int from, int to) { edge[++tot].</description>
    </item>
    
    <item>
      <title>Algorithm14.7 树的图解法</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.7-%E6%A0%91%E7%9A%84%E5%9B%BE%E8%A7%A3%E6%B3%95/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.7-%E6%A0%91%E7%9A%84%E5%9B%BE%E8%A7%A3%E6%B3%95/</guid>
      <description>[TOC]
树的图解法  树【不仅限于二叉树，多叉树都没问题的】转化为图【无向图】
 树的深度：【图中其他所有点】 离 【根节点对应的图中的节点】 距离最远的 树的宽度：图中距离 【根节点对应的图中的节点】 各个不同距离中，个数最多的点（例如，距离为1的点有2个，距离为2的点有3个，距离为3的点有1个，所以宽度为3） LCA问题：可以通过图论中的最短路来解决=》floyd直接暴力出来   基础转换 https://www.luogu.com.cn/problem/P3884
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 105; const int inf = 1e8+9; int n, d[maxn][maxn], ta, tb, depth, w[maxn], width = 1, ans; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= n; ++j) if (i != j) d[i][j] = inf; for (int i = 1; i &amp;lt; n; ++i) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;ta, &amp;amp;tb); d[ta][tb] = 1; d[tb][ta] = 2; } for (int k = 1; k &amp;lt;= n; ++k) for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;ta, &amp;amp;tb); for (int i = 1; i &amp;lt;= n; ++i) { depth = max(depth, d[1][i]); w[d[1][i]]++; } for (int i = 1; i &amp;lt;= depth+1; ++i) width = max(width, w[i]); printf(&amp;#34;%d\n%d\n%d\n&amp;#34;, depth+1, width, d[ta][tb]); return 0; } </description>
    </item>
    
    <item>
      <title>Algorithm15 倍增</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm15-%E5%80%8D%E5%A2%9E/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm15-%E5%80%8D%E5%A2%9E/</guid>
      <description>[TOC]
倍增 拼凑砝码 https://www.luogu.com.cn/problem/P2347
#include &amp;lt;iostream&amp;gt;using namespace std; int w[8] = {1, 2, 3, 5, 10, 20}, t; #include &amp;lt;bitset&amp;gt;bitset&amp;lt;1010&amp;gt; s; int main() { s[0] = 1; for (int i = 0; i &amp;lt; 6; ++i) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); for (int j = 0; j &amp;lt; t; ++j) s |= s&amp;lt;&amp;lt;w[i]; } printf(&amp;#34;Total=%d\n&amp;#34;, s.count()-1); return 0; } </description>
    </item>
    
    <item>
      <title>Algorithm16 高精度&amp;大数运算</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm16-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm16-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/</guid>
      <description>[TOC]
高精度 &amp;amp; 大数运算 （一）高精度除法-高精度除低精度 &amp;lt; 高精度加法 &amp;lt; 高精度乘法 &amp;lt; 高精度减法 &amp;lt; 高精度除法-高精度除高精度
（二）语言：python，Java的四则运算自带高精度；C/C++需要利用字符串/字符数组来读取大数并开数组存放然后通过模拟竖式运算来计算。
大数加法 https://www.luogu.com.cn/problem/P1601
1、读入用字符数组读入。
2、做加法通过考虑进位位。
3、输出的时候特判进位位是否需要单独输出
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 100005char sa[maxn], sb[maxn]; int a[maxn], b[maxn], ans[maxn], lena, lenb ,lenans, ap; #include &amp;lt;cmath&amp;gt;#include &amp;lt;string.h&amp;gt; void read() { lena = strlen(sa);lenb = strlen(sb); lenans = max(lena, lenb); for (int i = 0; i &amp;lt; lena; ++i) a[i] = sa[lena-1-i] - &amp;#39;0&amp;#39;; for (int i = 0; i &amp;lt; lenb; ++i) b[i] = sb[lenb-1-i] - &amp;#39;0&amp;#39;; } void add(int a[], int b[]) { for (int i = 0; i &amp;lt; lenans; ++i) { ans[i] = a[i]+b[i]+ap; ap = ans[i]/10; ans[i]%=10; } } void write() { if (ap) printf(&amp;#34;%d&amp;#34;, ap); for (int i = lenans-1; i &amp;gt;= 0; --i) printf(&amp;#34;%d&amp;#34;, ans[i]); } int main() { scanf(&amp;#34;%s%s&amp;#34;, sa, sb); read(); add(a, b); write(); return 0; } 大数减法 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm19 递推与递归</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm19-%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm19-%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/</guid>
      <description>[TOC]
递推与递归 斐波那契数列 （高精度） https://www.luogu.com.cn/problem/P1255
(相似题目：https://www.luogu.com.cn/problem/P2437)
题目大意：上楼梯，一次上一步或者一次上两步，问上n阶的楼梯可以有多少种走法
1、递推公式：d[i] = d[i-1]+d[i-2];
2、斐波那契数列在n=50的时候就已经将int爆掉，所以如果n=5000的时候需要用高精度。
AC代码：
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 5005typedef long long ll; #include &amp;lt;cstring&amp;gt;const int N = 2005; struct BigInt { int len, s[N]; BigInt() {memset(s, 0, sizeof(s));len = 1;} BigInt(int num) { *this = num; } BigInt(char *num) { *this = num; } BigInt operator=(int num) { char c[N]; sprintf(c, &amp;#34;%d&amp;#34;, num); *this = c; return *this; } BigInt operator=(const char *num) { len = strlen(num); for (int i = 0; i &amp;lt; len; i++) s[i] = num[len - 1 - i] - &amp;#39;0&amp;#39;; return *this; } string str() { string res = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; len; i++) res = (char) (s[i] + &amp;#39;0&amp;#39;) + res; return res; } void clean() {while (len &amp;gt; 1 &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>Algorithm19.1 递归</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm19.1-%E9%80%92%E5%BD%92/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm19.1-%E9%80%92%E5%BD%92/</guid>
      <description>[TOC]
递归  主要题型：对于一个字串，然后子字串同样进行递归【带有优先级的计算式】
两种方案：
 第一种，先输入进来，然后整体进行递归，递归的参数就是这个整体字串 第二种，边输入边递归，这样就可以利用一些getchar，char字符来进行输入的直接判断（例如如果字串一部分为ADD567，如果不知道长度的的话还有遍历判断，如果直接边输入边解析，那就可以直接利用cin来直接分割，cin&amp;raquo;字串&amp;raquo;数字，就自动分割了）   指令移动 https://www.luogu.com.cn/problem/P1322
#include &amp;lt;iostream&amp;gt;using namespace std; int solve() { char c; string tp; int num, ans, d; while (cin&amp;gt;&amp;gt;c) { if (c == &amp;#39;]&amp;#39;) break; cin&amp;gt;&amp;gt;tp&amp;gt;&amp;gt;num; if (c == &amp;#39;R&amp;#39;) { d = getchar(); ans += num*solve(); d = getchar(); } if (c == &amp;#39;B&amp;#39;) d = getchar(), ans -= num; if (c == &amp;#39;F&amp;#39;) d = getchar(), ans += num; if (d == int(&amp;#39;]&amp;#39;)) break; } return ans; } int main() { printf(&amp;#34;%d\n&amp;#34;, solve()); return 0; } </description>
    </item>
    
    <item>
      <title>Algorithm2.1 背包dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.1-%E8%83%8C%E5%8C%85dp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.1-%E8%83%8C%E5%8C%85dp/</guid>
      <description>[TOC]
背包dp   01背包：每种物品仅一个  体积逆序遍历   完全背包：每种物品有无限个  体积升序遍历   多重背包：每种物品有具体个数  外层是体积逆序遍历  内层是个数遍历     分组背包：每种物品仅一个，且不同物品有自己所属的组别 多维代价背包：每种物品不仅占用空间，而且占用金钱 多维目的背包：每种物品不仅具有价值1，而且具有价值2   01背包 装配组合//路径问题 https://www.luogu.com.cn/problem/P1164
题目大意：
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 102#define maxm 10010int n, m, a[maxn], dp[maxm]; // dp[i]表示容量为i的到达种类 // 初始化：只知道到给定容量的这些的到达次数是1，所以直接 dp[a[j]] = 1; // 状态转移方程：dp[i] = dp[i-a[j]]  int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int j = 0; j &amp;lt; n; ++j) scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[j]); // init  dp[0] = 1; for (int j = 0; j &amp;lt; n; ++j) for (int i = m; i &amp;gt;= a[i]; --i) dp[i] += dp[i-a[j]]; printf(&amp;#34;%d\n&amp;#34;, dp[m]); return 0; } 固定容量 最大价值 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm2.10 坐标系dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.10-o%E4%BA%8C%E7%BB%B4%E5%9D%90%E6%A0%87%E8%BD%B4dp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.10-o%E4%BA%8C%E7%BB%B4%E5%9D%90%E6%A0%87%E8%BD%B4dp/</guid>
      <description>[TOC]
坐标系dp  区域最大：
 最大正方形 &amp;lt;-&amp;gt; 最大正方形变式 最大矩形（包括正方形）   最大正方形 https://www.luogu.com.cn/problem/P1387
 题目大意：给出一个二维坐标系中，找出里边全部是1的一个正方形的最大长度
 初始化：维护一个dp[maxn][maxn],dp[i][j]表示在第i，j的这个点上的最大正方形
状态转移方程：
if (a[i][j]) dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j]))+1; 完整代码：
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 105; int n, m, a[maxn][maxn], dp[maxn][maxn], ans; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= m; ++j) scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]); for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= m; ++j) if (a[i][j]) dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))+1, ans = max(ans, dp[i][j]); printf(&amp;#34;%d\n&amp;#34;, ans); return 0; } 最大矩形（包括正方形） https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>Algorithm2.2 区间dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.2-%E5%8C%BA%E9%97%B4dp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.2-%E5%8C%BA%E9%97%B4dp/</guid>
      <description>[TOC]
区间dp 区间基本提取 https://www.luogu.com.cn/problem/P2426
题目大意：删除一段数组的数，代价为这个区间的左右端点值的差的绝对值*长度，求全部删去的最大代价。
区间DP的水题，维护一个dp二维数组，然后三层遍历左右端点+中间割点，利用状态转移方程dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])即可。
注意：要上来初始化一下，初始化的值就是运算法则算出来的，而dp所做的就是排列组合来搜索组合。
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 105; int n, a[maxn], dp[maxn][maxn]; // dp[i][j] 表示区间[i, j]所获得的最大价值 // dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]);  int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; ++i) scanf(&amp;#34;%d&amp;#34;, a+i); for (int i = 1; i &amp;lt;= n; ++i) for (int l = 0; l+i &amp;lt;= n; ++l) if (l == 0) dp[i][i+l] = a[i]; else dp[i][i+l] = abs(a[i]-a[i+l])*(l+1); for (int i = 1; i &amp;lt;= n; ++i) for (int j = i+1; j &amp;lt;= n; ++j) for (int k = i; k &amp;lt;= j; ++k) dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]); printf(&amp;#34;%d\n&amp;#34;, dp[1][n]); return 0; } 石子合并（线型） 石子合并（环形） https://www.</description>
    </item>
    
    <item>
      <title>Algorithm2.3 状压dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.3-%E7%8A%B6%E5%8E%8Bdp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.3-%E7%8A%B6%E5%8E%8Bdp/</guid>
      <description>[TOC]
状压dp  主要特征：n较小 =&amp;gt; 暴搜或者状压。【所以主要特征就是可以通过暴力搜索搜出来，但是不能过题，需要用dp，把所有要搜索到的状态压缩到一个01字串中，每个字符都表示】
主要思路：就是将本来某一行的状态是或否的唯二的两种【可能本来需要用数组来储存的】 =&amp;gt; 通过用二进制【01来进行储存】
主要原因：用于解决情况之间的耦合性太复杂（就例如八皇后，看上下左右斜上下这些，直接通过压缩成字符串的状态然后来进行位运算即可），如果直接循环遍历去判断的话太麻烦，所以通过状态压缩，
 把本来是需要用数组表示的数据结构=&amp;gt;用一个字串直接整体表示 把本来需要循环来计算的=&amp;gt;用位运算来计算   互不侵犯：https://www.luogu.com.cn/problem/P1896
题目大意：类似于八皇后，只不过八皇后是一行一列都会受影响，而这个题只是相邻的上下行受影响。问放n个皇后最多有多少种方式
1、数据结构：
dp[i][j][s]表示在第i行，且第i行的状态为j时，他所需要的国王的个数为s个，此时的种类数量。
2、遍历层次：遍历各个层-&amp;gt;遍历某一层所有的可能的状态-&amp;gt;遍历所需要的国王的个数-&amp;gt;遍历上一行的状态查看是否冲突sit[j]&amp;amp;sit[t] sit[j]&amp;gt;&amp;gt;1&amp;amp;sit[t] sit[j]&amp;lt;&amp;lt;1&amp;amp;sit[t] ，查看这些状态是否冲突
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 10#define maxsit (1&amp;lt;&amp;lt;10)+50#define maxk 105int n, k, sit[maxk], cnt_sit, num[maxk]; // dp[i][j][s] 表示在第i行，这一行的状态为j（二进制所转换成的十进制之后的数），放了s个目标 的总方案数 typedef long long LL; LL dp[maxn][maxsit][maxk], ans=0; // 首先预处理单独这一行，可能的状态，相互之间不冲突，也就是没有相邻的。【注意是线性的，不是环形的，也就是说101这种的是完全可以的】 void init() { for (int i = 0; i &amp;lt; (1&amp;lt;&amp;lt;n); ++i) { if (i &amp;amp; (i&amp;lt;&amp;lt;1)) continue; int sum = 0; for (int j = 0; j &amp;lt; n; ++j) if (i &amp;amp; (1&amp;lt;&amp;lt;j)) sum++; sit[++cnt_sit] = i; num[cnt_sit] = sum; } } void solve() { dp[0][1][0] = 1; for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= cnt_sit; ++j) for (int l = num[j]; l &amp;lt;= k; ++l) for (int t = 1; t &amp;lt;= cnt_sit; ++t) if (!</description>
    </item>
    
    <item>
      <title>Algorithm2.4 树型dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.4-%E6%A0%91%E5%9E%8Bdp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.4-%E6%A0%91%E5%9E%8Bdp/</guid>
      <description>[TOC]
树型dp  题目风格：给出树上的每个节点的值，然后给出
思路：
 利用链式前向星存储  对于n叉树的话，这样存储最好，因为这样在每一层的节点对于他的子叶遍历时直接用链式前向星挨个遍历即可 对于二叉树的话，可以直接用二叉链表储存，用链式前向星也可以   在递归当前节点时，递归他的所有叶子结点 在递归回来之后，修改dp数组，递归出来之后其子树的值是被更新过的，所以此时可以进行更新   最大子树和 https://www.luogu.com.cn/problem/P1122
题目大意：获取该棵树中最大的子树和
对于该题：
 数据结构：链式前向星储存，然后通过维护一个dp[i]数组，表示第i个节点为根的子树的最大和。 dp状态转移方程：dp[x] = max(dp[x], dp[x]+dp[to]);  #include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 2e4+9; int n, dp[maxn], in[maxn], ta, tb; struct node { int to, next; }edges[maxn&amp;lt;&amp;lt;1];int head[maxn], tot; void addedge(int from, int to) { edges[++tot].to = to; edges[tot].next = head[from]; head[from] = tot; in[to]++; } void tree_dp(int x) { for (int i = head[x]; i; i=edges[i].</description>
    </item>
    
    <item>
      <title>Algorithm2.6 计数dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.6-%E8%AE%A1%E6%95%B0dp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.6-%E8%AE%A1%E6%95%B0dp/</guid>
      <description>[TOC]
计数dp  典型：
 对一个区域进行划分，划分种类  随意划分：P1025，直接给定一个数以及要划分的份数，然后看这个数有多少种分法 按照给定的要求划分：P1077，直接卡死了每一个点上的约定范围 按照递增/递减的方式划分：P1806，直接按照递增着划分      随意划分 https://www.luogu.com.cn/problem/P1025
按照给定要求划分 https://www.luogu.com.cn/problem/P1077
递增/递减划分 https://www.luogu.com.cn/problem/P1806
每一步都有可能是从任意之前的某一步跳过来的，因为只要保证递增就好了。也就是第一次是1次，那么第2次必定第一次的次数递增上来，那么第三次必定包括第一次和第二次递增上来。
=&amp;gt;每次只需要把自己前面所有的点的值都加起来即可
#include &amp;lt;iostream&amp;gt;using namespace std; typedef long long ll; const int maxn = 509; ll n, dp[maxn]; int main() { scanf(&amp;#34;%lld&amp;#34;, &amp;amp;n); dp[0] = 1; for (int i = 1; i &amp;lt;= n; ++i) for (int j = n; j &amp;gt;= i; --j) dp[j] += dp[j-i]; printf(&amp;#34;%lld\n&amp;#34;, dp[n]-1); return 0; } </description>
    </item>
    
    <item>
      <title>Algorithm2.7 线性dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.7-%E7%BA%BF%E6%80%A7dp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.7-%E7%BA%BF%E6%80%A7dp/</guid>
      <description>[TOC]
线性dp 时间线问题 https://www.luogu.com.cn/problem/P1095
题目大意：时间线上，每秒钟 =&amp;gt; 可以选择a方式，属性c变化1；可以选择b方式，属性c变化2。
1、dp[i]表示在时间为i的时候，最远可到达的距离。
2、预处理：由于已知了a方式更好，那么可以优先通过a方式对数据dp进行预处理
3、状态转移方程：dp[i] = max(dp[i], dp[i-1]+17)
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 300010int m, s, t, dp[maxn]; int main() { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;m, &amp;amp;s, &amp;amp;t); // 预处理  for (int i = 1; i &amp;lt;= t; ++i) if (m &amp;gt;= 10) {m-=10;dp[i] = dp[i-1]+60;} else {m+=4;dp[i] = dp[i-1];} // 状态转移  for (int i = 1; i &amp;lt;= t; ++i) dp[i] = max(dp[i], dp[i-1]+17); if (dp[t] &amp;gt;= s) { printf(&amp;#34;Yes\n&amp;#34;); for (int i = 1; i &amp;lt;= t; ++i) if (dp[i] &amp;gt;= s) {printf(&amp;#34;%d\n&amp;#34;, i);break;} } else printf(&amp;#34;No\n%d&amp;#34;, dp[t]); return 0; } https://www.</description>
    </item>
    
    <item>
      <title>Algorithm2.8 基础dp</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.8-o%E5%9F%BA%E7%A1%80dp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.8-o%E5%9F%BA%E7%A1%80dp/</guid>
      <description>[TOC]
基础dp 数字三角形 https://www.luogu.com.cn/problem/P1216
题目大意：给一个三角形矩阵，然后从上往下走，怎么才能走的总量最大。
1、// 上往下 =&amp;gt; 初始化三角形的上边两条边
初始化：dp[i][0] = dp[i-1][0]+a[i][0], dp[i][i] = dp[i-1][i-1]+a[i][i]; 状态转移方程：dp[i][j] = max(dp[i-1][j-1],dp[i-1][j])+a[i][j];
2、下往上 =&amp;gt; 初始化最下边的那条边
初始化： dp[r-1][i] = a[r-1][i]; 状态转移方程：dp[i][j] = max(dp[i+1][i], dp[i+1][i+1])+a[i][j];
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 1005int r, a[maxn][maxn], dp[maxn][maxn], ans = 0; #include &amp;lt;cmath&amp;gt;// 上往下 =&amp;gt; 初始化三角形的上边两条边(dp[i][0] = dp[i-1][0]+a[i][0], dp[i][i] = dp[i-1][i-1]+a[i][i];) // dp[i][j] = max(dp[i-1][j-1],dp[i-1][j])+a[i][j]; // 下往上 =&amp;gt; 初始化最下边的那条边 dp[r-1][i] = a[r-1][i]; // dp[i][j] = max(dp[i+1][i], dp[i+1][i+1])+a[i][j];  int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;r); for (int i = 0; i &amp;lt; r; ++i) for (int j = 0; j &amp;lt; i + 1; ++j) scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]); //init  for (int i = 0; i &amp;lt; r; ++i) dp[r-1][i] = a[r-1][i]; for (int i = r-2; i &amp;gt;= 0; --i) for (int j = 0; j &amp;lt; i + 1; ++j) dp[i][j] = max(dp[i+1][j], dp[i+1][j+1])+a[i][j]; printf(&amp;#34;%d\n&amp;#34;, dp[0][0]); /* * // init dp[0][0] = a[0][0]; for (int i = 1; i &amp;lt; r; ++i) dp[i][0] = dp[i-1][0]+a[i][0], dp[i][i] = dp[i-1][i-1]+a[i][i]; for (int i = 2; i &amp;lt; r; ++i) for (int j = 1; j &amp;lt; i ; ++j) dp[i][j] = max(dp[i-1][j-1],dp[i-1][j])+a[i][j]; for (int i = 0; i &amp;lt; r; ++i) ans = max(ans, dp[r-1][i]); printf(&amp;#34;%d\n&amp;#34;, ans); */ return 0; } 数字三角形变形 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm2.9 dp思维</title>
      <link>http://www.chenranfei.site/posts/acm/dp/algorithm2.9-o%E6%80%9D%E7%BB%B4dp/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/dp/algorithm2.9-o%E6%80%9D%E7%BB%B4dp/</guid>
      <description>[TOC]
思维 &amp;amp; dp Leetcode1578-valid-palindrome 1578. 避免重复字母的最小删除成本
题目大意：
1、结合贪心思想，永远把相邻的最小的给加进去，ans += min(cost[i-1], cost[i])
2、状态的推进更新，例如str=&amp;quot;aaa&amp;quot;，cost分别为4 3 5，在更新4 3时候就要把状态退后，用这两个的最大的去比【因为最大的才是真正留下来的】，所以要用cost[i] = max(cost[i-1], cost[i])来保留状态
int minCost(string s, vector&amp;lt;int&amp;gt;&amp;amp; cost) { int ans = 0; for (int i = 1; i &amp;lt; s.length(); i++){ if (s[i] == s[i-1]){ ans += min(cost[i-1], cost[i]); cost[i] = max(cost[i-1], cost[i]); } } return ans; } 「循环」一圈形式的dp https://www.luogu.com.cn/problem/P1057
题目大意：
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 32int n, t, dp[maxn][maxn]; // dp[i][j]表示第i次传球第j个人到自己手上的方式总数 // 初始化：第一次也就是第一个人是1，其他都是0。也就是dp[0][0] = 1 // 状态转移：某人某次传球到自己手上的方式总数是在上一次传到两个旁边的人手上之和 // dp[i][j] = dp[i-1][j-1]+dp[i-1][j+1] (注意对圈的边界的人的特判)  int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;t); // init  dp[0][0] = 1; for (int i = 1; i &amp;lt; t; ++i) for (int j = 0; j &amp;lt; n; ++j) if (j == 0) dp[i][j] = dp[i-1][1]+dp[i-1][n-1]; else if (j == n-1) dp[i][j] = dp[i-1][n-2]+dp[i-1][0]; else dp[i][j] = dp[i-1][j-1]+dp[i-1][j+1]; printf(&amp;#34;%d\n&amp;#34;, dp[t-1][0]); return 0; } 「回文」判断最长回文串  bool dp[i][j]表示从[i,j]这一段是否为回文串 状态转移方程：dp[i][j] = (s[i] == s[j] &amp;amp;&amp;amp; (j-i == 1||dp[i+1]dp[j-1]))?</description>
    </item>
    
    <item>
      <title>Algorithm20.1 STL map</title>
      <link>http://www.chenranfei.site/posts/acm/stl/algorithm20.1-stl-map/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/stl/algorithm20.1-stl-map/</guid>
      <description>[TOC]
STL - map  【注意，此处的map是指的c++STL的map，c++STL的map的底层时红黑树，而Java的map的底层是哈希，类似于unordered_map，本质不同】
map底层：红黑树（一种非严格意义上的平衡二叉树）【利用二叉树来进行查询、插入、删除=&amp;gt;O(logn)】map内部所有的数据都是无重复+有序的
map有序性：map的key需要定义operator &amp;lt;。一般的数据类型系统已经确定了（如果是结构体做key的话，需要重载小于号。）
  unordered_map底层：hash_value【利用哈希来进行查询、插入、删除=&amp;gt;O(1)】unordered_map内部的数据只保证无重复 （不能保证有序）
unordered_map无重复性：unordered_map需要重载 == ，因为他判断重复就是看 ==。一般的数据类型系统已经确定了（如果是结构体做key的话，需要重载==。）
  vector+pair实现：
  map与unordered_map VS set与multiset:
map有序，而unordered_map的无序性，但是两者都保持的是key唯一。
set唯一，而multiset不唯一，可重复，但是两者都保持的是有序。
 查看是否已经映射 https://www.luogu.com.cn/problem/P1918
#include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;lt;map&amp;gt;map&amp;lt;int, int&amp;gt; mp; int n, m, t; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; ++i) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;t);mp[t] = i;} scanf(&amp;#34;%d&amp;#34;, &amp;amp;m); while (m--) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); if (mp.count(t)) printf(&amp;#34;%d\n&amp;#34;, mp[t]); else printf(&amp;#34;0\n&amp;#34;); } return 0; } 管理系统映射 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm20.2 STL set</title>
      <link>http://www.chenranfei.site/posts/acm/stl/algorithm20.2-stl-set/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/stl/algorithm20.2-stl-set/</guid>
      <description>[TOC]
STL - set set基础语法整理博客：
https://www.luogu.com.cn/blog/communist/stl-zheng-li-zhi-set
 set底层：红黑树
set关键字唯一性【类似于map中的key，只出现一次】：保证set中所有元素只出现一次
set序列递增性：如果不是int的话需要重载运算符
使用场景：维护一个不重复的数据结构 =》 类似于unique的结构【拓展延伸：可以维护一个结构体，然后来看是否重复】
  multiset底层：红黑树
multiset关键字不唯一，可重复性
  map与unordered_map VS set与multiset:
map有序，而unordered_map的无序性，但是两者都保持的是key唯一。
set唯一，而multiset不唯一，可重复，但是两者都保持的是有序。
 basic
int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; ++i) scanf(&amp;#34;%d&amp;#34;, a+i); set&amp;lt;int&amp;gt; s(a+1, a+1+n); auto iter = s.begin(); // 输出，发现保证了有序性  while (iter != s.end()) { printf(&amp;#34;%d &amp;#34;, *iter);iter++; } // 然后再插入新的元素，查看是否有去重复  cin&amp;gt;&amp;gt;t; s.insert(t); cout&amp;lt;&amp;lt;endl; auto iter2 = s.</description>
    </item>
    
    <item>
      <title>Algorithm21 博弈论</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%8D%9A%E5%BC%88%E8%AE%BA/algorithm21-%E5%8D%9A%E5%BC%88%E8%AE%BA/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%8D%9A%E5%BC%88%E8%AE%BA/algorithm21-%E5%8D%9A%E5%BC%88%E8%AE%BA/</guid>
      <description>[TOC]
博弈论    巴什博弈 【bash game】 威佐夫博弈 【Wythoff game】 尼姆博弈 【Nimm game】 斐波那契博弈   巴什博弈 题目大意：
 情景：一堆两人。 方式：每人每回合拿1～m个。 问题：给定石头总数，问先手是否必胜。  思路：先手在石头总数为n%(1+m) == 0的时候必败，在其余时候必胜。因为先手可以总保证在每回合让自己和对手拿的总数为(1+m)个，所以到最后一轮对手无论拿1～m个都没用，都必败。
威佐夫博弈 题目大意：
 情景：两堆两人。 方式：每人每回合 从一堆中拿若干个 或者 从两堆中各拿相同个。 问题：给定两堆石头数量，问先手是否必胜。  尼姆博弈 题目大意：
 情景：n堆两人。 方式：每人每回合 从一堆中拿若干个。 问题：给定若干堆石头数量，问先手是否必胜。  变式：
题目大意：
 情景：n堆两人。 方式：每人每回合 从一堆中拿一个【那一堆不能是对手上回合拿过的堆】  </description>
    </item>
    
    <item>
      <title>Algorithm22 数据结构 离散化</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A6%BB%E6%95%A3%E5%8C%96/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A6%BB%E6%95%A3%E5%8C%96/</guid>
      <description>[TOC]
数据结构 离散化  本质：是一种哈希，将原数组进行哈希映射，映射前后仍然保持全序/偏序
过程：排序-&amp;gt;去重-&amp;gt;索引（对应到stl中就是首先sort排序-&amp;gt;然后unique去重-&amp;gt;最后lowerbound二分找位置作为索引）
demo1：1,23424,21472313246768,6594,95,0,65535313=&amp;gt;1,4,6,3,2,0,5
demo2：32434234，32434234，43324556，8384733，98998988=&amp;gt;0,0,1,2,3
demo3（存在需要去重的情况=&amp;gt;这种情况下是需要将重复的元素离散化为相同索引，然后起后面的索引依次往前递补）：0, 1,23424,1,0,20746768,6594,95,0,6553513=&amp;gt;1,4,1,0,6,3,2,0,5 
 数组实现 三个数组：a[maxn] b[maxn] c[maxn]，分别是原串、原串经排序之后的串、离散化之后的串
三个过程：排序、去重、索引
三个算法实现对应过程：sort排序、unique去重并获取
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 1e3+9; #include &amp;lt;algorithm&amp;gt;//int n = 7, a[maxn] = {0, 1,23424,20746768,6594,95,0,6553513}, b[maxn], c[maxn]; // 原串 a={1,23424,20746768,6594,95,0,6553513} // 中间串 b={0,1,95,6594,23424,6553513,20746768} // 离散化 c={1,4,6,3,2,0,5} int n = 9, a[maxn] = {0, 1,23424,1,0,20746768,6594,95,0,6553513}, b[maxn], c[maxn]; // 原串 a={1,23424,1,0,20746768,6594,95,0,6553513} // 中间串 b={0,1,95,6594,23424,6553513,20746768,6553513,20746768} // 离散化 c={1,4,1,0,6,3,2,0,5}  int main() { for (int i = 1; i &amp;lt;= n; ++i) b[i] = c[i] = a[i]; // 排序  sort(b+1, b+1+n); // 去重  int size = unique(b+1, b+1+n)-b-1; // 索引  for (int i = 1; i &amp;lt;= n; ++i) c[i] = lower_bound(b+1, b+1+size, a[i])-b-1; cout&amp;lt;&amp;lt;&amp;#34;原串 &amp;#34;;for (int i = 1; i &amp;lt;= n; ++i) printf(&amp;#34;%d &amp;#34;, a[i]); cout&amp;lt;&amp;lt;&amp;#34;\n中间排序串 &amp;#34;;for (int i = 1; i &amp;lt;= n; ++i) printf(&amp;#34;%d &amp;#34;, b[i]); cout&amp;lt;&amp;lt;&amp;#34;\n离散化串 &amp;#34;;for (int i = 1; i &amp;lt;= n; ++i) printf(&amp;#34;%d &amp;#34;, c[i]); return 0; } 结构体实现 数据结构：构造结构体，重载运算符（val和idx一次排序）。</description>
    </item>
    
    <item>
      <title>Algorithm23 数据结构 区间问题</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm23-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm23-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</guid>
      <description>[TOC]
数据结构 区间问题  单个区间 区间最值「典型数据结构问题」：
 固定长度区间，然后滑动询问：  单调队列 RMQ [Range maximum/minimun Query] 线段树   不固定长度，随意起点和终点：  RMQ [Range maximum/minimun Query] 线段树    区间最长递增子序列「LIS问题」：
 线性dp  区间逆序对数/区间相互交换次数：
 归并排序，记录逆序对数 树状数组  区间其他问题：
 求区间中连续抽出相同高度之后的总次数：「思维问题」同时抽取转换为一次遍历  两个区间  最长公共子序列「LCS问题」   区间最值-固定长度区间+滑动询问 https://www.luogu.com.cn/problem/P2032
https://www.luogu.com.cn/problem/P1440
https://www.luogu.com.cn/problem/P2251
https://www.luogu.com.cn/problem/P1886
 固定长度区间最大 // 固定长度区间最小 // 固定长度区间最小 // 固定长度区间最大和最小
 「单调队列思路」思路：维护一个优先队列（也就是堆结构），然后往里边push，往外拿，输出顶的
 往里边push：无脑每次往里边push 往外拿：每次先遍历，遍历到索引不在合适的区间内的，然后给pop掉【理解成从堆里把不符合的内容揪出来】 输出顶的：直接每次把堆顶拿出来  数据结构：通过pair来将值和索引进行绑定，【借助优先队列】默认对值进行排序，根据（less选取最大）（greater选取最小）对堆进行更新。
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 1e6+9; int n, k, a[maxn], ans_max[maxn], ans_min[maxn], idx; typedef pair&amp;lt;int, int&amp;gt; pr; #include &amp;lt;queue&amp;gt;priority_queue&amp;lt;pr, vector&amp;lt;pr&amp;gt;, less&amp;lt;pr&amp;gt;&amp;gt; pq_max; priority_queue&amp;lt;pr, vector&amp;lt;pr&amp;gt;, greater&amp;lt;pr&amp;gt;&amp;gt; pq_min; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;k); for (int i = 1; i &amp;lt;= n; ++i) scanf(&amp;#34;%d&amp;#34;, a+i); for (int i = 1; i &amp;lt;= n; ++i) { pq_max.</description>
    </item>
    
    <item>
      <title>Algorithm3 交叉</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm3-%E4%BA%A4%E5%8F%89/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm3-%E4%BA%A4%E5%8F%89/</guid>
      <description>[TOC]
交叉 交换纸牌：使之数量相等 题目链接：https://www.luogu.com.cn/problem/P1031
1、题目大意是允许相邻的两个牌堆交叉换牌
2、解决方案就是把交叉换成单向，然后通过单边尽头单向遍历简化问题【单边尽头单向可以的原因就是每次至少保证满足1个，然后就算是其他的中间往两边的，也最多了，每次只能满足一个，所以不如直接 单边 尽头 =&amp;gt; 方便遍历】
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 105int n, a[maxn], sum = 0, ans = 0; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]);sum += a[i];} sum /= n; for (int i = 0; i &amp;lt; n - 1; ++i) if (a[i] != sum) { a[i + 1] -= (sum - a[i]); ans++; } printf(&amp;#34;%d\n&amp;#34;, ans); return 0; } </description>
    </item>
    
    <item>
      <title>Algorithm4 十种排序</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm4-%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm4-%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/</guid>
      <description>[TOC]
排序 排序时间复杂度中的 $log_x^n$ 中以x为底n的对数通常x是取2的。 详细计算：通过k-叉树的计算次数，可以得到，最底层想覆盖n个数，那么就要$k^{depth}=n$ 然后也就得到$depth=log_k^n$ 也就是要depth次搜索，才能从最上层搜到最下层，所以log的值是和k叉树是有关系的，如果k叉越大，那么搜到最底层的速度也就越快  暴力遍历：
 冒泡排序【稳定】：$O(n^2)$ 最大的往后冒泡，保证「每次提取最大」的，然后「放到最后」 选择排序【不稳定】：$O(n^2)$ 「拿到合适的然后放置」选择出最值以及最值的索引，然后进行交换。 插入排序三种：「拿到然后找合适的地方放置一个/多个」  直接插入【稳定】：$O(n^2)$ 对每次拿到的数，从一端到另一端暴力查找，找到合适的位置插入进去 折半插入【稳定】：$O(nlog_2^n)$ 在选择合适的位置的时候，会进行二分折半查找，找到合适位置插入进去 希尔插入【不稳定】：$O(n^{1.3})\sim O(n^2)$ 更复杂的插入排序过程，三大步，首先对半分，两半一对一匹配进行插入排序；然后对半分的两类内部分别进行插入，然后对整体进行插入排序。    递归 二分与合并：$O(n*log_2^n)$
 快速排序【不稳定】：首先移动，然后「合理的分割」 归并排序【稳定】：「分割」，然后「合理的合并」  递归 桶 多分与合并：
 计数排序：n个数n个桶，然后把n个桶再合并 桶排序：n个数k个桶，k个桶各自进行排序，然后再把k个桶合并 基数排序【稳定】：n个数10个桶，10个桶为首位/尾位的是个数字对应的数。  思路一：先合并，然后再根据首位/尾位的下面一位接着入桶 思路二：对每一个桶分别根据下一位再重新进小小桶，然后对小小桶进行合并，再对大桶进行合并    其他： $$ O(n*log_n2) $$
 锦标赛排序/堆排序【不稳定】：利用类似于堆/树的log2n的结构来提取最大/最小，然后放在首/尾。  利用最小堆：递增排序   利用最大堆：递减排序   归并排序 两个易错点：
1、递归完了回来将要排序的时候，两个范围注意，左边小于等于mid，右边小于等于r，然后右边的起点也是mid+1。
2、******递归
快速排序 题目链接：https://www.luogu.com.cn/problem/P1177
1、所有排序算法的函数形式都是可以写成sort_algorithm(int[] arr, int l,int r){}</description>
    </item>
    
    <item>
      <title>Algorithm5 Advanced Sort</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm5-%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6-%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm5-%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6-%E6%AF%94%E8%BE%83/</guid>
      <description>[TOC]
排序变种   结构体排序  结构体封装题目要求的实体 结构体封装大数的类，来进行运算   排序过程：计算交换次数  交换任意一对 =&amp;gt; 一遍扫，模拟即可 仅可以交换相邻的 =&amp;gt; 树状数组 // 归并排序     用优先队列实现的顶部最大 &amp;amp; 顶部最小 最大：priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; pq;
最小：priority_queue&amp;lt;int&amp;gt; pq;
https://www.luogu.com.cn/problem/P3378
#include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;lt;queue&amp;gt;priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; pq; int m, op, t; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;m); while (m--) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;op); switch (op) { case 1: scanf(&amp;#34;%d&amp;#34;, &amp;amp;t);pq.push(t);break; case 2: printf(&amp;#34;%d\n&amp;#34;, pq.top());break; case 3: pq.</description>
    </item>
    
    <item>
      <title>Algorithm6 贪心问题</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm6-%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm6-%E8%B4%AA%E5%BF%83/</guid>
      <description>[TOC]
贪心问题  装袋问题：
结构体排序问题 // 排序贪心：
 装袋问题-每个袋子限制个数为两个 https://www.luogu.com.cn/problem/P1094
题目大意：给出若干个不同容量的东西，给出限定的最大容量的袋子，然后最少用多少个袋子装完这些不同容量东西
思路1【错误】：维护一个优先队列，每次取顶上两个，然后放一块。不行的原因，一些特殊情况，例如袋子100，物品分别为20、20、30、50、60，如果顺次加起来的话，=&amp;gt;30、40、50、60=&amp;gt;50、60、70，最后三个袋子，最少装袋是两个，20+20+60和30+50。
priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; pq; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;k, &amp;amp;n); for (int i = 0; i &amp;lt; n; ++i) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;tem); pq.push(tem); } while (true){ int tmp1 = pq.top();pq.pop(); int tmp2 = pq.top();pq.pop(); cout&amp;lt;&amp;lt;tmp1&amp;lt;&amp;lt;&amp;#34;&amp;#34;&amp;lt;&amp;lt;tmp2&amp;lt;&amp;lt;endl; if (tmp1 + tmp2 &amp;gt; k) {pq.push(tmp1);pq.push(tmp2);break;} else pq.push(tmp1+tmp2); } printf(&amp;#34;%d\n&amp;#34;, pq.size()); return 0; } 思路2【正确】：由于题目还有一个附加条件=&amp;gt;每个袋子最多两个（=&amp;gt;也在一定程度上约束了两个）用双指针，首尾各一个，分别用来指代放在袋子的两个：够了就放一个袋子里，指针都往中间移动；不够就只把大的往中间移。前提是排好序
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 30010int k, n, tem, a[maxn], ans = 0; #include &amp;lt;algorithm&amp;gt; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;k, &amp;amp;n); for (int i = 0; i &amp;lt; n; ++i) scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); sort(a, a+n); int fidx = 0, eidx = n-1; while (fidx &amp;lt;= eidx) if (a[fidx] + a[eidx] &amp;lt;= k) fidx++, eidx--, ans++; else eidx--, ans++; printf(&amp;#34;%d\n&amp;#34;, ans); return 0; } 装袋问题-无限制个数的装袋 排序贪心 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm6.1 贪心 VS 其他算法</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm6.1-%E8%B4%AA%E5%BF%83vs%E5%85%B6%E4%BB%96/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm6.1-%E8%B4%AA%E5%BF%83vs%E5%85%B6%E4%BB%96/</guid>
      <description>[TOC]
二分  一些第一眼看上去是用贪心解决，但实际上是需要用其他算法解决的问题
 https://www.luogu.com.cn/problem/P1570【看起来是贪心，实际上是找出答案的范围然后二分出结果】
题目大意：选取m个，然后问怎么选，才能保证属性a求和比上属性b求和的值最大
思路一：【贪心】按照属性a和属性b的比值进行排序，然后贪心的选取前m个。单个的VS求和的，有冲突
（反例：400 1和200 100 1 1）在选取了400 1之后，如果根据比例会优先选200 100，但是实际上在求和中要选1 1，
思路二：【二分】进行算式推导，推导成关于要求解的数的一个方程式，然后进行二分，来调整解，逼近解
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 205; int n, m, a[maxn], b[maxn]; double l, mid, r; #include &amp;lt;algorithm&amp;gt; double check(double x) { double w[maxn]; for (int i = 1; i &amp;lt;= n; ++i) w[i] = b[i]*x-a[i]; sort(w+1, w+1+n); double tmp = 0; for (int i = 1; i &amp;lt;= m; ++i) tmp += w[i]; return tmp; } int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) scanf(&amp;#34;%d&amp;#34;, a+i); for (int i = 1; i &amp;lt;= n; ++i) { scanf(&amp;#34;%d&amp;#34;, b+i); r = max(r, a[i]*1.</description>
    </item>
    
    <item>
      <title>Algorithm7 分治算法 &amp; 快速幂</title>
      <link>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm7-%E5%88%86%E6%B2%BB-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm7-%E5%88%86%E6%B2%BB-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>[TOC]
分治问题 最典型：分形 &amp;amp; 矩阵的分治  矩形分治的 统一解法 // 模版：数据结构用一个统一的数组来存储 图//矩阵 结构【init】，然后 分形//分治 递归【draw】，最后再画出来【print】（或者有的时候需要输出分治的过程）
 矩阵的分治：https://www.luogu.com.cn/problem/P5461
题目大意：正方形矩阵，分成四块，左上全赦免（为零），然后对剩下其他部分接着分成四块，一直这样下去。输出最后矩阵
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxl 1030int n, a[maxl][maxl]; #include &amp;lt;cstring&amp;gt;#define cl(a, b) memset(a, b, sizeof(a))#include &amp;lt;cmath&amp;gt; void draw(int x, int y, int h) { if (h == 2) {a[x+1][y] = a[x][y+1] = a[x+1][y+1] = 1;return;} int nowh = h&amp;gt;&amp;gt;1; draw(x+nowh, y, nowh); draw(x, y+nowh, nowh); draw(x+nowh, y+nowh, nowh); } void print() { for (int i = 1; i &amp;lt;= n; ++i) { for (int j = 1; j &amp;lt;= n; ++j) { printf(&amp;#34;%d &amp;#34;, a[i][j]); } printf(&amp;#34;\n&amp;#34;); } } int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); n = pow(2, n); cl(a, 0); // init  draw(1, 1, n); // draw  print(); // print  return 0; } 分形-谢尔宾斯基三角：https://www.</description>
    </item>
    
    <item>
      <title>Algorithm8.1 BFS</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.1-bfs/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.1-bfs/</guid>
      <description>[TOC]
bfs [模版] 最多可到达 https://www.luogu.com.cn/problem/P1683
题目大意：最多可到达的格点数
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 23int n, m, dir[4][2]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}}, ans=1, vis[maxn][maxn]; char mp[maxn][maxn]; #include &amp;lt;queue&amp;gt;struct node{ int x, y; node(int x,int y): x(x), y(y){} }; queue&amp;lt;node&amp;gt; q; void bfs(int x, int y) { q.push(node(x, y)); vis[x][y] = 1; while (!q.empty()) { node nw = q.front();q.pop(); for (int i = 0; i &amp;lt; 4; ++i) { int nx = nw.</description>
    </item>
    
    <item>
      <title>Algorithm8.2 DFS</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8-dfs/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8-dfs/</guid>
      <description>[TOC]
dfs  向深递归
 传参的确定 =&amp;gt; 可以利用好递归调用栈机制 状态的判断 =&amp;gt; 递归到每一层之后，所有参数共同组合决定出一个状态，这个状态维护是否重复   [数组一维模版 &amp;amp; 分层] 全排列 https://www.luogu.com.cn/problem/P1706
#include &amp;lt;iostream&amp;gt;using namespace std; int n, a[12], vis[12]; void dfs(int l) { if (l == n) { for (int i = 0; i &amp;lt; n; ++i) printf(&amp;#34;%5d&amp;#34;, a[i]); printf(&amp;#34;\n&amp;#34;); return; } for (int i = 1; i &amp;lt;= n; ++i) { if (!vis[i]) { a[l] = i;vis[i] = 1; dfs(l+1); vis[i] = 0; } } } int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); dfs(0); return 0; } 素数环 &amp;amp; 分层 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm8.2 DFS进阶-TLE情况的解决方案</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.2-dfs%E8%BF%9B%E9%98%B6-tle%E6%83%85%E5%86%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.2-dfs%E8%BF%9B%E9%98%B6-tle%E6%83%85%E5%86%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>[TOC]
DFS进阶-TLE情况的解决方案  解决方案
 「一」通过剪枝缩小搜索范围 「二」记忆化搜索 - 添加一个v数组 // dp数组，来记录DFS所有触及到的状态，防止再次访问 「其他」DP解决   https://www.luogu.com.cn/problem/P1077
「一」剪枝缩小搜索范围 关键是找清楚搜索维度的变量变化，找清楚哪些是递归进入的变量，哪些。该题一开始就看作的是层上dfs，然后通过l来作为依据进行搜索，l来作为return的依据，写出如下代码：
// 搜索 int cnt, ans; void dfs(int l) { if (l == n) { if (cnt == m) ans++;return;} for (int i = 0; i &amp;lt;= a[l+1]; ++i) { cnt+=i;dfs(l+1);cnt-=i; } } 可以看到其实cnt，（本来是一个全局变量）也可以写成递归的一个依据，因为进入之前与之后有相反操作，因此优化
int ans; void dfs(int l, int cnt) { if (l == n) { if (cnt == m) ans++;return; } for (int i = 0; i &amp;lt;= a[l+1]; ++i) dfs(l+1, cnt+i); } 「二」记忆化搜索 - 记录状态，防止重复访问  核心：</description>
    </item>
    
    <item>
      <title>Algorithm8.3 DFS 记忆化搜索</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.3-dfs%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.3-dfs%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</guid>
      <description>[TOC]
DFS 记忆化搜索 用于相邻依赖 =&amp;gt; 涂色：相邻的不能相同；连续递增/连续递减 搜索的形式+dp的存储思想，把dp数组融合到dfs搜索的过程中。
[模版] 记忆化搜索 - 优化重复递归调用 https://www.luogu.com.cn/problem/P1464
题目大意：纯粹的重复递归调用，极限的话20 * 20 * 20次不同的计算要被一直算，如果可以记录下来，那么这么多次运算只需要算一遍。
1、用dp来记录下来每次的递归结果，也就是return之前先给dp附上值。return dp=w();
2、注意return的时候，看看边界条件，特判条件放在前面先return；递归条件放后面return
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 25typedef long long ll; ll ta, tb, tc, dp[maxn][maxn][maxn]; ll dfs(int a, int b, int c) { if (a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return 1; if (a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) return dfs(20, 20, 20); if (dp[a][b][c]) return dp[a][b][c]; if (a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return dp[a][b][c] = dfs(a, b, c-1) + dfs(a, b-1, c-1) - dfs(a, b-1, c); else return dp[a][b][c] = dfs(a-1, b, c) + dfs(a-1, b-1, c) + dfs(a-1, b, c-1) - dfs(a-1, b-1, c-1); } int main() { while (scanf(&amp;#34;%lld%lld%lld&amp;#34;, &amp;amp;ta, &amp;amp;tb, &amp;amp;tc) &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>Algorithm8.5 搜索思维题 &amp; 数字题目类型整合</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.5-%E6%90%9C%E7%B4%A2%E6%80%9D%E7%BB%B4%E9%A2%98/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.5-%E6%90%9C%E7%B4%A2%E6%80%9D%E7%BB%B4%E9%A2%98/</guid>
      <description>[TOC]
搜索思维题  特点：可以用搜索，但是可能会T或者需要剪枝过多
 特殊地图（某方向固定长度）起点到终点 + 特殊走法：考虑按照特殊方向进行模拟 特殊走法（不允许往某个方向走）：考虑直接全盘dp   特殊地图起点到终点-特殊走法：  两行地图 特殊走法，只往一边走更优  特殊走法：  某单个方向不能走  // 搜索 int cnt, ans; void dfs(int l) { if (l == n) { if (cnt == m) ans++;return;} for (int i = 0; i &amp;lt;= a[l+1]; ++i) { cnt+=i;dfs(l+1);cnt-=i; } } 可以看到其实cnt，（本来是一个全局变量）也可以写成递归的一个依据，因为进入之前与之后有相反操作，因此优化
int ans; void dfs(int l, int cnt) { if (l == n) { if (cnt == m) ans++;return; } for (int i = 0; i &amp;lt;= a[l+1]; ++i) dfs(l+1, cnt+i); } 记忆化搜索 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm8.6 数字类型题目整合</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.6-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E6%95%B4%E5%90%88/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%90%9C%E7%B4%A2/algorithm8.6-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E6%95%B4%E5%90%88/</guid>
      <description>[TOC]
数字类型题目整合  数字题目类型整合：
 若干个数相加组合成目标数的方案总和 小于等于4个数的平方的和组合成目标数的方案总和 给定一个数，问随意将这个数进行拆解，然后拆解得到的数做乘积，求乘积最大值   dfs转计数dp 问题1:若干个数相加组合成目标数的方案总和-可用dfs+剪枝出来 https://www.luogu.com.cn/problem/P1025
1、计数问题，dfs暴力搜
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxtotal 205#define maxn 8int n, total, ans, dp[maxn][maxtotal]; void dfs(int last, int l, int val){ if (l == n) { if (val == total) ans++; return; } for (int i = last; val+i*(n-l)&amp;lt;=total; ++i) dfs(i, l+1, val+i); } int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;total, &amp;amp;n); dfs(1, 0, 0); printf(&amp;#34;%d\n&amp;#34;, ans); return 0; } 2、利用dp实现</description>
    </item>
    
    <item>
      <title>Algorithm9 数论其他汇总</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9-%E6%95%B0%E8%AE%BA%E5%85%B6%E4%BB%96%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9-%E6%95%B0%E8%AE%BA%E5%85%B6%E4%BB%96%E6%B1%87%E6%80%BB/</guid>
      <description>[TOC]
数论其他汇总 约数问题 https://www.luogu.com.cn/problem/P1403
题目大意：给定一个数n，求1～n的所有数各自的约数的数量总和。
https://www.luogu.com.cn/problem/P1372
题目大意：给定1～n，求这里边任意k个数的最大公约数是多少
思路：最基本的就是这k个数是相互之间按照ans*1， ans*2……ans*k这样得到的k个数，所以这k个数之间的最大公约数必定为ans*1。所以想要得到这个ans，就可以通过令ans*k=n =&amp;gt; ans=n/k。
#include &amp;lt;iostream&amp;gt;using namespace std; int n, k; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;k); printf(&amp;#34;%d\n&amp;#34;, n/k); return 0; } </description>
    </item>
    
    <item>
      <title>Algorithm9.1 数论 数学基础</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9.1-%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9.1-%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
      <description>[TOC]
数论 数学基础  常用：
 进制转换  数学思维：
1、找到一段序列中出现奇数次/偶数次的
2、找到一段区间中可以用平方差计算得到的个数
 进制转换 获取唯一的奇数个的不匹配的数 &amp;amp; 找未配上的对 https://www.luogu.com.cn/problem/P1469 【注意：卡内存，卡时间】
 思路一：数组存，然后排序，然后再遍历，两个两个遍历=&amp;gt; 爆内存，爆时间。 思路二：map存，找到配对的删除。一边即过。=&amp;gt; 6个点爆内存 正确思路：直接用一个变量，然后来异或^所有的数，a^a = 0，所以最后剩下的那个数就是没匹配的。  scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; ++i) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); ans ^= t;} printf(&amp;#34;%d\n&amp;#34;, ans); 获取唯一的出现偶数次数的 &amp;amp; 找配上对的 这个需要先把所有存在的数都输入进去，得到所有数的异或，然后再异或数组种的所有数，那么出现偶数次的就会显露出来了，出现单次的就会和第一次的异或掉了。
scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; ++i) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;t);ans^=t;} scanf(&amp;#34;%d&amp;#34;, &amp;amp;m); for (int i = 1; i &amp;lt;= m; ++i) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;t);ans^=t;} 区间中可以用平方差计算得到的个数 https://www.</description>
    </item>
    
    <item>
      <title>Algorithm9.2 数论入门</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9.2-%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9.2-%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/</guid>
      <description>[TOC]
数论基础 最大公约数gcd int gcd(int a,int b) { return (b&amp;gt;0)?gcd(b, a%b):a; } 利用的就是欧几里得原理
int gcd(int a, int b) { return (b&amp;lt;=0)?a:gcd(b, a%b); } 最大公约数[gcd]与最小公倍数[gld]乘积 == 这两个数的乘积 a*b = gcd(a, b)*gld()
最小公倍数[gld] 可以利用最大公约数倒推回去，也就是gld(a, b)=a*b/gcd(a, b)
质数 判断1～n中的所有质数
1、基础：O(n^2)复杂度，遍历，遍历的边界从3～sqrt(x)
bool isprime(int x){ for (int i = 3; i &amp;lt;= sqrt(x); ++i) if (x%i == 0) return false; return true; } 2、埃拉托斯特尼筛：O(nlogn)复杂度
3、线性筛：O(n)
prime是质数列表，isprime
#define maxn 10000010int vis[maxn], prime[maxn], isprime[maxn]; void Prime() { for(int i=2; i&amp;lt;=b; i++) { if(!</description>
    </item>
    
    <item>
      <title>Algorithm9.3 组合数</title>
      <link>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9.3-%E7%BB%84%E5%90%88%E6%95%B0/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E6%95%B0%E8%AE%BA/algorithm9.3-%E7%BB%84%E5%90%88%E6%95%B0/</guid>
      <description>[TOC]
组合数 基本的排列组合数 A(n, m)和C(n, m)
第二类Stirling数 数学意义：把n个数划分成k个集合
实际意义：将n个球分到k个相同的盒子
// 递归写法 ll stirling(int n, int k){ if (k==n || k==1) return 1; else if (k==2) return pow(2, (n-1)*1.0)-1; else return stirling(n-1, k-1)+k*stirling(n-1, k); } // 非递归写法  第二类Stirling数的变形 数学意义：把n个数划分成k个不同的集合
实际意义：把n个球分到k个不同的盒子里
和第二类Stirling数的区别：就是划分出来的集合再进行容器的匹配，对于不同的集合划分到不同的容器中。匹配原则：Ann
ll stirling(int n, int k){ if (k==n || k==1) return 1; else if (k==2) return pow(2, (n-1)*1.0)-1; else return stirling(n-1, k-1)+k*stirling(n-1, k); } // 排列数Ann ll factorial(ll n) { ll fc = 1; for (ll i = 1; i &amp;lt;= n; ++i) fc *= i; return fc; } https://www.</description>
    </item>
    
    <item>
      <title>kuangbin 1 简单搜索</title>
      <link>http://www.chenranfei.site/posts/acm-practice-collection/kuangbin-1-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm-practice-collection/kuangbin-1-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/</guid>
      <description>[TOC]
kuangbin 1 简单搜索 A B 「BFS」三维迷宫 题目大意：三维迷宫，注意多组数据存在的初始化的问题即可。
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 33; int n, m, k, bgn, bgm, bgk, edn, edm, edk, dir[6][3] = {{1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1}}, vis[maxn][maxn][maxn], flag; char mp[maxn][maxn][maxn]; #include &amp;lt;cstring&amp;gt;#define cl(a, b) memset(a, b, sizeof(a)) struct node { int x, y, k, step; node(int x, int y, int k, int step):x(x), y(y), k(k), step(step){} }; #include &amp;lt;queue&amp;gt;queue&amp;lt;node&amp;gt; q; void bfs() { vis[bgn][bgm][bgk] = 1; q.</description>
    </item>
    
    <item>
      <title>kuangbin 4 最短路</title>
      <link>http://www.chenranfei.site/posts/acm-practice-collection/kuangbin-4-%E6%9C%80%E7%9F%AD%E8%B7%AF/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm-practice-collection/kuangbin-4-%E6%9C%80%E7%9F%AD%E8%B7%AF/</guid>
      <description>[TOC]
kuangbin 4 最短路  https://vjudge.ppsucxtt.cn/contest/66569
 A 单源最短路 Dijkstra 链式前向星 题目大意：单起点最短路，用Dijkstra解决
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxpoint = 1e3+9; const int maxedges = 2e3+9; const int inf = (1&amp;lt;&amp;lt;31)-1; int n, m, ta, tb, tc, d[maxpoint], tem, vis[maxpoint], v; struct node { int to, nt, val; }edges[maxedges&amp;lt;&amp;lt;1];int head[maxpoint], tot; void addedge(int from, int to, int val) { edges[++tot].to = to; edges[tot].val = val; edges[tot].nt = head[from]; head[from] = tot; } void dijkstra(int bg, int ed) { for (int i = 1; i &amp;lt;= n; ++i) d[i] = inf; d[bg] = 0; for (int i = 1; i &amp;lt;= n; ++i) { tem = inf; for (int j = 1; j &amp;lt;= n; ++j) if (!</description>
    </item>
    
    <item>
      <title>Summary1.2 数据结构 STL整合</title>
      <link>http://www.chenranfei.site/posts/acm-summary/summary1.2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-stl%E6%95%B4%E5%90%88/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm-summary/summary1.2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-stl%E6%95%B4%E5%90%88/</guid>
      <description>[TOC]
数据结构 STL 用法整合 linklist #include &amp;lt;list&amp;gt; list&amp;lt;int&amp;gt; linklist; int main() { // 往链表头部插入元素  linklist.push_front(2); // 2  linklist.push_front(1); // 1 2  // 往链表尾部插入元素  linklist.push_back(3); // 1 2 3  // 链表排序  linklist.sort(); // 链表去重  linklist.unique(); // 链表长度 	int linklistlen = linklist.size(); } map // 功能描述 =&amp;gt; 查找出现单次的,并尽可能的节省空间 #include &amp;lt;map&amp;gt; map&amp;lt;int, bool&amp;gt; m; for (1~n) { cin&amp;gt;&amp;gt;t; if (m.count(t)) m.erase(t); // m.count(t) 返回0或1，数出现次数，map只允许一个key出现一次，所以只有0或1 m.erase(t)移除掉t的key所对应的那个项  else m[t] = true; } // map利用迭代器进行遍历，需要设置迭代器并且指向对应的map map&amp;lt;int, bool&amp;gt;::iterator iter = m.</description>
    </item>
    
    <item>
      <title>Other-WF 中南大学网络服务队2020招新 硬件组培训知识</title>
      <link>http://www.chenranfei.site/posts/other/o-wf-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E9%98%9F2020%E6%8B%9B%E6%96%B0-%E7%A1%AC%E4%BB%B6%E7%BB%84%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 20 Jul 2020 21:45:10 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/other/o-wf-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E9%98%9F2020%E6%8B%9B%E6%96%B0-%E7%A1%AC%E4%BB%B6%E7%BB%84%E7%9F%A5%E8%AF%86/</guid>
      <description>[TOC]
首先 Authored By Aczy156
CPU 1型号 1AMD芯片U移动端都具备核显，G为具备核显的，并且后缀无论是否有X，都可以超频，主板也都可以超，芯片组都支持CPU超频。 不同芯片组主板都支持超频，intel只有Z系列芯片组支持CPU超频 2intel有较为古老的赛扬、奔腾、至强系列、M系列(M3,M5,M7，后来M7并入i3)，低电压，用于超级本、轻薄本等；以及现在主流的有i系列（i3,i5,i7,i9）
2架构 Intel 一代Nehalem、二代SandyBridge、三代IvyBridge、四代Haswell、五代Broadwell、六代Skylake、七代Kabylake，八代Coffee lake，第九代Coffee Lake-Refresh ，第十代Ice Lake
AMD AMD的架构有诸如推土机（bulldozer 中文译名推土机）、打桩机(piledriver 中文译名打桩机)、压路机(streamroller 中文译名压路机)、以及最新的Ryzen系列采用的Zen架构等等。 zen架构有1系zen，2系zen+，3系zen2（移动端从2系开始，2系zen，3系zen+，4系zen2）
3制程/工艺 intel 六代-九代 14nm 十代 10nm/14nm共存
Amd amd1、2代12nm 三代7nm
4核心core(C)/线程Thread(T) 超线程技术：超线程技术是一个很好的提升核心利用率的东西，将闲置处理资源充分调动起来，增强核心并行运算性能，在操作系统中一颗物理CPU能同时执行两个线程。 核心不一定越多越好，要看实际应用场景。
5主频、超频 外频*倍频 外频：总线速度，倍频：频率倍数， 主频并不是衡量性能的唯一标准，但也是非常重要的参数，在其他参数相同的情况下，主频越高性能越好。 intel处理器采用睿频加速技术（Turbo Boost技术），来提高运行主频，达到提高性能 amdTurbo Core技术是多核产品上的一种智能调频技术，增强多核平台在运行不支持多核处理的程序时提高系统性能。 两个技术都可以实现自动超频。 AMD多核占优的原因：工艺散热限制核心组排布、由于多方面因素和挤牙膏的因素和物理架构的原因，导致intel在多核心上表现不优
6缓存(一级缓存/二级缓存/三级缓存) 一二 一般对应核心，其中一级缓存成本很高，直接处理要求速度特别高，一般只有几十k，三级缓存共享缓存，直接和内存做通信。
7TDP功耗 主要与CPU架构、制程的更新有关 CPU架构越先进,工艺越小，功耗越低。 同系列产品，CPU功耗还是和性能基本成正比的，性能越高，需要的功耗也就越高。
8核显 核心显卡是封装在CPU里的，一般平时承担一些负载较轻的图形运算，使用内存共享作为显存。 其中AMD和Intel两家CPU制造厂商都有带有核心显卡的CPU。其中AMD最新的Vega架构实力强劲。
9cpu封装 LGA：Intel CPU采用的封装方式 LGA封装是最常见的，LGA全称“land grid array”，或者叫“平面网格阵列封装”，我们平时常见的Intel CPU基本都采用了这样的封装方式。
PGA：主流的AMD CPU采用的封装方式 PGA的全称叫做“pin grid array”，或者叫“插针网格阵列封装”，主流的AMD CPU，以及早期的酷睿移动MQ系列基本都采用了PGA封装方式
BGA：intel所有低压CPU采用的封装方式 BGA的全称叫做“ball grid array”，或者叫“球柵网格阵列封装”。目前，绝大部分的intel移动CPU都使用了这种封装方式，例如intel所有以H、HQ、U、Y等结尾（包括但不限低压）的处理器。</description>
    </item>
    
    <item>
      <title>Python-编译原理算法</title>
      <link>http://www.chenranfei.site/posts/project/python4-compiling_principle_master/</link>
      <pubDate>Sun, 07 Jun 2020 19:28:52 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/project/python4-compiling_principle_master/</guid>
      <description>[TOC]
编译原理课程作业  词法分析器 LL1分析(消去左递归、构造FIRST\FOLLOW集合、模拟) 递归下降分析 算法优先分析  项目地址源代码 https://github.com/Aczy156/Compiling-Principle-Work 项目结构 data  Grammer_for_ll1_and_RD.txt，是存放用于实验二预测分析法和实验三递归下降分析文法的测试文法 Grammer_for_OF.txt，是存放用于实验四算符优先文法的测试文法。  MultiAnalysis  LL1_analysis.py是LL1分析法的整体过程。 RecursiveDescent_analysis.py是递归下降分析的整体过程。 OperatorFirst_analysis.py是算符优先文法的整体分析过程。  tools [在MultiAnalysis中的各种文法中多次使用，所以提取出来子模块，放进工具中来模块化管理]
 Draw_Grammer.py，利用python中prettytable来专门做文法的可视化。 Eliminate_Left_Recursion.py，利用消除左递归算法来专门处理对于自上而下的文法(例如实验二中的预测分析文法和实验三的递归下降文法)的左递归的问题。 Extract_Common_Factors.py，利用LCP(最长公共前缀)来提取公因子并消除。  数据结构 (命名基本保持一致，除了在一些情境中要利用python deepcopy深备份一份或者要进行更改会命名为new_grammer/new_vn等等)：
 文法grammer：文法在通过预处理过后，通过python中的数据结构dictionary(dict、字典)来映射，例如{&amp;lsquo;E&amp;rsquo;: [&amp;lsquo;E+T&amp;rsquo;, &amp;lsquo;T&amp;rsquo;], &amp;lsquo;T&amp;rsquo;: [&amp;lsquo;T*F&amp;rsquo;, &amp;lsquo;F&amp;rsquo;], &amp;lsquo;F&amp;rsquo;: [&#39;(E)&#39;, &amp;lsquo;i&amp;rsquo;]}，用来表示通过数据预处理之后的最基本的算术表达式文法。 非终结符vn：非终结符通过list来盛放。例如[&amp;lsquo;E&amp;rsquo;, &amp;lsquo;T&amp;rsquo;, &amp;lsquo;F&amp;rsquo;]，用来表示通过数据预处理之后的最基本的算术表达式文法的非终结符。 终结符vt：终结符通过list来盛放。例如 [&#39;(&#39;, &amp;lsquo;)&#39;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;+&amp;rsquo;, &amp;lsquo;*&#39;, &amp;lsquo;#&#39;]，用来表示通过数据预处理之后的最基本的算术表达式文法的非终结符。  </description>
    </item>
    
    <item>
      <title>阿里云CentOS7部署JavaWeb_jar_war_nginx</title>
      <link>http://www.chenranfei.site/posts/project/o-%E9%98%BF%E9%87%8C%E4%BA%91centos7%E9%83%A8%E7%BD%B2javaweb_jar_war_nginx/</link>
      <pubDate>Sun, 07 Jun 2020 19:03:25 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/project/o-%E9%98%BF%E9%87%8C%E4%BA%91centos7%E9%83%A8%E7%BD%B2javaweb_jar_war_nginx/</guid>
      <description>[TOC]
(一)第一部分：最基本的jar包运行(无需配置tomcat) [http://60.205.183.114:8081/]
 1、配置阿里云(Esc学生服务器、镜像Centos7.7)，并远程连接进入终端。 2、安装并配置JDK(参考https://www.jianshu.com/p/093413f2a04f) a)安装jdk。 b)寻找jdk路径配置环境变量。 c)简单的Java hello world测试确保安装成功。 3、安装并配置mysql(mariadb)(参考https://blog.csdn.net/DaSo_CSDN/article/details/54754936) a)安装mysql、mariadb server。 b)systemctl 开启服务。 c) 打开端口。(阿里云要在控制台打开，参考https://yq.aliyun.com/articles/701181) d) 更改mysql 的root密码，对应于项目配置文件中的密码。 4、利用scp进行文件传输(参考https://www.cnblogs.com/tugenhua0707/p/8278772.html) a)传输spring maven 的快照版本用于测试。 b)传输数据库sql文件。 5、导入数据库 a)创建sql文件对应的数据库。 b)利用文件重定向运行sql文件。 c)检查数据库是否导入成功 6、运行jar文件，控制台获取公网IP，本机输入IP:8081测试。 7、设置后台运行(已设置：http://60.205.183.114:8081/) a)contrl+c中止。 b)然后通过nohup 和 &amp;amp; 来后台运行。 c)ps通过pid来停止后台运行进程。  运行结果 整体过程:
[root@iZ2ze4r3b4xcztbcsey08cZ ~]# history 1 MAKRER=SHOW_LOCALE;printf $MAKRER&amp;#34;&amp;#34;; locale; MAKRER=SHOW_LOCALE;printf $MAKRER&amp;#34;&amp;#34;; 2 yum install -y mysql 3 yum install -y mariadb-server mariadb 4 systemctl start mariadb 5 systemctl enable mariadb 6 yum install -y mysql-devel 7 firewall-cmd --zone=public --add-port=3306/tcp --permanent 8 CHECK_TYPE=SHELL; echo &amp;#34;INFO=${CHECK_TYPE}PID=$$PPID=$PPIDTTY=$(tty)SHELL=$0HOME=$HOMEPWD=$PWD| CHECK_SHELL_END&amp;#34; 9 ls 10 ifconfig 11 ls 12 yum list 13 java -version 14 ls 15 yum search java-1.</description>
    </item>
    
    <item>
      <title>C Compiler</title>
      <link>http://www.chenranfei.site/posts/project/c-compilerclangmingwgcc/</link>
      <pubDate>Wed, 08 Apr 2020 20:42:26 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/project/c-compilerclangmingwgcc/</guid>
      <description>[TOC]
C Compiler Clang MinGW GCC FSort中的线程问题 在Clang和MinGW编译器中都可以正常编译，但是经过Clang编译之后，可以正常运行；而</description>
    </item>
    
    <item>
      <title>Contest PAT-PTA刷题系统</title>
      <link>http://www.chenranfei.site/posts/contest/contest-pta-practice/</link>
      <pubDate>Wed, 08 Apr 2020 20:42:26 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/contest/contest-pta-practice/</guid>
      <description>[TOC]
PTA1001-1099 PTA 1001  题目大意：求a+b
  【易错】输出格式的标准化：每3位来一个逗号（利用循环+取余进行输出）  #include &amp;lt;iostream&amp;gt;using namespace std; int a, b, c, d, i; string s = &amp;#34;&amp;#34;; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b); c = a+b; if (c &amp;lt; 0) d = 1, c = -c; if (c == 0) {printf(&amp;#34;0&amp;#34;);return 0;} while (c) { s += &amp;#39;0&amp;#39;+c%10; c /= 10; if (!(++i%3) &amp;amp;&amp;amp; c) i=0, s += &amp;#39;,&amp;#39;; } if (d) cout&amp;lt;&amp;lt;&amp;#34;-&amp;#34;; for (int j = s.</description>
    </item>
    
    <item>
      <title>Java Web Spring</title>
      <link>http://www.chenranfei.site/posts/project/java-spring/</link>
      <pubDate>Wed, 08 Apr 2020 20:42:26 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/project/java-spring/</guid>
      <description>[TOC]
Java Web Spring IOC [依赖注入/控制反转] 1、例子：class A中引入class B，两种方法：
 传统方法：在A中new一个class B的类。这样是A控制着B。 IOC：在A的构造函数中注入一个已经提前new好的class B的类。这样B还是B，不受A的控制。  2、在Spring中的使用：消除所有依赖关系 and 工厂模式
a）消除所有依赖关系：通过控制反转提前new出需要new的类。
b）工厂模式：用一个工厂来提前把所有需要new的类给new出来。供所有需要注入的类去注入。其中有两种工厂模式来进行对象的映射
 简单工厂：静态，单个唯一的工厂 工厂方法：动态，一个抽象的、产生工厂的唯一工厂+有多少个产品就有多少个具体工厂的具体工厂（这些工厂是有抽象工厂挨个产生的）。  AOP [面向切面编程] 最简单的理解：为目标对象创建一个代理对象，通过代理对象调用目标对象，并且可以在目标对象前后进行切面编程
单例模式 Spring依赖注入的Bean实例是单例的。
每一个类都仅有一个实例，并且提供了一个全局访问点，也就是BeanFactory，只能通过这个访问点来获取实例。（创建则是在每次初始化运行的时候创建的）
Spring MVC [Spring 的 Handler接口] 利用适配器模式，每每需要新增/扩展一个Controller来处理请求，就直接实现接口，implement Controller，然后直接实现返回值为ModelAndView的handleRequest方法即可。
配置文件   Maven：只要用maven进行包管理，那么必定有pom.xml，里边写了各种需要的依赖
  Spring MVC：
 整个项目，命名空间、schema设置-&amp;gt;applicationContext.xml； servlet之间映射关系，URL与Controller，请求与处理请求-&amp;gt;dispatcher-servlet.xml； 其他URL的映射关系-&amp;gt;web.xml    Spring Boot：唯一的application.properties配置文件。（配置包括JDBC、Mybatis、logging等等各种都可以在这唯一的配置文件中配置）
  运行项目 myPetStore - 利用Spring boot的jpetsotre 项目地址：https://github.com/Aczy156/myPetStore
 clone之后，运行的时候需要注意：resource目录的目录类型没有同步为resource root，导致运行项目的时候spring容器无法识别，导致application.properties中的很多属性无法被正常提取，所以无法运行。参考博客  运行项目 NewPetStore - 前后端分离 Nuxt.</description>
    </item>
    
    <item>
      <title>Java Web 项目</title>
      <link>http://www.chenranfei.site/posts/project/java-web/</link>
      <pubDate>Wed, 08 Apr 2020 20:42:26 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/project/java-web/</guid>
      <description>[TOC]
Java Web 最基础JavaWeb：Web-INF工程 过程：
 直接创建基础Java项目 利用创建出来的空Java项目，添加「框架支持」“Add Frameworks Support” 利用Java EE中的Web Application 即可构建最最最基本的Java web框架  易错点：
 空工程，没有依赖/或者类似maven的包管理工具，所以依赖需要手动倒入，各种jar包。 两种配置servlet的写法中：  利用.xml配置文件的写法，容易忘记写servlet-class标签，这样就无法响应servlet 利用标签的写法，会利用name属性去找对应的类，找不到对应的类就会出问题，直接在tomcat容器里跑不起来。   tomcat配置内容，artifact配置注意会默认有war_exploded这个出现在链接里，也即是最后打包之后放在tomcat里边的内容，链接里要加入的。如果想删除，不仅要在server里边删除，也要在「deployment」部署里边删除  </description>
    </item>
    
    <item>
      <title>Python 3 Pycharm Basic Configuration</title>
      <link>http://www.chenranfei.site/posts/python/python3-pycharm-basic-configuration/</link>
      <pubDate>Wed, 08 Apr 2020 20:42:26 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/python/python3-pycharm-basic-configuration/</guid>
      <description>[TOC]
Python 深度学习项目 python-interpreter 设置 - virtualenv的设置  「一」每个项目创立的时候可以跟着设置一个venv，可以从本来已有python目录直接调用 「二」自己创建一个venv，然后在命令行中一步一步安装所有需要的依赖（或者直接通过requirements.txt一步到位，安装好所有的依赖） 「三」pycharm-&amp;gt;preference-&amp;gt;interpreter中可以看到所有扫描到的virtualenv，然后每一个virtualenv都是可以作为运行环境。  可以选择原来已经设置好的venv 可以选择刚才自己创建的venv（也就是）    python-conda的使用 conda 创建venv
# 查看conda已有的env conda env list # conda创建新的env，在创建的时候可以选择python版本和虚拟环境的名字 conda create --name myenv python==3.6 python-requireme.txt 设置 - 快速安装依赖  无需install，可以直接使用（内置在pip依赖中，直接使用即可） 将当前的项目的依赖导出成requirements.txt，用来作为标记，利用freeze语法。pip freeze &amp;gt; requirements.txt 给当前的项目依赖已有的requiremes.txt快速安装全部所需依赖。pip install -r requirements.txt  目录结构  config：存放全局变量（超参数） data-preparation：做数据预处理 models：存放所有的模型，用来进行调用 train：模型训练的整个过程  分开目录结构之后文件之间相互引用 无法相互引用的两大原因：
 整体项目文件类型：该项目所对应的文件类型要修改 =&amp;gt; 右键选中当前project--&amp;gt;Mark Directory as --&amp;gt; Sources Root. （修改了之后的该项目所对应的文件性质应该呈现蓝色） 相互引用的文件命名：所有的命名中都不可以出现- (间隔符)，但是可以_ (下划线)  GitHub接管项目的版本控制 在利用VCS进行控制之后，更该项目名称，无法正常继续进行GitHub操作</description>
    </item>
    
    <item>
      <title>Python PyTorch RNN TextCNN</title>
      <link>http://www.chenranfei.site/posts/project/pytorch-rnn-textcnn/</link>
      <pubDate>Wed, 08 Apr 2020 20:42:26 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/project/pytorch-rnn-textcnn/</guid>
      <description>[TOC]
PyTorch RNN TextCNN PyTorch RNN  数据预处理：通过numpy模拟产生数据，然后利用matplotlib来渲染数据   目录结构  config：存放全局变量（超参数） data-preparation：做数据预处理 models：存放所有的模型，用来进行调用 train：模型训练的整个过程  分开目录结构之后文件之间相互引用 无法相互引用的两大原因：
 整体项目文件类型：该项目所对应的文件类型要修改 =&amp;gt; 右键选中当前project--&amp;gt;Mark Directory as --&amp;gt; Sources Root. （修改了之后的该项目所对应的文件性质应该呈现蓝色） 相互引用的文件命名：所有的命名中都不可以出现- (间隔符)，但是可以_ (下划线)  </description>
    </item>
    
    <item>
      <title>Tool-Git语法</title>
      <link>http://www.chenranfei.site/posts/tool/tool-git%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Wed, 08 Apr 2020 20:42:26 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/tool/tool-git%E8%AF%AD%E6%B3%95/</guid>
      <description>[TOC]
Git 基础定义 定义：版本控制管理工具
几个位置：
 工作区  版本库   暂存区 仓库  本地仓库 远端仓库    基础语法 git init 【修改】初始化当前目录变成可以用git进行接管的文件目录。在整个工作区中会产生一个.git文件，存放版本库。
git add . git add README.md 【移动】将该目录的所有文件/README.md文件添加到缓存区
（注意，虽然移动到了暂缓区，但是还没有被提交到本地仓库，因此在add之后，查看log，还是没有记录这个版本的「此时的status显示红色」，包括查看reflog，也是没有这个版本的）然后将文件加入工作区之后「此时status显示绿色」
git commit -m &amp;#34;xxx 提交到本地仓库&amp;#34; 【移动】将缓存区的文件提交到本地仓库
git status 【查看】
 文件：看缓存区是否还有尚未提交到本地仓库的文件 文件：看缓存区文件里的内容和本地仓库文件里的内容是否有不一致的 分支：当前处于哪个分支  git diff README.md 【查看】看某个文件不一致在哪里，回来类似于cat语句将不一样的地方输出出来
git log git log --pretty=oneline 【查看】看所有的缓存区提交到本地仓库的记录（通过添加参数保证所有的内容都在一行内显示）
git reset HEAD * 【操作】清空缓存区：移除暂存区的内容，然后利用.gitignore忽略掉不想commit的文件，然后再将对应文件添加进入缓存区
git reflog 【查看】看到所有本地仓库的历史记录的版本号，可以利用获取到的版本好来随意移动到本地仓库的对应版本
git reset --hard HEAD^ git reset --hard HEAD^^ git reset --hard HEAD~100 git reset --hard 6fcfc89 【前后移动+修改】</description>
    </item>
    
    <item>
      <title>Tool-LaTex语法</title>
      <link>http://www.chenranfei.site/posts/tool/tool-latex%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 05 Apr 2020 17:16:12 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/tool/tool-latex%E8%AF%AD%E6%B3%95/</guid>
      <description>[TOC]
LaTex语法 插入方式  inline math 行内公式 block math 块内公式  inline math $test_{latex}$
$test_{latex}$ block math $$ test_{latex} $$
$$ test_{latex} $$ 基本字符 下面基本常用字符都是inline math 写的
   字母 实现 字母 实现     $\alpha$​ \alpha $\Alpha$ \Alpha   $\beta$ \beta $\Beta$ \Beta   $\gamma$ \gamma $\Gamma$ \Gamma   $\delta$ \delta $\Delta$ \Delta   $\epsilon$ \epsilon $\Epsilon$ \Epsilon   $\varepsilon$ \varepsilon     $\zeta$ \zeta $\Zeta$ \Zeta   $\eta$ \eta $\Eta$ \Eta   $\theta$ \theta $\Theta$ \Theta   $\vartheta$ \vartheta     $\iota$ \iota $\Iota$ \Iota   $\kappa$ \kappa $\Kappa$ \Kappa   $\lambda$ \lambda $\Lambda$ \Lambda   $\mu$ \mu $\Mu$ \Mu   $\nu$ \nu $\Nu$ \Nu   $\xi$ \xi $\Xi$ \Xi   $\omicron$ \omicron $\Omicron$ \Omicron   $\pi$ \pi $\Pi$ \Pi   $\varpi$ \varpi     $\rho$ \rho $\Rho$ \Rho   $\varrho$ \varrho     $\sigma$ \sigma $\Sigma$ \Sigma   $\varsigma$ \varsigma     $\tau$ \tau $\Tau$ \Tau   $\upsilon$ \upsilon $\Upsilon$ \Upsilon   $\phi$ \phi $\Phi$ \Phi   $\varphi$ \varphi     $\chi$ \chi $\Chi$ \Chi   $\psi$ \psi $\Psi$ \Psi   $\omega$ \omega $\Omega$ \Omega    运算符号 普通运算符号    符号 实现 名称     $\pm$ \pm 加减   $\mp$ \mp 减加   $\times$ \times 乘   $\div$ \div 除   $\cdot$ \cdot 点   $\ast$ \ast 星号   $\star$ \star 五角星   $\dagger$ \dagger 剑号   $\ddagger$ \ddagger 双剑号   $\amalg$ \amalg amalg   $\cap$ \cap 圆帽   $\cup$ \cup 圆杯   $\uplus$ \uplus 圆杯加号   $\sqcap$ \sqcap 方帽   $\sqcup$ \sqcup 方杯   $\vee$ \vee 正V   $\wedge$ \wedge 倒V   $\setminus$ \setminus 集差   $\wr$ \wr 环积   $\circ$ \circ 圆圈   $\bullet$ \bullet 实心圆   $\oslash$ \oslash 圆圈斜线   $\odot$ \odot 圆圈点   $\bigcirc$ \bigcirc 大圆圈   $\bigtriangleup$ \bigtriangleup 大正三角形   $\bigtriangledown$ \bigtriangledown 大倒三角形   $\triangleleft$ \triangleleft 左三角形   $\triangleright$ \triangleright 右三角形   $\oplus$ \oplus 圆圈加号   $\ominus$ \ominus 圆圈减号   $\otimes$ \otimes 圆圈乘号   $\bot$ \bot 倒T   $\top$ \top 正T   $\sum$ \sum 求和   $\prod$ \prod 乘积   $\int$ \int 积分   $\oint$ \oint 围道积分   $\biguplus$ \biguplus 大圆杯加号   $\bigoplus$ \bigoplus 大圆圈加号   $\bigvee$ \bigvee 大V   $\bigcap$ \bigcap 大圆帽   $\bigotimes$ \bigotimes 大圆圈乘号   $\bigwedge$ \bigwedge 大倒V   $\bigcup$ \bigcup 大圆杯   $\bigodot$ \bigodot 大圆圈点   $\bigsqcup$ \bigsqcup 大方杯    分数：\frac{} 正常大小的：$P(B_j|A)=\frac{P(B_jA)}{P(A)}$​​​</description>
    </item>
    
    <item>
      <title>Tool-Linux-常用配置</title>
      <link>http://www.chenranfei.site/posts/tool/tool-linux-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 05 Apr 2020 17:16:12 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/tool/tool-linux-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>[TOC]
Linux常见配置 查看配置 - neofetch  mac: brew install neofetch centos: sudo dnf install neofetch  terminal 水平分割 - tmux 切换文件权限 - chown 切换单个文件权限：chown 用户:群组 path_of_file
eg: chown aczy156:staff orange
递归切换这个file和里边递归的所有file
eg:</description>
    </item>
    
    <item>
      <title>Tool-Linux-指令整理</title>
      <link>http://www.chenranfei.site/posts/tool/tool-linux-%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 05 Apr 2020 17:16:12 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/tool/tool-linux-%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/</guid>
      <description>[TOC]
 综合了https://blog.csdn.net/wojiaopanpan/article/details/7286430 博客的一些指令以及一些过去的一些积累。
 基本指令 mv cp ls (ls -l 查看该目录下面文件的具体信息，包括权限归属) chown 切换权限归属 chown -R aczy156 file-name （-R为当前目录以及这个目录下边的所有文件） chroot chroot /mnt，在配置arch并利用arch安装驱动系统安装好后，把root权交给新安装的那个系统的一个操作 chmod +x 目录 给目录 cd cd 空，默认进入root文件，也就是相当于cd ～ cd .. 两个点为进入上一级目录 pwd 当前目录的path open 打开某个文件夹（open . 打开当前的目录的文件夹） mkdir vim fdisk cfdisk df -hl 看所有的存储空间使用情况 mount mkfs :q（退出模式） :wq move rm []删除 rm -rf xx [删除目录的,也就是文件夹]删除某个文件 cd rm rf .删除所有文件 xrandr 不加参数：查看分辨率 cvt 1024 768 参数为分辨率的x和y
 日常使用 os config file 系统文件 config.</description>
    </item>
    
    <item>
      <title>Tool-Office-插件使用</title>
      <link>http://www.chenranfei.site/posts/tool/tool-office-%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 05 Apr 2020 17:16:12 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/tool/tool-office-%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC]
Office 插件工具使用 文献管理工具 - Zotero 安装 直接在Zotero中配置选项，然后会自动下载插件，与Chrome或Office建立连接。
 文献管理（manage）「Zotero connect with Chrome」 文献引用（citation）「Zotero connect with Office」  使用 文献引用，设置引用风格：有China National Standard GB/T 7714-2015(numeric, 中文)，依据其他论文种类还有其他的风格。
新的文档使用：
 首先增添第一个Citation（引用），然后会按照格式出现[1]或者1。 然后在参考文献对应list的地方增添bibliography（参考书目），然后就会在参考文献下边出现这个文献引用对应的参考书目。  </description>
    </item>
    
    <item>
      <title>Python 4 virtualenv</title>
      <link>http://www.chenranfei.site/posts/python/python4-virtualenv/</link>
      <pubDate>Sun, 05 Apr 2020 17:13:50 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/python/python4-virtualenv/</guid>
      <description>[TOC]
 Virtualenv用于为某个项目新配置一个独立的python环境而产生 环境为macOS pip安装virtualvenvsudo pip install virtualenv
 mac如果有安装Xcode，则在/usr/bin中自带有python2.7，可用于配置python2.7的相关环境 而自己装配的python3则在/usr/local/bin中，可用于python3的相关环境
第一种方法：
 通过在创建项目之前，先开好一个venv mkdir newproject cd newproject 指定python版本(以自带的python2.7为例) virtualenv -p /usr/bin venv2.7 激活当前的虚拟环境 source venv/bin/activate [然后可以通过pip list 查看当前的这个虚拟环境中都有什么以来,此时因为已经成为虚拟环境，在指令前面会变成(venv)localhost:newproject aczy156$:，会多出一个(venv),会显示出此时的python版本、已经安装的各种库函数(博主手动安装的numpy pyzmq，剩下的自带的)]  在pycharm中选择virtualenv作为环境，然后选择对应的版本的interpreter(博主在这一步的时候打开之后pycharm直接识别到了创建好的venv，都是默认选好的了)  在新的空目录下选择virtualenv，然后location是这个目录下存放库的文件，可以起名为venv，interpreter为python版本。 此时就配置好虚拟环境了。
 terminal 通过 deactivate可以退出source环境下的编辑。  </description>
    </item>
    
    <item>
      <title>Other-Mysql安装、配置、连接navicat过程</title>
      <link>http://www.chenranfei.site/posts/other/o-mysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5navicat%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 17 Mar 2020 21:54:42 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/other/o-mysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5navicat%E8%BF%87%E7%A8%8B/</guid>
      <description>[TOC]
Windows环境下配置mysql环境 安装包下载 清华源可以直接下载.msi 安装引导。 https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/
配置环境变量 按win键，输入“查看高级系统设置”-&amp;gt;编辑系统变量中的PATH-&amp;gt;添加下载的mysql的bin目录。 eg：C:\Program Files\MySQL\MySQL Server 8.0\bin 按win键，输入cmd，右击通过管理员权限打开
 进入mysql文件下的bin目录cd &amp;quot;C:\Program Files\MySQL\MySQL Server 8.0\bin&amp;quot;(目录不同电脑不同，通过tab自动弹出的是最准的) mysqld --initialize --console记录下来初始化的密码  mysqld install mysqld --console 可以测试一下当前的数据库是否安装好：  登陆mysql -u root -p,密码是上面初始化的那个。 执行show databases;如果报错，可以通过修改密码解决。alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;youpassword&#39;    设置密码加密方式 此步可以解决navicat可视化管理本地mysql或者其他IP的MySQL的连接失败的情况
 首先登陆mysql -u root -p,如果改了密码了就是自己改的，如果没有改过密码就是原来初始话的那个密码 然后更改加密方式： alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;youpassword&#39;  最后navicat可以连接成功 </description>
    </item>
    
    <item>
      <title>Other-区块链 RAFT协议详解</title>
      <link>http://www.chenranfei.site/posts/other/o-%E5%8C%BA%E5%9D%97%E9%93%BE-raft%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 17 Mar 2020 21:52:58 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/other/o-%E5%8C%BA%E5%9D%97%E9%93%BE-raft%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>[TOC]
基于RAFT共同机制的用于维护分布式系统中解决分布式储存和共识机制的协议算法。 RAFT包括三种节点：leader、follower、candidate RAFT协议算法中包括三个基本组件动作，   Leader Election，用来模拟在每次联盟链上选出当前的Leader的操作，即向其他的follower发布并传递请求：在图中的表示形式是每个节点处于follower状态，并自动转化为candidate，然后对自己投票，并发起RequestVoteRPC，随后等待联盟链上的其他节点的回应：  当前节点获得超过半数节点的投票，赢得选举成为Leader，此时该节点所代表的联盟链上的成员可以对其他follower进行指示，可以进行相应的操作。 如果参加选举的节点有多个，也即在有多个成员申请修改链上内容的权限：如果其他节点赢得选举，该节点成为Leader，当前节点接收到对方心跳 ，当前节点变为follower。 选举超时，没有节点赢得选举，当前节点自增任期，重新发起选举：所有申请修改的成员都没有得到响应成功，要重新申请，只到结果呈现为情况1、情况2.    Normal Operation(basic log replication)，用来每次client给每个节点发送请求的过程，每次请求就是一个指令，用来模拟在联盟链中每一个节点需要做的操作。  leader接受请求后，把指令（Entry）追加到leader的操作日志中，然后对follower发起AppendEntries操作，尝试让操作指令(Entry)追加到Followers的操作日志中。如果有Follower不可用，则一直尝试 一旦Leader接受到多数（Quorums）Follower的回应，Leader就会进行commit操作，每一台节点服务器会把操作指令交给状态机处理。这样就保证了各节点的状态的一致性 各服务器状态机处理完成之后，Leader将结果返回给Client。     在这里插入图片描述
 对于Normal Operation中的特殊情况例如发生了网络分区，RAFT同样可以以较高的容错性解决该情况，由于部分节点的心跳跳动周期之后没有leader的响应，节点认定为 leader down ，然后重新选举，这是产生双网络之后，有两个client分别为两个leader传达命令，在此情况下两个网络中的节点会有两种不同的指令，但是当修复网络分区之后，两个leader会通过查看期限，最终会统一为一个leader，使整个网络还是保持一致性。     Safety
 Election safety: 在一个term下，最多只有一个Leader：也即在联盟链中，在没有网络分区的情况下，最多只有一个leader；如果出现了网络分区的情况，则会执行Normal Operation中的特殊情况的执行方法。 Leader Append-Only: 一个Leader只能追加新的entries，不能重写和删除entries Log Matching: 集群中各个节点的log都是相同一致的 Leader Completeness:如果一个log entry被committed了，则这个entry一定会出现在Leader的log里，即leader会一致同步所有follower的信息。 State Machine Safety: 如果一个节点服务器的state machine执行了一个某个log entry命令，则其他节点服务器，也会执行这个log entry命令，不会再执行其他命令。     Excerpt from http://thesecretlivesofdata.com/raft Experpt from In Search of an Understandable Consensus Algorithm</description>
    </item>
    
    <item>
      <title>Other-利用sshKey实现单台机器管理多个GitHub账户</title>
      <link>http://www.chenranfei.site/posts/other/o-%E5%88%A9%E7%94%A8sshkey%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E6%88%B7/</link>
      <pubDate>Thu, 20 Feb 2020 18:01:06 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/other/o-%E5%88%A9%E7%94%A8sshkey%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E6%88%B7/</guid>
      <description>[TOC]
踩过的坑 用户在搭建第二个博客的时候[有特殊需求的情况下]，经过搜索发现一个GitHub账户只能有一个GitHub page，然而当我在利用第二个账户push的时候，总显示 Git push ERROR: Repository not found fatal:这种无法正常连接的报错，
 一开始以为分枝问题，各种git remote -v的调试，各种重置，添加的，然后还是不行 后来经过Google 发现一个email只能绑定一个sshkey，然后传输利用ssh进行匹配 然后在利用ssh-add进行添加的时候配置添加好第二个key(记得不可以名字重复，不然会覆盖)之后在配置config的时候要注意不能改host。(在下边详细说) 在最后pushd时候在原来随便的一个测试项目中发生了一件尴尬的画面，测试的时候两个账号push的时候串了，后来发现在两个push的时候发布者不是取决于项目的clone的那个账号，而是当时git config中设置的email对应的账号。 然后在选取好账号后就可以进行push了。  配置两个ssh key详解： 先列一下其他的人写的，真的很详细了已经https://gist.github.com/jexchan/2351996 主要是在最后的配置config的时候， 我改了这些地方，最后两个email都可以顺利通过ssh进行连接，(感觉第一行和中间那个像注释的东西貌似不用改，，，但也没试过，，，)，产生了两个ssh key之后把内容拷贝到GitHub就不说了，教程很多也没什么坑。</description>
    </item>
    
    <item>
      <title>Other-Vue_router路由跳转</title>
      <link>http://www.chenranfei.site/posts/other/o-vue_router%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/</link>
      <pubDate>Sun, 16 Feb 2020 12:19:14 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/other/o-vue_router%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC/</guid>
      <description>[TOC]
整体框架结构 Vue router 实现界面导航切换。.。
  由router/index.js 中的vue-router来指引不同的要跳转的界面
  在main.js中添加路由跳转的函数，
  在app.vue中利用router-view来规范router切换的范围
  在需要跳转的位置利用main.js中的路由跳转函数来进行跳转
  核心代码 router/index.js
import Vue from &amp;#39;vue&amp;#39; import VueRouter from &amp;#39;vue-router&amp;#39; Vue.use(VueRouter) export default new VueRouter({ routes: [ { path: &amp;#39;/&amp;#39;, redirect: { name: &amp;#39;home&amp;#39; } }, { path: &amp;#39;/home&amp;#39;, name: &amp;#39;home&amp;#39;, component: require(&amp;#39;../components/AddPicture.vue&amp;#39;).default }, { path: &amp;#39;/page01&amp;#39;, name: &amp;#39;page01&amp;#39;, component: require(&amp;#39;../components/Mainpage.vue&amp;#39;).default } ] }) main.js
import Vue from &amp;#39;vue&amp;#39; import App from &amp;#39;.</description>
    </item>
    
    <item>
      <title>Contest CSP-2019.12-1.2.3题总结</title>
      <link>http://www.chenranfei.site/posts/contest/contest-csp-2019.12-q123%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 09 Feb 2020 21:54:27 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/contest/contest-csp-2019.12-q123%E6%80%BB%E7%BB%93/</guid>
      <description>[TOC]
CSP[2019.12]1.2.3题总结 第一题 找7倍数或者含有7的数。
// // main.cpp // [201912-1]count-num // // Created by 陈冉飞 on 2020/2/9. // Copyright © 2020 陈冉飞. All rights reserved. //  #include &amp;lt;iostream&amp;gt;using namespace std; int cnt = 0,num = 0,n,a[4]; bool check(int num){ if (num%7 == 0) return true; while (num &amp;gt; 0) { if (num%10 == 7) return true; num/=10; } return false;; } int main(int argc, const char * argv[]) { scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); while (cnt &amp;lt; n) { num++; if (check(num)) {a[(num-1)%4]++;cnt--;} cnt++; } printf(&amp;#34;%d\n%d\n%d\n%d\n&amp;#34;,a[0],a[1],a[2],a[3]); return 0; } 第二题 一开始想复杂了，想成搜索了，后来网页往下滚动看到了1e3果断循环暴力，结果还真是，，。</description>
    </item>
    
    <item>
      <title>Other-Vue Report</title>
      <link>http://www.chenranfei.site/posts/other/o-vue-report/</link>
      <pubDate>Fri, 07 Feb 2020 15:54:32 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/other/o-vue-report/</guid>
      <description>[TOC]
Label &amp;amp; Tag 每一个区块(div)有对应相应的模块的索引，
 对应函数有利用@进行对应， 对应css 利用class进行对应：   因为在css也就是在整体的style标签中每个括号对应的部分都有对应的一个类型，然后在标签中通过class=“”来找到对应的样式 其他的对应css的索引的方式直接在标签中加上:style=“”，如果多个的话要加括号      //添加的只有一个属性
 &amp;lt;div :style=“{x:’……’,b:’……&#39;}” &amp;gt;  //添加的有多个属性=&amp;gt;用大括号扩到一块
 gutter 纵向的长度
span 横向的长度
 对于更改对input的类型的更改：【包括一些修饰属性的使用、v-decorator的使用】
首先，v-decorator 是用于对输入内容的获取，是可以对输入进行修饰的，例如可以添加对输入要求的规则、是否是必须的、也可以是自己初始化号的时间……
前面可以添加对组件的修饰，例如是否可以更改，disabled。
 关于label中多层引号，外层用双引号，内层如果需要的话不能用双引号，要用单引号
 Table的渲染 &amp;amp; 表单中添加动作以及响应机制：
类似Qt的signal-slot机制。
在vue中渲染表格首先要定义一个填充的模型，在需要添加动作的利用scopedSlots来进行标示表格中的数据渲染的形式，利用Array(设置dataSource来渲染)最后渲染出来。
Type of Data 在props中声明：
Array 数组
Number 数字
 在app.vue 中与组件中的数据进行sync的方法：
(子组件：在props中声明名字(propsarray,propsnumber)以及类型，
app.vue：在data中声明(apparat,appnumber))
对于Array：利用v-bind:apparray=“propsarray”
对于Number：利用propsnumber.sync=“appnumber”
对于事件：利用$emit，
(在子组件中：需要添加动作的组件的触发响应的emit(mark,value),
在app.vue中：利用子组件中的mark，将mark绑定到app中对应的方法，利用v-on:mark=“appfunction”,或者@mark=“appfunction&amp;rdquo;)
Ant Design &amp;amp; Element 封装好的组件工具。引入即用
Ant Design of Vue https://www.</description>
    </item>
    
    <item>
      <title>Algorithm23 计算几何 凸包算法</title>
      <link>http://www.chenranfei.site/posts/acm/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/algorithm23-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 04 Feb 2020 19:03:55 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/algorithm23-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/</guid>
      <description>[TOC]
POJ1113-凸包算法 题目链接：http://poj.org/problem?id=1113 凸包算法的板题，找出凸包，计算凸包的周长加上以要求的距离为半径的圆的周长即可。
卷包裹法 思路：
 点集预处理，以横坐标为准从小到大(横坐标相同以纵坐标从小到大) 从点集的第一个点开始找上凸包。  如果要添加的点在凸包的点集中最新添加的两个点所形成的直线的右边，将改点添加进凸包的点集。 如果在左边，把凸包点集中最靠后的点移除，再判断，直到在右边就添加。   从点集的最后一个点开始找下凸包。  判断点在线的左边还是右边：利用叉积(几何意义就是通过比较斜率，利用叉积的大小可以防止斜率为零或者无穷的情况)
Graham扫描法 思路：
 点集预处理：通过两次预处理，首先提取处横纵坐标都最小的，也就是以横坐标为准从小到大(横坐标相同以纵坐标从小到大)，然后再平移坐标轴使原点与第一步找到的点重合，根据其他点与原点的斜率大小进行排序 按照预处理的顺序找凸包，要保证新添加的点在凸包的点集中最新添加的两个点所形成的直线的左边。  关于得到凸包点集中是否要凸包的边上的点(初顶点以外的其他点) eg: (1,1) (1,2) (2,1) (1,2) (3,1) 包含凸包边上的点：(1,1) (1,2) (2,1) (1,2) (3,1) 不包含：(1,1) (1,2) (1,2) (3,1)
卷包裹法得到不包含凸包边上的点 解析：此时abc在一条直线，x同或者y同，那么得到的叉积必为零，同时不满足添加进凸包点集的条件就是在线的左边或者在线上，要等于号。
int cross(point a,point b,point c){ return (a.x-c.x)*(b.y-c.y)-(a.y-c.y)*(b.x-c.x); } int solve(){ int idx = 0; // upper 0 -&amp;gt; n-1  for (int i = 0; i &amp;lt; n; i++){ while (idx &amp;gt;1 &amp;amp;&amp;amp; cross(con[idx-1], e[i], con[idx-2]) &amp;gt;= 0) idx--; con[idx++] = e[i]; } int s = idx; // lower n-1 -&amp;gt; 0  for (int i = n-1; i &amp;gt;= 0; i--) { while (idx &amp;gt; s &amp;amp;&amp;amp; cross(con[idx-1], e[i], con[idx-2]) &amp;gt;= 0) idx--; con[idx++] = e[i]; } return idx; } Graham-Scan法：同样道理：</description>
    </item>
    
    <item>
      <title>Contest CF719 div3 补题</title>
      <link>http://www.chenranfei.site/posts/contest/contest-cf719-div3/</link>
      <pubDate>Tue, 04 Feb 2020 16:12:46 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/contest/contest-cf719-div3/</guid>
      <description>[TOC]
CF719 div3 补题  https://codeforces.com/contest/1520
 A 题目大意：看字串中是否有重复出现的，连续一段出现可以，中间隔着其他的，然后再次出现就不行了。
思路：用map来维护前面所出现过的所有字符，看是否存在
#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int t, n; #include &amp;lt;map&amp;gt;map&amp;lt;char, int&amp;gt; m; char s[55]; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { int flag = 0; m.clear(); scanf(&amp;#34;%d%s&amp;#34;, &amp;amp;n, s); m[s[0]] = 1; for (int i = 1; i &amp;lt; strlen(s); ++i) { if (s[i] != s[i - 1] &amp;amp;&amp;amp; m.count(s[i])) flag = 1; else m[s[i]] = 1; } if (flag) printf(&amp;#34;NO\n&amp;#34;); else printf(&amp;#34;YES\n&amp;#34;); } return 0; } B 题目大意：找1～n范围中，所有数都相同的数（1 2 88 444是，101 67 1239不是）</description>
    </item>
    
    <item>
      <title>Contest CSU预选赛 补题</title>
      <link>http://www.chenranfei.site/posts/contest/contest-csu2021pre/</link>
      <pubDate>Tue, 04 Feb 2020 16:12:46 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/contest/contest-csu2021pre/</guid>
      <description>[TOC]
CSU 预选赛 补题  http://acm.csu.edu.cn:20080/csuoj/contest/problemset?cid=2193
 A 题目大意：贪心，可以无限选，然后问给定容积，最大价值。
思路永远选单位价值最大的，然后逐级取余。
#include &amp;lt;iostream&amp;gt;using namespace std; int a, ans; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;a); ans += (a/16)*227; a %= 16; ans += (a/8)*109; a %= 8; ans += (a/4)*49; a %= 4; ans += (a/2)*23; a %= 2; ans += a*10; printf(&amp;#34;%d\n&amp;#34;, ans); return 0; } B C D </description>
    </item>
    
    <item>
      <title>Contest ICT pFind</title>
      <link>http://www.chenranfei.site/posts/contest/contest-ict-pfind/</link>
      <pubDate>Tue, 04 Feb 2020 16:12:46 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/contest/contest-ict-pfind/</guid>
      <description>[TOC]
ICT pFind  机试：共五道，前两个签到，第三个大数乘法，第四个区间最值问题，第五个数据结构二叉树问题
 机试-1 题目大意：将二维数组进行翻转
思路：储存在二维数组中，利用循环来进行翻转然后输出。
#include &amp;lt;iostream&amp;gt;using namespace std; const int maxn = 209; int n, a[maxn][maxn]; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 1; i &amp;lt;= n; ++i) for (int j = 1; j &amp;lt;= n; ++j) scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]); for (int i = 1; i &amp;lt;= n; ++i) { for (int j = 1; j &amp;lt;= n; ++j) { printf(&amp;#34;%d &amp;#34;, a[n-j+1][i]); } printf(&amp;#34;\n&amp;#34;); } return 0; } 机试-2 题目大意：括号匹配，非左右括号的按照异常处理，然后查看左右括号是否匹配</description>
    </item>
    
    <item>
      <title>Summary1 Aczy156的算法模版</title>
      <link>http://www.chenranfei.site/posts/acm-summary/summary1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/</link>
      <pubDate>Tue, 04 Feb 2020 16:12:46 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm-summary/summary1-%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/</guid>
      <description>[TOC]
Aczy156的算法模版 常用 表示无穷大（int的上限）：
// int的最大值就是2的31次方-1 #define INF (1&amp;lt;&amp;lt;31)-1// 用库中定义的INT_MAX #include &amp;lt;climits&amp;gt;#define INF INT_MAXdouble 四舍五入的变式：永远舍和永远入：
double a = 0.656, b = 0.651; printf(&amp;#34;%.2lf %2lf&amp;#34;, a-0.05, b-0.05); // 都会往下舍，变为0.65 0.65 printf(&amp;#34;%.2lf %2lf&amp;#34;, a+0.05, b+0.05); // 都会往上入，变为0.66 0.66 字符 &amp;amp; 字符串的scanf读入
char ch scanf(&amp;#34;%c&amp;#34;, &amp;amp;ch); // 前面要加空格 char s[10]; scanf(&amp;#34;%s&amp;#34;, s); scanf字符串读入(对于流输入输出进行优化)
// 数据：2007-06-23-11:59 2007-06-23-12:00 int by, ey, bm, em, bd, ed, bh, eh, bmin, emin; scanf(&amp;#34;%d-%d-%d-%d:%d&amp;#34;, &amp;amp;by, &amp;amp;bm, &amp;amp;bd, &amp;amp;bh, &amp;amp;bmin); scanf(&amp;#34;%d-%d-%d-%d:%d&amp;#34;, &amp;amp;ey, &amp;amp;em, &amp;amp;ed, &amp;amp;eh, &amp;amp;emin); // 即可获取 char a; cin&amp;gt;&amp;gt;by&amp;gt;&amp;gt;a&amp;gt;&amp;gt;bm&amp;gt;&amp;gt;a&amp;gt;&amp;gt;bd&amp;gt;&amp;gt;a&amp;gt;&amp;gt;bh&amp;gt;&amp;gt;a&amp;gt;&amp;gt;bmin; cin&amp;gt;&amp;gt;by&amp;gt;&amp;gt;a&amp;gt;&amp;gt;bm&amp;gt;&amp;gt;a&amp;gt;&amp;gt;ed&amp;gt;&amp;gt;a&amp;gt;&amp;gt;eh&amp;gt;&amp;gt;a&amp;gt;&amp;gt;emin; // 也可以获取 cin读入提速</description>
    </item>
    
    <item>
      <title>Summary1.1 Aczy156的基础数据结构手写实现</title>
      <link>http://www.chenranfei.site/posts/acm-summary/summary1.1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 04 Feb 2020 16:12:46 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm-summary/summary1.1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0/</guid>
      <description>[TOC]
Aczy156的基础数据结构手写实现 数据结构的实现 链表
堆
STL的实现 排序算法的实现 快速排序
归并排序</description>
    </item>
    
    <item>
      <title>Summary2 Aczy156的面经</title>
      <link>http://www.chenranfei.site/posts/acm-summary/summary2-%E9%9D%A2%E7%BB%8F/</link>
      <pubDate>Tue, 04 Feb 2020 16:12:46 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/acm-summary/summary2-%E9%9D%A2%E7%BB%8F/</guid>
      <description>[TOC]
Aczy156的面经 系统 1、Linux系统的进程通信方式
管道pipeline，信号signal，消息队列message queue，共享内存，信号量semophore，套接字socket
   类型 无连接 可靠 流控制 优缺点 优先级     普通PIPE N Y Y 只能父子进程通信，速度慢 N   流PIPE N Y Y 速度慢 N   命名PIPE(FIFO) N Y Y 任何进程间都能通讯，但速度慢 N   消息队列 N Y Y  Y   信号量 N Y Y 不能传复杂消息 Y   共享存储 N Y Y 速度快，容量不限，但是面临同步问题，读写问题 Y   UNIX流SOCKET N Y Y  N   UNIX数据包SOCKET Y Y N  N    2、Linux指令：</description>
    </item>
    
    <item>
      <title>Deep Learning 14 keras</title>
      <link>http://www.chenranfei.site/posts/mldl/dl14-keras/</link>
      <pubDate>Wed, 29 Jan 2020 01:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl14-keras/</guid>
      <description>[TOC]
keras.models  Model Sequential  Keras.Input 区分于keras.layers.Input 或者区分于
keras.layers 适用于含有神经元的网络  Dropout / SpatialDropout Dense 全连接层  用于处理图像-卷积  Convention卷积：Conv1D，Conv2D 和 Conv3D Pooling池化：MaxPooling1D,MaxPooling2D, GlobalMaxPooling1D   用于NLP处理-序列模型  LSTM / Bidirectional LSTM GRU Cu  CuDNNLSTM：这个是在老版本(在V_tensorflow &amp;lt; 2.0.0)中支持的，在新的tensorflow和独立出来的keras中都是没有的，所以如果使用的话，需要1:调整tensorflow的版本小于2.0.0、2:不使用自带的独立出来的keras，而是使用tensorflow内置的keras CUDNNGRU    一些不常用的keras库 keras.engine 底层控制驱动引擎，keras.engine.topology中的Layer来自定义keras神经网络模型中的某一层(是层，不是神经元)
keras.initializers &amp;ndash; 初始化 keras.regularizers &amp;ndash; 正则化 keras.constraints &amp;ndash; 约束(以层为对象进行) keras.concatenate &amp;ndash; 用于连接 </description>
    </item>
    
    <item>
      <title>Deep Learning 14.1 pytorch</title>
      <link>http://www.chenranfei.site/posts/mldl/dl14.1-pytorch/</link>
      <pubDate>Wed, 29 Jan 2020 01:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl14.1-pytorch/</guid>
      <description>[TOC]
pytorch类比keras但区别 keras的所有子库基本都是复数，包括models, layers, optimizers等等
而torch大部分都是单数
torch.model ?
torch.input ?
torch.layer ?
torch.optim torch.optim.Adam()
一些不常用的keras库 keras.engine keras.initializers &amp;ndash; 初始化 keras.regularizers &amp;ndash; 正则化 keras.constraints &amp;ndash; 约束(以层为对象进行) keras.concatenate &amp;ndash; 用于连接 </description>
    </item>
    
    <item>
      <title>Deep Learning 16 GNN Basic</title>
      <link>http://www.chenranfei.site/posts/mldl/dl16-gnn%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 29 Jan 2020 01:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl16-gnn%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</guid>
      <description>[TOC]
工具配备：
深度学习框架：
​	常用：pytorch
神经网络框架：
 DGL：deep graph library (AWS) PyG：pytorch_geometric (Pytorch) AGL：Euler (alibaba) tf_geometric  基本流程 basic dependencies 导入dgl deep graph library ，引入，没有的话安装再引入
try: import dgl except: !pip install dgl import dgl 导入torch的一些基本依赖
Graph embedding [把整个表进行嵌入]   node embedding
  edge embedding
  build Spatial Model [构建空间model] </description>
    </item>
    
    <item>
      <title>Deep Learning 17 优化目标</title>
      <link>http://www.chenranfei.site/posts/mldl/dl17-%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87/</link>
      <pubDate>Wed, 29 Jan 2020 01:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl17-%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87/</guid>
      <description>[TOC]
优化目标 概念区分 1、整体理解：损失函数，代价函数，目标函数，熵=&amp;gt;都是最优化问题下的的优化目标，通过设定优化目标获取最优化问题的最优解
2、设计原理：为什么要设计这样的优化目标
 用交叉熵的原因，交叉熵和KL散度的关系 用平方损失的原因，平方损失和最大似然的关系 添加正则子的原因，为什么能添加这样的正则子  回归问题 平方「Square」 平方根「Square Root」 分类问题-熵「Entropy」 与熵相关的为信息论相关内容
熵「Entropy」  信息量
事件A的自信息量，A这个事件包含了多少信息
 $s(x)=\sum_{i}P_A(x_i)log(P_A(x_i))\$
验证：
交叉熵「Cross Entropy」  分类问题-二分类，对数似然
事件AB，从A的角度看，如何描述B
 信息论公式：
$H(A,B)=-\sum_{i}P_A(x_i)log(P_B(x_i))\$
对于样本集上的数据，两种表达形式，单个样本Loss &amp;amp; 整个样本集然后除样本数Cost
Loss =&amp;gt; $L=yln\hat{y}+(1-y)ln(1-\hat{y})$​
Cost =&amp;gt; $C=-\frac{1}{n}\sum_{x}^{}[yln\hat{y}+(1-y)ln(1-\hat{y}]\$
验证：当真实$y=1$，如果$\hat{y}$越接近1，则损失函数Loss越小；如果$\hat{y}$越接近0，则损失函数Loss越大。因而达到忘Loss损失函数变小的方向变化。（当真实$y=0$亦然，看下图左边是$y=1$的情况，右边是$y=0$的情况）
多分类交叉熵「Categorical Cross Entropy」  分类问题-多分类，对数似然
 相对熵「Relative Entropy」  衡量两个分布的不同
事件AB，从A的角度看，B有多大不同
 $D_{KL}(A|B)=\sum_{i}P_A(x_i)log(P_A(x_i))-\sum_{i}P_A(x_i)log(P_B(x_i))\$ （对于离散事件是求和，对于连续事件是求积分）
相对熵包含了交叉熵的内容，$D_{KL}(A|B)=\sum_{i}P_A(x_i)log(P_A(x_i))-\sum_{i}P_A(x_i)log(P_B(x_i))=s(A)+H(A,B)\$，也就是相对熵=坐标系自己的熵+交叉熵
验证：由于坐标系选取不同，对于事件A和事件B，从A的角度看，$D_{KL}(A|B)\neq D_{KL}(B|A)$
交叉熵VS相对熵/KL散度 一般情况下，都用交叉熵，不用KL散度。
首先理解分类问题的目标 =&amp;gt;看模型学习到的分布P(model)和真实分布P(real)是否接近 =&amp;gt;看模型学习到的分布P(model)和训练数据P(training)的分布是否接近 =&amp;gt;因而可以用KL散度来进行计算$D_{KL}(P(training)|P(model))$ =&amp;gt;将KL散度进行展开$D_{KL}(P(training)|P(model))=s(P(training))+H(P(training),P(model))$ =&amp;gt;由于训练数据固定，那么对应的训练数据的熵也是不变的，所以$D_{KL}$等价于交叉熵，而因为交叉熵方便计算，所以一般都使用交叉熵</description>
    </item>
    
    <item>
      <title>Deep Learning 15 Kaggle一些基本问题</title>
      <link>http://www.chenranfei.site/posts/mldl/dl15-kaggle%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 28 Jan 2020 23:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl15-kaggle%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC]
/input目录下的数据是read_only格式 可以通过copy一份到/working
两个路径：
 input路径： /kaggle/input/ working路径：/kaggle/working/  利用Linux指令进行copy
!cp -r /kaggle/input/ new_folder_name
切换tensorflow版本到旧版本( &amp;lt; 2.x ) （1）无论如何切换，在kaggle 的kernel环境下需要修改一个kernel配置，来使对环境的配置生效
修改kaggle的tensorflow的版本之后，print仍不变version的处理办法：https://www.kaggle.com/general/88036
切换原因：tensorflow训练过程中的log需要旧版本（AttributeError: module &#39;tensorflow&#39; has no attribute &#39;log&#39;）
移除掉旧的：
!pip uninstall tensorflow
安装新的：
!pip install tensorflow==1.13.1
（2）由于keras需要2.2+的版本，所以需要再次升级到高版本
!pip install--upgrade tensorflow
查看版本信息
print(tf.__version)
最后发现只有安装tensorflow 一些常见的基本报错 1、
TypeError: &amp;#39;int&amp;#39; object is not iterable 表示数据类型、数据维度不对
情况一：在for循环遍历的时候，要用range()把遍历的范围修饰，也就是把传入的int/len()给修饰
for i in len(sample_list): -&amp;gt;要改成
for i in range(len(sample_list)): 情况二：keras的layer输入数据时维度不对。
input_shape=(12) vs input_shape=(12,) 前面的是数字，然后在这一层进行读的时候，并没有转换成可iterable的，因为input的格式不对。</description>
    </item>
    
    <item>
      <title>Python 1 Pandas</title>
      <link>http://www.chenranfei.site/posts/python/python1-pandas/</link>
      <pubDate>Tue, 28 Jan 2020 23:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/python/python1-pandas/</guid>
      <description>[TOC]
数据类型相关 在处理脏数据的时候：
通过data[col][raw].dtype来查看元素的类型
通过data[col][raw].astype = specific_data_type来切换单元格的属性
截取 1）.loc,.iloc,.ix,只加第一个参数如.loc([1,2]),.iloc([2:3]),.ix[2]…则进行的是行选择 2）.loc,.at，选列是只能是列名，不能是position 3）.iloc,.iat，选列是只能是position，不能是列名 4）df[]只能进行行选择，或列选择，不能同时进行列选择，列选择只能是列名。
sex tip total_bill 0 Female 1.01 16.99 1 Male 1.66 10.34 2 Male 3.50 23.68 3 Male 3.31 23.68 4 Female 3.61 24.59 print df.loc[1:3, [&amp;#39;total_bill&amp;#39;, &amp;#39;tip&amp;#39;]] print df.loc[1:3, &amp;#39;tip&amp;#39;: &amp;#39;total_bill&amp;#39;] print df.iloc[1:3, [1, 2]] print df.iloc[1:3, 1: 3] total_bill tip 1 10.34 1.66 2 23.68 3.50 3 23.68 3.31 -------------------- tip total_bill 1 1.66 10.34 2 3.50 23.</description>
    </item>
    
    <item>
      <title>Python 2 Numpy</title>
      <link>http://www.chenranfei.site/posts/python/python2-numpy/</link>
      <pubDate>Tue, 28 Jan 2020 23:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/python/python2-numpy/</guid>
      <description>[TOC]
np.zeros np.zeros(size) 初始化为长度为size，内容为0的矢量「秩=1」==》既不是行向量也不是列向量【a.T=a即可以验证】
a = np.zeros(array_size)
np.zero(size_x, size_y) 初始化为二维的「秩=2」==》如果让此时的size_y=1,那就是个列向量；如果让此时的size_x=1,那就是个行向量
![image-20201206171734156](/Users/aczy156/Library/Application Support/typora-user-images/image-20201206171734156.png)
np.random.rand(size)/ np.random/randn(size) 初始化一个长度为size，内容为0～1随机数(精确说是高斯变量)矢量==》既不是行向量也不是列向量【a.T=a即可以验证】
a = np.random.rand(array_size)
print(a, len(a))
# 成功初始化一个矢量/数据 输出的是[xxx, xxx, ……, xxx], array_size
np.dot(array_a, array_b) 做矢量/向量的乘积（点乘）=》
 可以是下边例子的两个长度为array_size的一维向量 也可以是只要是符合矩阵乘积规则的都OK，例如(m, r) * (r, n) / (m, a) * (a, n)  a = np.random.rand(array_size)
b = np.random.rand(array_size)
c = np.dot(a, b)
np 广播
a = np.random.rand(array_size)
c = a+5 # 加上一个常数但是numpy会自动转换成一个n为向量，来和前面的格式对齐，最后就是[a[0]+5, a[1]+5, ……]
np.exp/np.expm1/np.log/np.log1p 做//做对数logv1,logv2……
v = np.</description>
    </item>
    
    <item>
      <title>Deep Learning 12 CV Target Detection</title>
      <link>http://www.chenranfei.site/posts/mldl/dl12-cvtarget-detection/</link>
      <pubDate>Tue, 28 Jan 2020 22:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl12-cvtarget-detection/</guid>
      <description>[TOC]
CV Target Detection YOLO R-CNN &amp;amp; Fast R-CNN </description>
    </item>
    
    <item>
      <title>Deep Learning 11 CV Image Segmentation</title>
      <link>http://www.chenranfei.site/posts/mldl/dl11-cvimage-segmentation/</link>
      <pubDate>Tue, 28 Jan 2020 21:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl11-cvimage-segmentation/</guid>
      <description>[TOC]
CV-Image Segmentation 图像分割 传统分割方法 理解：
 把图像分割成若干个块 每个块都有相同点 [可以利用拓广性来进行延伸]  基本方法：
  基于阈值的图像分割：按照灰度值进行提取，直接归成纯白色和纯黑色
  基于区域的图像分割：延伸合并 &amp;amp; 分裂 【两个可逆的过程】
 单个像素点 ==延伸合并==》 一个区域 整张图片 ==分裂==》 若干个区域    基于边缘检测的图像分割： 直接通过提取边缘，来划定不同的区域。
  分水岭算法
  Image Segmentation 具体方法分析 基于阈值的图像分割 特点：
阈值的影响太大：1) 阈值小 =&amp;gt; 对亮的区域/灰度值低的区域 效果好 2) 阈值大 =&amp;gt; 对暗的区域/灰度值高的区域 效果好
基于区域的图像分割  单个像素点的延伸合并  特点：
若干个单个像素点的选取影响太大。
拓广的规则/策略的设定影响太大。
 分裂  特点：
基于边缘检测的图像分割 特点：太依赖边缘的话，有可能没法形成一个回路(差一点形成一个回路)，或者很多没有规则的线。
基于主动轮廓的图像分割 分水岭算法 特点：对于边缘的分割太过敏感了，容易过度分割
基于GA遗传算法的图像分割 深度学习分割 基于特征编码 - VGGNet 分割 基于特征编码 - ResNet 特点：缓解梯度消失的问题。（类似于序列模型中的GRU(重置门、更新门)和LSTM(有三个门遗忘门、记忆门、输出门)，GRU就是）</description>
    </item>
    
    <item>
      <title>Machine Learning 10 Boosting家族</title>
      <link>http://www.chenranfei.site/posts/mldl/ml1-mlxgboost-lightgbm-catboost/</link>
      <pubDate>Tue, 28 Jan 2020 20:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/ml1-mlxgboost-lightgbm-catboost/</guid>
      <description>[TOC]
Xgboost 1 普通训练 2 对于利用交叉训练的   首先需要利用DMatrix来进行转换
  然后通过xgb的train()来进行训练
  for fold_n (train_idx, val_idx) in enumerate(folds.split(X)): train_data = xgb.DMatrix(data=X_train) val_data = xgb.DMatrix(data=X_val) model = xgb.train() Lightgbm 0 相关预处理 a) 中文属性的问题，需要编码，不然无法训练
1 普通训练 2 对于利用交叉训练的 几个组成成分
 oof: out-of-folds clf: classifier trn_idx, val_idx: 是用来在交叉验证 中用来索引到数据的，因为是需要交叉验证，选取特定的集合 lightgbm需要用lgb.Dataset 来获取他特有的数据的格式。   # 两个其他的特殊 属性数组，一个储存的是得到数据的属性的数组(如果是整个数据集的所有属性的话，那features=train.columns) features = [&amp;#39;feature1&amp;#39;, &amp;#39;feature2&amp;#39;, &amp;#39;feature3&amp;#39;, &amp;#39;feature4&amp;#39;] cat_feats = [&amp;#39;feature1&amp;#39;, &amp;#39;feature4&amp;#39;] # oof, predictions oof = np.</description>
    </item>
    
    <item>
      <title>Deep Learning 9 几种常用数据类型</title>
      <link>http://www.chenranfei.site/posts/mldl/dl9-%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 28 Jan 2020 19:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl9-%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>[TOC]
numpy 数据类型 查看维度数dim 查看各个维度的长度 【前提要知道有多少维度】
print(&amp;#39;data_np shape is: &amp;#39;, np.size(data_np, 0), np.size(data_np, 1), np.size(data_np, 2)) 需要进行维度变化的 按照维度求最值 【根据axis来选择对应的维度，然后提取最大值】 ==&amp;gt; axis=x,就是第x的维度提取最值，最后那个维度变成一，dim--
array([[0, 1, 2], [9, 4, 5], [6, 7, 8], [10, 11, 12]]) # 当前维度(4, 3) print(np.max(a)) #全局最大 8 print(np.max(a,axis=0)) #每列最大 =&amp;gt; 第一个维度的长度变为1，所以向量的长度变为3 [6 7 8] print(np.max(a,axis=1)) #每行最大 =&amp;gt; 第二个维度的长度变为1，所以向量的长度变为4 [2 5 8]import plotly.express as px fig = px.pie(data, name=&amp;#39;attr&amp;#39;) 类似于Dataframe的value_counts() 实质还是要通过形成dataframe数据结构来进行
pd.Series(numpy_data).value_counts().plot.bar()
numpy 去重 区分于List，都可以去重，其中，list可以通过转换set直接去重，即：但是无法获取重复的元素的索引
ls = list(set([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;])) numpy去重，不仅可以去重，并且可以获得重复的索引</description>
    </item>
    
    <item>
      <title>Deep Learning 8 Python 广播机制/apply/map/zip等</title>
      <link>http://www.chenranfei.site/posts/mldl/dl8-python-%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6-apply-map/</link>
      <pubDate>Tue, 28 Jan 2020 18:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl8-python-%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6-apply-map/</guid>
      <description>[TOC]
Python - 广播机制 Python - apply [维持原来的维度数]
应用场景：对于一个DataFrame
1、利用函数进行apply
然后通过给apply传入一个参数是一个映射的函数apply(func)，然后进行映射的方式就是func函数所表达的方式
def get_length(text): return len(text) train[&amp;#39;new_length&amp;#39;] = train[&amp;#39;text&amp;#39;].apply(get_length) 2、利用lambda然后直接进行转换
train[&amp;#39;new_length&amp;#39;] = train[&amp;#39;text&amp;#39;].apply(lambda x: len(x)) Python - map [降低原来的维度数]
无规则映射都是可以的。【在没有设定规则的映射下，映射方式就是通过离散型数据进行映射，自动按照长度进行映射】
也就是1-500的范围或者是abcd多少个种类，一般连续性的都没法map，因为就算map映射了之后也是各自为一个长度的直方体
 把一个csv中的某一列(全都是字符串)映射到一个这一列的长度的数组中  tweet_len = tweet.text.str.len() tweet_len.value_counts().plot.bar() 如果按照零一进行提取
# value str length fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5)) # get lens list tweet_len_1 = tweet[tweet[&amp;#39;target&amp;#39;] == 1][&amp;#39;text&amp;#39;].str.len() ax1.hist(tweet_len_1, color=&amp;#39;green&amp;#39;) tweet_len_0 = tweet[tweet[&amp;#39;target&amp;#39;] == 0][&amp;#39;text&amp;#39;].str.len() ax2.hist(tweet_len_0, color=&amp;#39;red&amp;#39;)  把一个csv中的某一列(全都是字符串)映射到一个这一列的各个元素的分割后的长度的数组中  tweet_num = tweet.</description>
    </item>
    
    <item>
      <title>Deep Learning 7 综合性案例 Credit Card Anomly Detection</title>
      <link>http://www.chenranfei.site/posts/mldl/dl7-%E7%BB%BC%E5%90%88%E6%80%A7-credit_card-anomly_detection/</link>
      <pubDate>Tue, 28 Jan 2020 17:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl7-%E7%BB%BC%E5%90%88%E6%80%A7-credit_card-anomly_detection/</guid>
      <description>[TOC]
Credit Card Frauds Detection 处理样本分布不均问题：Imbalance Datasets distribution 几种可行的解决方案：
 采样方法  under-sampling 欠采样 over-sampling 过采样   集成学习+阈值调整 *  根据不同的种类来区分颜色的【通过利用plotly=&amp;gt;histogram】
import plotly.express as px fig = px.histogram(data, x=&amp;#39;attr&amp;#39;, color=&amp;#39;attr&amp;#39;) fig.show() 直接画出数量，不用区分种类颜色的【直接利用matplotlib.pyplot=&amp;gt;bar】import matplotlib.pyplot as plt
eg1:
plt.bar(data.attr.value_counts().index, data.attr.value_counts().values) eg2:
df[&amp;#39;Attr&amp;#39;].value_counts().plot.bar() 直方图类型 [多个属性]： import plotly.express as px fig = px.histogram(data, x=&amp;#39;attr1&amp;#39;, color=&amp;#39;attr2&amp;#39;) 饼状图 [单个属性] import plotly.express as px fig = px.pie(data, name=&amp;#39;attr&amp;#39;) 数据可视化&amp;ndash;numerical data连续数据 </description>
    </item>
    
    <item>
      <title>Deep Learning 6 CV</title>
      <link>http://www.chenranfei.site/posts/mldl/dl6-cv%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 28 Jan 2020 16:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl6-cv%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B/</guid>
      <description>[TOC]
CV-数据增强 手动人工数据增强   数据为非图形化的数据「本身不是图片」
 例如Digit Recognization，通过把所有像素点放进了表格里边    数据为图形化的数据「本身是图片」
 例如Facial Keypoints Detection，通过对已经是图片的进行变形。 变形包括：  垂直镜像对称 mirroring on vertical axis 旋转类 rotation  水平翻转 horizontal flip 旋转增强 rotation augmentation   色彩转换 color shifting  亮度增强 brightness augmentation RGB变化 RGB shifting (PCA采样，AlexNet PCA色彩增强)   剪裁类 shearing  转移/移动增强 shifit agumentation 随机剪裁 random cropping   变形类 warping  局部变形 local warping   随机噪声增强 random-noise augmentation      利用albumentations进行数据增强 要点：</description>
    </item>
    
    <item>
      <title>Deep Learning 5.1 NLP 一些常用库</title>
      <link>http://www.chenranfei.site/posts/mldl/dl5.1-nlp%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B5%84%E6%96%99%E5%BA%93/</link>
      <pubDate>Tue, 28 Jan 2020 15:15:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl5.1-nlp%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B5%84%E6%96%99%E5%BA%93/</guid>
      <description>[TOC]
NLP 工具库 NLP &amp;ndash; nltk [natural language toolkit] NLP &amp;ndash; gensim NLP 语料库 NLP &amp;ndash; GloVe全局动态库  GloVe 50D GloVe 100D GloVe 200D GloVe 300D  一些其他的具有标准参考的库 String库 punctuation 【标点符号】
import string collections defaultdict 【默认字典】
Counter
from collection import defaultdict from collection import Counter </description>
    </item>
    
    <item>
      <title>Deep Learning 5 NLP基本过程</title>
      <link>http://www.chenranfei.site/posts/mldl/dl5-nlp%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 28 Jan 2020 15:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl5-nlp%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B/</guid>
      <description>[TOC]
NLP 1、数据清洗 data cleaning  清洗html中的残留的tag：BeautifulSoup 清洗标点：正则表达式 清洗常用的没有实际意义的词语(a, the)：nltk中的stepwords  # import basic dependencies from bs4 import BeautifulSoup import re from nltk.corpus import stopwords # 具体使用 # html残留tag：用BeautifulSoup，实例化对象，然后通过get_text()获取 bs = BeautifulSoup(train[&amp;#39;text_content&amp;#39;][index], &amp;#39;lxml&amp;#39;) print(&amp;#39;origin content:\n{}\nafter use BeautifulSoup to clean html tag:\n{}\n&amp;#39;, train[&amp;#39;text_content&amp;#39;][index], bs.get_text()) # 标点符号：正则表达式 letters_only = re.sub(&amp;#39;[^a-zA-Z]&amp;#39;, &amp;#39;&amp;#39;, bs.get_text()) print(&amp;#39;origin content:\n{}\nafter use re:\n{}\n&amp;#39;, bs.get_text(), letters_only) # 用nltk中导入的stopwords来删除一些常见的没有用的单词，a，the…… # 先转换成小写lower case，然后分割split，最后用nltk中的stepwords lower_case = letters_only.lower() words = lower_case.split() stopwords.words(&amp;#39;english&amp;#39;)[:20] words = [word for word in words if not word in stopwords.</description>
    </item>
    
    <item>
      <title>Deep Learning 5 NLP基本过程</title>
      <link>http://www.chenranfei.site/posts/mldl/dl5.2-nlp%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Tue, 28 Jan 2020 15:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl5.2-nlp%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE/</guid>
      <description>[TOC]
NLP punctuations - 标点 puncts = [&amp;#39;,&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;&amp;#34;&amp;#39;, &amp;#39;:&amp;#39;, &amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;, &amp;#39;-&amp;#39;, &amp;#39;!&amp;#39;, &amp;#39;?&amp;#39;, &amp;#39;|&amp;#39;, &amp;#39;;&amp;#39;, &amp;#34;&amp;#39;&amp;#34;, &amp;#39;$&amp;#39;, &amp;#39;&amp;amp;&amp;#39;, &amp;#39;/&amp;#39;, &amp;#39;[&amp;#39;, &amp;#39;]&amp;#39;, &amp;#39;&amp;gt;&amp;#39;, &amp;#39;%&amp;#39;, &amp;#39;=&amp;#39;, &amp;#39;#&amp;#39;, &amp;#39;*&amp;#39;, &amp;#39;+&amp;#39;, &amp;#39;\\&amp;#39;, &amp;#39;•&amp;#39;, &amp;#39;~&amp;#39;, &amp;#39;@&amp;#39;, &amp;#39;£&amp;#39;, &amp;#39;·&amp;#39;, &amp;#39;_&amp;#39;, &amp;#39;{&amp;#39;, &amp;#39;}&amp;#39;, &amp;#39;©&amp;#39;, &amp;#39;^&amp;#39;, &amp;#39;®&amp;#39;, &amp;#39;`&amp;#39;, &amp;#39;&amp;lt;&amp;#39;, &amp;#39;→&amp;#39;, &amp;#39;°&amp;#39;, &amp;#39;€&amp;#39;, &amp;#39;™&amp;#39;, &amp;#39;›&amp;#39;, &amp;#39;♥&amp;#39;, &amp;#39;←&amp;#39;, &amp;#39;×&amp;#39;, &amp;#39;§&amp;#39;, &amp;#39;″&amp;#39;, &amp;#39;′&amp;#39;, &amp;#39;Â&amp;#39;, &amp;#39;█&amp;#39;, &amp;#39;½&amp;#39;, &amp;#39;à&amp;#39;, &amp;#39;…&amp;#39;, &amp;#39;“&amp;#39;, &amp;#39;★&amp;#39;, &amp;#39;”&amp;#39;, &amp;#39;–&amp;#39;, &amp;#39;●&amp;#39;, &amp;#39;â&amp;#39;, &amp;#39;►&amp;#39;, &amp;#39;−&amp;#39;, &amp;#39;¢&amp;#39;, &amp;#39;²&amp;#39;, &amp;#39;¬&amp;#39;, &amp;#39;░&amp;#39;, &amp;#39;¶&amp;#39;, &amp;#39;↑&amp;#39;, &amp;#39;±&amp;#39;, &amp;#39;¿&amp;#39;, &amp;#39;▾&amp;#39;, &amp;#39;═&amp;#39;, &amp;#39;¦&amp;#39;, &amp;#39;║&amp;#39;, &amp;#39;―&amp;#39;, &amp;#39;¥&amp;#39;, &amp;#39;▓&amp;#39;, &amp;#39;—&amp;#39;, &amp;#39;‹&amp;#39;, &amp;#39;─&amp;#39;, &amp;#39;▒&amp;#39;, &amp;#39;：&amp;#39;, &amp;#39;¼&amp;#39;, &amp;#39;⊕&amp;#39;, &amp;#39;▼&amp;#39;, &amp;#39;▪&amp;#39;, &amp;#39;†&amp;#39;, &amp;#39;■&amp;#39;, &amp;#39;’&amp;#39;, &amp;#39;▀&amp;#39;, &amp;#39;¨&amp;#39;, &amp;#39;▄&amp;#39;, &amp;#39;♫&amp;#39;, &amp;#39;☆&amp;#39;, &amp;#39;é&amp;#39;, &amp;#39;¯&amp;#39;, &amp;#39;♦&amp;#39;, &amp;#39;¤&amp;#39;, &amp;#39;▲&amp;#39;, &amp;#39;è&amp;#39;, &amp;#39;¸&amp;#39;, &amp;#39;¾&amp;#39;, &amp;#39;Ã&amp;#39;, &amp;#39;⋅&amp;#39;, &amp;#39;‘&amp;#39;, &amp;#39;∞&amp;#39;, &amp;#39;∙&amp;#39;, &amp;#39;）&amp;#39;, &amp;#39;↓&amp;#39;, &amp;#39;、&amp;#39;, &amp;#39;│&amp;#39;, &amp;#39;（&amp;#39;, &amp;#39;»&amp;#39;, &amp;#39;，&amp;#39;, &amp;#39;♪&amp;#39;, &amp;#39;╩&amp;#39;, &amp;#39;╚&amp;#39;, &amp;#39;³&amp;#39;, &amp;#39;・&amp;#39;, &amp;#39;╦&amp;#39;, &amp;#39;╣&amp;#39;, &amp;#39;╔&amp;#39;, &amp;#39;╗&amp;#39;, &amp;#39;▬&amp;#39;, &amp;#39;❤&amp;#39;, &amp;#39;ï&amp;#39;, &amp;#39;Ø&amp;#39;, &amp;#39;¹&amp;#39;, &amp;#39;≤&amp;#39;, &amp;#39;‡&amp;#39;, &amp;#39;√&amp;#39;, ] fasttext mispell - 一些省略成引号的 mispell_dict = {&amp;#34;ain&amp;#39;t&amp;#34;: &amp;#34;is not&amp;#34;, &amp;#34;aren&amp;#39;t&amp;#34;: &amp;#34;are not&amp;#34;,&amp;#34;can&amp;#39;t&amp;#34;: &amp;#34;cannot&amp;#34;, &amp;#34;&amp;#39;cause&amp;#34;: &amp;#34;because&amp;#34;, &amp;#34;could&amp;#39;ve&amp;#34;: &amp;#34;could have&amp;#34;, &amp;#34;couldn&amp;#39;t&amp;#34;: &amp;#34;could not&amp;#34;, &amp;#34;didn&amp;#39;t&amp;#34;: &amp;#34;did not&amp;#34;, &amp;#34;doesn&amp;#39;t&amp;#34;: &amp;#34;does not&amp;#34;, &amp;#34;don&amp;#39;t&amp;#34;: &amp;#34;do not&amp;#34;, &amp;#34;hadn&amp;#39;t&amp;#34;: &amp;#34;had not&amp;#34;, &amp;#34;hasn&amp;#39;t&amp;#34;: &amp;#34;has not&amp;#34;, &amp;#34;haven&amp;#39;t&amp;#34;: &amp;#34;have not&amp;#34;, &amp;#34;he&amp;#39;d&amp;#34;: &amp;#34;he would&amp;#34;,&amp;#34;he&amp;#39;ll&amp;#34;: &amp;#34;he will&amp;#34;, &amp;#34;he&amp;#39;s&amp;#34;: &amp;#34;he is&amp;#34;, &amp;#34;how&amp;#39;d&amp;#34;: &amp;#34;how did&amp;#34;, &amp;#34;how&amp;#39;d&amp;#39;y&amp;#34;: &amp;#34;how do you&amp;#34;, &amp;#34;how&amp;#39;ll&amp;#34;: &amp;#34;how will&amp;#34;, &amp;#34;how&amp;#39;s&amp;#34;: &amp;#34;how is&amp;#34;, &amp;#34;I&amp;#39;d&amp;#34;: &amp;#34;I would&amp;#34;, &amp;#34;I&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;I would have&amp;#34;, &amp;#34;I&amp;#39;ll&amp;#34;: &amp;#34;I will&amp;#34;, &amp;#34;I&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;I will have&amp;#34;,&amp;#34;I&amp;#39;m&amp;#34;: &amp;#34;I am&amp;#34;, &amp;#34;I&amp;#39;ve&amp;#34;: &amp;#34;I have&amp;#34;, &amp;#34;i&amp;#39;d&amp;#34;: &amp;#34;i would&amp;#34;, &amp;#34;i&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;i would have&amp;#34;, &amp;#34;i&amp;#39;ll&amp;#34;: &amp;#34;i will&amp;#34;, &amp;#34;i&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;i will have&amp;#34;,&amp;#34;i&amp;#39;m&amp;#34;: &amp;#34;i am&amp;#34;, &amp;#34;i&amp;#39;ve&amp;#34;: &amp;#34;i have&amp;#34;, &amp;#34;isn&amp;#39;t&amp;#34;: &amp;#34;is not&amp;#34;, &amp;#34;it&amp;#39;d&amp;#34;: &amp;#34;it would&amp;#34;, &amp;#34;it&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;it would have&amp;#34;, &amp;#34;it&amp;#39;ll&amp;#34;: &amp;#34;it will&amp;#34;, &amp;#34;it&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;it will have&amp;#34;,&amp;#34;it&amp;#39;s&amp;#34;: &amp;#34;it is&amp;#34;, &amp;#34;let&amp;#39;s&amp;#34;: &amp;#34;let us&amp;#34;, &amp;#34;ma&amp;#39;am&amp;#34;: &amp;#34;madam&amp;#34;, &amp;#34;mayn&amp;#39;t&amp;#34;: &amp;#34;may not&amp;#34;, &amp;#34;might&amp;#39;ve&amp;#34;: &amp;#34;might have&amp;#34;,&amp;#34;mightn&amp;#39;t&amp;#34;: &amp;#34;might not&amp;#34;,&amp;#34;mightn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;might not have&amp;#34;, &amp;#34;must&amp;#39;ve&amp;#34;: &amp;#34;must have&amp;#34;, &amp;#34;mustn&amp;#39;t&amp;#34;: &amp;#34;must not&amp;#34;, &amp;#34;mustn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;must not have&amp;#34;, &amp;#34;needn&amp;#39;t&amp;#34;: &amp;#34;need not&amp;#34;, &amp;#34;needn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;need not have&amp;#34;,&amp;#34;o&amp;#39;clock&amp;#34;: &amp;#34;of the clock&amp;#34;, &amp;#34;oughtn&amp;#39;t&amp;#34;: &amp;#34;ought not&amp;#34;, &amp;#34;oughtn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;ought not have&amp;#34;, &amp;#34;shan&amp;#39;t&amp;#34;: &amp;#34;shall not&amp;#34;, &amp;#34;sha&amp;#39;n&amp;#39;t&amp;#34;: &amp;#34;shall not&amp;#34;, &amp;#34;shan&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;shall not have&amp;#34;, &amp;#34;she&amp;#39;d&amp;#34;: &amp;#34;she would&amp;#34;, &amp;#34;she&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;she would have&amp;#34;, &amp;#34;she&amp;#39;ll&amp;#34;: &amp;#34;she will&amp;#34;, &amp;#34;she&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;she will have&amp;#34;, &amp;#34;she&amp;#39;s&amp;#34;: &amp;#34;she is&amp;#34;, &amp;#34;should&amp;#39;ve&amp;#34;: &amp;#34;should have&amp;#34;, &amp;#34;shouldn&amp;#39;t&amp;#34;: &amp;#34;should not&amp;#34;, &amp;#34;shouldn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;should not have&amp;#34;, &amp;#34;so&amp;#39;ve&amp;#34;: &amp;#34;so have&amp;#34;,&amp;#34;so&amp;#39;s&amp;#34;: &amp;#34;so as&amp;#34;, &amp;#34;this&amp;#39;s&amp;#34;: &amp;#34;this is&amp;#34;,&amp;#34;that&amp;#39;d&amp;#34;: &amp;#34;that would&amp;#34;, &amp;#34;that&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;that would have&amp;#34;, &amp;#34;that&amp;#39;s&amp;#34;: &amp;#34;that is&amp;#34;, &amp;#34;there&amp;#39;d&amp;#34;: &amp;#34;there would&amp;#34;, &amp;#34;there&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;there would have&amp;#34;, &amp;#34;there&amp;#39;s&amp;#34;: &amp;#34;there is&amp;#34;, &amp;#34;here&amp;#39;s&amp;#34;: &amp;#34;here is&amp;#34;,&amp;#34;they&amp;#39;d&amp;#34;: &amp;#34;they would&amp;#34;, &amp;#34;they&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;they would have&amp;#34;, &amp;#34;they&amp;#39;ll&amp;#34;: &amp;#34;they will&amp;#34;, &amp;#34;they&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;they will have&amp;#34;, &amp;#34;they&amp;#39;re&amp;#34;: &amp;#34;they are&amp;#34;, &amp;#34;they&amp;#39;ve&amp;#34;: &amp;#34;they have&amp;#34;, &amp;#34;to&amp;#39;ve&amp;#34;: &amp;#34;to have&amp;#34;, &amp;#34;wasn&amp;#39;t&amp;#34;: &amp;#34;was not&amp;#34;, &amp;#34;we&amp;#39;d&amp;#34;: &amp;#34;we would&amp;#34;, &amp;#34;we&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;we would have&amp;#34;, &amp;#34;we&amp;#39;ll&amp;#34;: &amp;#34;we will&amp;#34;, &amp;#34;we&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;we will have&amp;#34;, &amp;#34;we&amp;#39;re&amp;#34;: &amp;#34;we are&amp;#34;, &amp;#34;we&amp;#39;ve&amp;#34;: &amp;#34;we have&amp;#34;, &amp;#34;weren&amp;#39;t&amp;#34;: &amp;#34;were not&amp;#34;, &amp;#34;what&amp;#39;ll&amp;#34;: &amp;#34;what will&amp;#34;, &amp;#34;what&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;what will have&amp;#34;, &amp;#34;what&amp;#39;re&amp;#34;: &amp;#34;what are&amp;#34;, &amp;#34;what&amp;#39;s&amp;#34;: &amp;#34;what is&amp;#34;, &amp;#34;what&amp;#39;ve&amp;#34;: &amp;#34;what have&amp;#34;, &amp;#34;when&amp;#39;s&amp;#34;: &amp;#34;when is&amp;#34;, &amp;#34;when&amp;#39;ve&amp;#34;: &amp;#34;when have&amp;#34;, &amp;#34;where&amp;#39;d&amp;#34;: &amp;#34;where did&amp;#34;, &amp;#34;where&amp;#39;s&amp;#34;: &amp;#34;where is&amp;#34;, &amp;#34;where&amp;#39;ve&amp;#34;: &amp;#34;where have&amp;#34;, &amp;#34;who&amp;#39;ll&amp;#34;: &amp;#34;who will&amp;#34;, &amp;#34;who&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;who will have&amp;#34;, &amp;#34;who&amp;#39;s&amp;#34;: &amp;#34;who is&amp;#34;, &amp;#34;who&amp;#39;ve&amp;#34;: &amp;#34;who have&amp;#34;, &amp;#34;why&amp;#39;s&amp;#34;: &amp;#34;why is&amp;#34;, &amp;#34;why&amp;#39;ve&amp;#34;: &amp;#34;why have&amp;#34;, &amp;#34;will&amp;#39;ve&amp;#34;: &amp;#34;will have&amp;#34;, &amp;#34;won&amp;#39;t&amp;#34;: &amp;#34;will not&amp;#34;, &amp;#34;won&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;will not have&amp;#34;, &amp;#34;would&amp;#39;ve&amp;#34;: &amp;#34;would have&amp;#34;, &amp;#34;wouldn&amp;#39;t&amp;#34;: &amp;#34;would not&amp;#34;, &amp;#34;wouldn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;would not have&amp;#34;, &amp;#34;y&amp;#39;all&amp;#34;: &amp;#34;you all&amp;#34;, &amp;#34;y&amp;#39;all&amp;#39;d&amp;#34;: &amp;#34;you all would&amp;#34;,&amp;#34;y&amp;#39;all&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;you all would have&amp;#34;,&amp;#34;y&amp;#39;all&amp;#39;re&amp;#34;: &amp;#34;you all are&amp;#34;,&amp;#34;y&amp;#39;all&amp;#39;ve&amp;#34;: &amp;#34;you all have&amp;#34;,&amp;#34;you&amp;#39;d&amp;#34;: &amp;#34;you would&amp;#34;, &amp;#34;you&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;you would have&amp;#34;, &amp;#34;you&amp;#39;ll&amp;#34;: &amp;#34;you will&amp;#34;, &amp;#34;you&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;you will have&amp;#34;, &amp;#34;you&amp;#39;re&amp;#34;: &amp;#34;you are&amp;#34;, &amp;#34;you&amp;#39;ve&amp;#34;: &amp;#34;you have&amp;#34;, &amp;#39;colour&amp;#39;: &amp;#39;color&amp;#39;, &amp;#39;centre&amp;#39;: &amp;#39;center&amp;#39;, &amp;#39;favourite&amp;#39;: &amp;#39;favorite&amp;#39;, &amp;#39;travelling&amp;#39;: &amp;#39;traveling&amp;#39;, &amp;#39;counselling&amp;#39;: &amp;#39;counseling&amp;#39;, &amp;#39;theatre&amp;#39;: &amp;#39;theater&amp;#39;, &amp;#39;cancelled&amp;#39;: &amp;#39;canceled&amp;#39;, &amp;#39;labour&amp;#39;: &amp;#39;labor&amp;#39;, &amp;#39;organisation&amp;#39;: &amp;#39;organization&amp;#39;, &amp;#39;wwii&amp;#39;: &amp;#39;world war 2&amp;#39;, &amp;#39;citicise&amp;#39;: &amp;#39;criticize&amp;#39;, &amp;#39;youtu &amp;#39;: &amp;#39;youtube &amp;#39;, &amp;#39;Qoura&amp;#39;: &amp;#39;Quora&amp;#39;, &amp;#39;sallary&amp;#39;: &amp;#39;salary&amp;#39;, &amp;#39;Whta&amp;#39;: &amp;#39;What&amp;#39;, &amp;#39;narcisist&amp;#39;: &amp;#39;narcissist&amp;#39;, &amp;#39;howdo&amp;#39;: &amp;#39;how do&amp;#39;, &amp;#39;whatare&amp;#39;: &amp;#39;what are&amp;#39;, &amp;#39;howcan&amp;#39;: &amp;#39;how can&amp;#39;, &amp;#39;howmuch&amp;#39;: &amp;#39;how much&amp;#39;, &amp;#39;howmany&amp;#39;: &amp;#39;how many&amp;#39;, &amp;#39;whydo&amp;#39;: &amp;#39;why do&amp;#39;, &amp;#39;doI&amp;#39;: &amp;#39;do I&amp;#39;, &amp;#39;theBest&amp;#39;: &amp;#39;the best&amp;#39;, &amp;#39;howdoes&amp;#39;: &amp;#39;how does&amp;#39;, &amp;#39;mastrubation&amp;#39;: &amp;#39;masturbation&amp;#39;, &amp;#39;mastrubate&amp;#39;: &amp;#39;masturbate&amp;#39;, &amp;#34;mastrubating&amp;#34;: &amp;#39;masturbating&amp;#39;, &amp;#39;pennis&amp;#39;: &amp;#39;penis&amp;#39;, &amp;#39;Etherium&amp;#39;: &amp;#39;Ethereum&amp;#39;, &amp;#39;narcissit&amp;#39;: &amp;#39;narcissist&amp;#39;, &amp;#39;bigdata&amp;#39;: &amp;#39;big data&amp;#39;, &amp;#39;2k17&amp;#39;: &amp;#39;2017&amp;#39;, &amp;#39;2k18&amp;#39;: &amp;#39;2018&amp;#39;, &amp;#39;qouta&amp;#39;: &amp;#39;quota&amp;#39;, &amp;#39;exboyfriend&amp;#39;: &amp;#39;ex boyfriend&amp;#39;, &amp;#39;airhostess&amp;#39;: &amp;#39;air hostess&amp;#39;, &amp;#34;whst&amp;#34;: &amp;#39;what&amp;#39;, &amp;#39;watsapp&amp;#39;: &amp;#39;whatsapp&amp;#39;, &amp;#39;demonitisation&amp;#39;: &amp;#39;demonetization&amp;#39;, &amp;#39;demonitization&amp;#39;: &amp;#39;demonetization&amp;#39;, &amp;#39;demonetisation&amp;#39;: &amp;#39;demonetization&amp;#39;} </description>
    </item>
    
    <item>
      <title>Deep Learning 5 NLP基本过程</title>
      <link>http://www.chenranfei.site/posts/mldl/dl5.3-nlp%E8%AF%8D%E8%AF%AD%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 28 Jan 2020 15:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl5.3-nlp%E8%AF%8D%E8%AF%AD%E5%A4%84%E7%90%86/</guid>
      <description>[TOC]
NLP - 词嵌入 </description>
    </item>
    
    <item>
      <title>Deep Learning 4 Feature Engineering 几种编码整合</title>
      <link>http://www.chenranfei.site/posts/mldl/dl4-feature-engineering%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81/</link>
      <pubDate>Tue, 28 Jan 2020 14:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl4-feature-engineering%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81/</guid>
      <description>[TOC]
Feature Engineering&amp;ndash;拼接、拆分数据 1、直接根据数据量拼接、拆分
df = pd.concat([train, test]) 用:来分割，:num表示num之前的所有，num:num之后的所有，:就是没有界限，所有的
train = df[:len_of_train] test = df[len_of_test:] 2、提前添加属性拼接、利用属性拆分
train[&amp;#39;type&amp;#39;] = &amp;#39;train&amp;#39; test[&amp;#39;type&amp;#39;] = &amp;#39;test&amp;#39; df = pd.concat([train, test]) train = df[df[&amp;#39;type&amp;#39;] == &amp;#39;train&amp;#39;] test = df[df[&amp;#39;type&amp;#39;] == &amp;#39;test&amp;#39;] 最后需要把拼接的时候，造成的test多了一个结果(也就是要预测的那个属性)属性给去掉
test.drop([&amp;#39;Ans_Attr&amp;#39;], axis=1) Feature Engineering&amp;ndash;Delete Duplicated attribute 用loc提取对应的列(那么行的位置不提取的话，就要用:来全部替代)，那就是df.loc[:,~df.colums.duplicated()]。（简化过程，先提取多余属性，df.columns.duplicated()，然后取反表示非多余的留下，用~进行筛选）
df = df.loc[:, ~df.columns.duplicated()] 用iloc的意思就是通过索引index来作为参数，提取的依据。
Feature Engineering&amp;ndash;Extract some valid info from other Attr 典型例子：
 titanic 中的用户名中，可以拆出Mrs, Mr……等，作为一个新的属性 Predict Feature Sale中，可以从Shop表中的shop_name属性中拆出城市的名字作为一个新的属性，可以从Category表中的type等，拆除新的属性来。  直接一句话搞定，split分割、map映射、lambda进行填入
shops[&amp;#39;newAttr&amp;#39;] = shops[&amp;#39;oriAttr&amp;#39;].str.split(&amp;#39;&amp;#39;).map(lambda x: x[0]) shops[&amp;#39;newAttr1&amp;#39;] = shops[&amp;#39;oriAttr&amp;#39;].</description>
    </item>
    
    <item>
      <title>Deep Learning 3 数据可视化之EDA</title>
      <link>http://www.chenranfei.site/posts/mldl/dl3-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8Beda/</link>
      <pubDate>Tue, 28 Jan 2020 13:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl3-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8Beda/</guid>
      <description>[TOC]
数据可视化&amp;ndash;categorical data 离散数据 直方图类型 [单个属性]： 根据不同的种类来区分颜色的【通过利用plotly=&amp;gt;histogram】
import plotly.express as px fig = px.histogram(data, x=&amp;#39;attr&amp;#39;, color=&amp;#39;attr&amp;#39;) fig.show() 直接画出数量，不用区分种类颜色的【直接利用matplotlib.pyplot=&amp;gt;bar】import matplotlib.pyplot as plt
eg1:
plt.bar(data.attr.value_counts().index, data.attr.value_counts().values) eg2:
df[&amp;#39;Attr&amp;#39;].value_counts().plot.bar() 直方图类型 [单个属性+多个图] ： 通过把不同图放在一个图中
# value str length fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5)) # get lens list tweet_len_1 = tweet[tweet[&amp;#39;target&amp;#39;] == 1][&amp;#39;text&amp;#39;].str.len() # get list1 ax1.hist(tweet_len_1, color=&amp;#39;green&amp;#39;) tweet_len_0 = tweet[tweet[&amp;#39;target&amp;#39;] == 0][&amp;#39;text&amp;#39;].str.len() # get list2 ax2.hist(tweet_len_0, color=&amp;#39;red&amp;#39;) 直方图类型 [多个属性]： import plotly.express as px fig = px.</description>
    </item>
    
    <item>
      <title>Deep Learning 3.1 数据可视化之模型评估阶段</title>
      <link>http://www.chenranfei.site/posts/mldl/dl3.1-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8B%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E9%98%B6%E6%AE%B5/</link>
      <pubDate>Tue, 28 Jan 2020 13:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl3.1-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8B%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E9%98%B6%E6%AE%B5/</guid>
      <description>[TOC]
数据可视化 &amp;ndash; 通过sklearn.metrics直接plot from sklearn.metrics import plot_precision_recall_curve
from sklearn.metrics import plot_roc_curve
from sklearn.metrics import plot_confusion_matrix
1、三个参数，分别是classifier、X_test / X_train / X_val、y_test / y_train / y_val，把模型+数据集传入方法中，然后直接进行预测，并把预测出来的数据和本来就有的y_test进行运算。
数据可视化 &amp;ndash; 通过sklearn.metrics进行计算，然后通过其他画图工具去画 首先计算所需要相关的包
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score 
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import roc_auc_score
from sklearn.metrics import confusion_matrix
【一】plot_roc_curve // 然后顺便计算出来auc(也就是线下边的面积)
1、通过roc_curve来计算tpr真正率和fpr假正率
2、通过auc来计算ROC面积
3、通过plt.plot()来画图
def plot_roc_curve_(y_true, y_pred): # Compute ROC curve and ROC area(auc) fpr, tpr, threshold = roc_curve(y_true, y_pred) # 计算真正率和假正率 roc_auc = auc(fpr, tpr) # plot plt.</description>
    </item>
    
    <item>
      <title>Deep Learning 2 Kaggle Competition</title>
      <link>http://www.chenranfei.site/posts/mldl/dl2-kaggle-competition/</link>
      <pubDate>Tue, 28 Jan 2020 12:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl2-kaggle-competition/</guid>
      <description>[TOC]
[Kaggle] House Price 结构化数据(表格)、回归问题(预测房价)
2020.4.20 House Prices V1.0

[Kaggle] TMDB Box Office Prediction 结构化数据(表格，表格拼接)、回归问题
题意：预测某公司的全球票房
解法：脏数据的处理(把表格中的特定数据列中的json数据提取解析出来)
[Kaggle] Digit Recognizer 解法：通过deeplearning+Neutral Network来提取属性，利用分类器来分类，神经网络最后一层用softmax。
非结构化数据(虽然是利用表格来描述的图片像素点，但是只是通过像素点来表示图像，像素点并不能作为 单独的可以提炼出来的属性)、分类问题(softmax层多分类)
2020.4.23 Digit Recognizer V1.0

[Kaggle] Titanic 结构化数据(表格)、分类问题(二分类TorF)
2020.4.26 Titanic V1.0
2020.7.12 Titanic V2.0: New Featureing Engineering

[Kaggle] DeepFake 非结构化数据(视频-图片,音频)、分类问题(二分类TorF)
20207.20 DeepFake: Data proprocessing

[iFLYTEK] Temperature Predict 结构化数据(表格)、时序问题(随时间推移)
2020.7.27 Temperature Predict：Basic structure, use lightgbm and xgboost

[Kaggle] Bike Sharing Demand 结构化数据(表格)、时序问题(随时间推移)
2020.7.31 bike sharing use rf and GDBT</description>
    </item>
    
    <item>
      <title>Deep Learning 1 IFLY Temperature Predict</title>
      <link>http://www.chenranfei.site/posts/mldl/dl1-ifly_temperature_predict/</link>
      <pubDate>Tue, 28 Jan 2020 04:05:44 +0800</pubDate>
      
      <guid>http://www.chenranfei.site/posts/mldl/dl1-ifly_temperature_predict/</guid>
      <description>[TOC]
描述 随着计算机技术的发展，我国逐渐实现了从传统农业到现代农业的转变，正逐步迈向智慧农业。温室是现代农业技术应用的典型场景，其内部环境具有可操作性，能人为形成适宜植物生长的小型封闭生态系统，提升农产品的产量和质量，因此被广泛应用于农业生产中。在温室的各项环境因子中，作物对温度最为敏感。温度的高低影响植株细胞的酶活性，从而影响作物的生长速度、产量和质量，因此温度对作物生长发育影响极大。为了保证农产品的产量和质量，应保证作物正常生长，需对温室温度进行精确的调控。
二、赛事任务 温室温度调控需要对温室温度进行精准的预测，本次大赛提供了中国农业大学涿州实验站的温室温度数据作为样本，参赛选手需基于提供的样本构建模型，预测温室温度变化情况。
三、评审规则 1.数据说明： 本次比赛为参赛选手提供了温室内外的部分传感器数据，包括温室内的温度、湿度、气压以及温室外的温度、湿度、气压。
本次比赛分为初赛和复赛两个阶段，初赛阶段提供约30天的传感器数据，其中前20天的数据作为训练数据，后10天的数据用于做温度预测；复赛阶段提供约15天的传感器数据，其中前10天的数据作为训练数据，后5天的数据用于做温度预测。
注1：训练集的数据，每1分钟1条数据记录；测试集的数据，每30分钟1条数据记录。
注2：选手不能利用“未来的实际数据”预测“过去的数据”，例如，假设要预测2020/6/18 08:08:08的室内温度，就不能利用这个时间点以后的真实数据进行预测。
特别说明，温室内的湿度和气压以及温室外的温度、湿度和气压会对温室内的温度产生一定的影响。
2.评估指标 本模型依据提交的结果文件，采用均方误差MSE进行评价。 观测值，预测值，待预测的记录数n，计算公式如下：数据准备工作  load dependencies ：五大常用numpy, pandas, matplotlib, seaborn, warnings 和一些基本的依赖 load data 加载数据：train, test check data 数据的基本状态结构，  加载依赖
# Common five dependencies import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline import seaborn as sns sns.set_style(&amp;#39;whitegrid&amp;#39;) import warnings warnings.filterwarnings(&amp;#39;ignore&amp;#39;) import datetime from tqdm import tqdm 加载数据：注意路径问题
# load datall df_train = pd.</description>
    </item>
    
  </channel>
</rss>