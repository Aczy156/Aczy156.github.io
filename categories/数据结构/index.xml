<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on Aczy156</title>
    <link>https://www.skyzh.dev/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on Aczy156</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Aczy156</copyright>
    <lastBuildDate>Mon, 01 Feb 2021 19:03:55 +0800</lastBuildDate>
    
	<atom:link href="https://www.skyzh.dev/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algorithm11 数据结构 线性表 整合</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>数据结构 线性表 杂乱整合 约瑟夫问题 https://www.luogu.com.cn/problem/P1996
题目大意：有规则抽取特定位置索引
1、删除、首尾添加、排序等等 =&amp;gt; vector
#include &amp;lt;iostream&amp;gt;using namespace std; int n, m, idx=0; #include &amp;lt;vector&amp;gt;vector&amp;lt;int&amp;gt; b; int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) b.push_back(i); while (b.size() &amp;gt; 1) { idx = (idx+m-1)%b.size(); printf(&amp;#34;%d &amp;#34;, b[idx]); b.erase(b.begin()+idx); } printf(&amp;#34;%d\n&amp;#34;, b[0]); return 0; } 前&amp;amp;中&amp;amp;后缀 https://www.luogu.com.cn/problem/P1449
题目大意：解析前、中、后缀表达式，然后得到表达式的值的意思
1、前缀中缀后缀，表达式 =&amp;gt; 栈
#include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;lt;stack&amp;gt;char ch; int a, b, store; stack&amp;lt;int&amp;gt; s; int main() { while (ch !</description>
    </item>
    
    <item>
      <title>Algorithm11.1 数据结构 线性表 链表</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm11.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm11.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/</guid>
      <description>数据结构 线性表 - 链表  1、通过STL库中的list，直接可以使用的链表
2、通过手写链表
 队列排队问题 - 利用STL库中的链表进行实现 https://www.luogu.com.cn/problem/P1160
题目大意：在特定位置添加、插入成员，从而建立一个队列；然后通过调整相关的前后顺序位置，得到最后的队列
1、特定位置插入、前后顺序（相邻位置）调整 =&amp;gt; 链表 // 双向链表
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 100010int n, m, idx, tp; #include &amp;lt;list&amp;gt;list&amp;lt;int&amp;gt; l; using Iterator = list&amp;lt;int&amp;gt;::iterator; Iterator pos[maxn]; // 用于存储索引关系 bool erased[maxn]; int main() { // init  l.push_front(1); pos[1] = l.begin(); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for (int i = 2; i &amp;lt;= n; ++i){ scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;idx, &amp;amp;tp); if (!tp) pos[i] = l.</description>
    </item>
    
    <item>
      <title>Algorithm11.2 数据结构 堆与堆优化</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm11.2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%89%8B%E5%86%99%E5%A0%86/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm11.2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%89%8B%E5%86%99%E5%A0%86/</guid>
      <description>数据结构 堆 &amp;amp; 手写堆  用到堆优化的思路不一定是用堆，也可能是通过利用优先队列进行优化
 堆的应用场景：解决重复排序问题，每添加一个新的元素【在线更新】，都要重新排一次序 =&amp;gt; 可以用堆进行优化
https://www.luogu.com.cn/problem/P3378
手写堆 实现 获取区间前几大/最大 1、数据结构：一个模拟堆的数组myheap
2、堆的基本操作：
 insert：插入新的元素 myheap[1]：获取堆顶元素 deletetop：删除堆顶元素  3、【下面范例都是小顶堆】
插入新的元素 =&amp;gt; 从堆底往堆顶移动索引
while (idx &amp;gt; 1) { if (myheap[idx] &amp;lt; myheap[idx&amp;gt;&amp;gt;1]) { swap(myheap[idx], myheap[idx&amp;gt;&amp;gt;1]); idx &amp;gt;&amp;gt;= 1; } } 删除堆顶元素 =&amp;gt; 从堆顶网堆底移动索引
int son = idx&amp;lt;&amp;lt;1; while (son &amp;lt;= size) { if (son &amp;lt; size &amp;amp;&amp;amp; myheap[son] &amp;gt; myheap[son+1]) son++; if (myheap[son] &amp;lt; myheap[idx]) { swap(myheap[son], myheap[idx]); idx &amp;lt;&amp;lt;= 1; } } 完整代码：</description>
    </item>
    
    <item>
      <title>Algorithm11.3 数据结构 线性表 栈</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm11.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%A0%88%E5%8D%95%E8%B0%83%E6%A0%88/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm11.3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%A0%88%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
      <description>数据结构 线性表 - 栈  1、通过STL库中的stack，直接可以使用的链表
2、通过手写栈
 进出栈顺序问题 - 利用STL库中的栈进行实现 https://www.luogu.com.cn/problem/P4387
题目大意：给定进栈顺序和出栈顺序，根据进栈顺序来比对出栈顺序是否正确
1、push、pop、empty
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 100010int t, len, in[maxn], out[maxn], idx_out; #include &amp;lt;stack&amp;gt;stack&amp;lt;int&amp;gt; s; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); while (t--) { // init  idx_out = 1; scanf(&amp;#34;%d&amp;#34;, &amp;amp;len); for (int i = 1; i &amp;lt;= len; ++i) scanf(&amp;#34;%d&amp;#34;, &amp;amp;in[i]); for (int i = 1; i &amp;lt;= len; ++i) scanf(&amp;#34;%d&amp;#34;, &amp;amp;out[i]); for (int i = 1; i &amp;lt;= len; ++i) { s.</description>
    </item>
    
    <item>
      <title>Algorithm11.4 数据结构 二叉树建树 前中后序遍历</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm11.4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm11.4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>数据结构 二叉树 建树、前中后序遍历  两种实现方式：
 二叉链表实现 结构体数组实现  性质：
 前序 中序 后序 dfs序 相关性质 给出两个，推第三个  给出前+后【不带中】 =&amp;gt; 中序不一定唯一 给出中+前【带中】 =&amp;gt; 后序唯一 给出中+后【带中】 =&amp;gt; 前序唯一     二叉链表实现 - 利用链表来链接起树的结构 1、节点中有两个指向叶子结点的指针。
struct node(){ int data; node * lchild; node * rchild; node(){} node(int data): data(data){} node(int data, node * lchild, node * rchild): data(data), lchild(lchild), rchild(rchild){} } 2、要给出的数据，是一串字符串，然后通过递归建树的过程中，逐渐输入scanf进去
例如：
// 两组测试用例 // A B D # # E # # C F # # G # # // 1 2 4 # # 5 # # 3 6 # # 7 # # // A B C # # D E # G # # F # # # // 1 2 3 # # 4 5 # 6 # # 7 # # # 3、思路：由于是二叉链表，实质上是指针指向的，所以就写一个递归的返回指针的函数。</description>
    </item>
    
    <item>
      <title>Algorithm11.5 数据结构 哈夫曼树 哈夫曼编码</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm11.5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0&#43;%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm11.5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0&#43;%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>数据结构 哈夫曼树  实现方式：
 二叉链表实现【实现和二叉树的二叉链表实现方式几乎一样，链接： 二叉树-二叉链表实现 】   二叉链表实现 - 利用链表来链接起树的结构 1、节点中有两个指向叶子结点的指针。结构体的因为是二叉链表，所以和二叉树的类似。
struct node(){ int data; node * lchild; node * rchild; } *huffmantree, huffman[maxn];; 2、新增的数据结构：也就是huffman[maxn]，起作用就是储存所有的节点的。
对应的思路，每次挑出节点中值最小的两个，然后把这两个节点合成一个，然后进行排序，并把新产生的节点放到优先队列中，然后再选出两个最小的，一直这么迭代下去。
 通过一个vis数组，来将右儿子给闭掉，然后将左儿子的值更新为他们所形成的父亲节点的值。  node * HuffmanTree() { for (int i = 0; i &amp;lt; n - 1; i++) { for (int j = 0; j &amp;lt; n; ++j) if (!vis[j]) pq.push({huffman[j].data, j}); ll = pq.top().idx;pq.pop(); rr = pq.top().idx; while (!pq.empty()) pq.pop(); vis[rr] = 1; node * lnode = new node {huffman[ll].</description>
    </item>
    
    <item>
      <title>Algorithm17 数据结构ST表</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84st%E8%A1%A8/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84st%E8%A1%A8/</guid>
      <description>ST表-可重复贡献问题 // RMQ（Min/Max） // 区间gcd 区间min/max/gcd 区分与线段树 ？？？
https://www.luogu.com.cn/problem/P3865
模版 - ST表 题目大意：得到范围内（Range）最大值（Max）的若干次查询（Query）=&amp;gt;RMQ问题
1、倍增思想，核心就是二倍二倍的获取最大值，类似于二叉树结构的遍历过程，复杂度为O(nlogn)。
maxx[i][j]二维数组：维护的数据结构，表示[i, i+pow(2, j)-1]区间的最大值。=&amp;gt;i表示区间的起点，j表示倍增的倍数。所以在初始化的时候j所需要max的就是两个j-1倍数的区间来比较最大值(其中两个区间的起点分别是i和i+1&amp;lt;&amp;lt;(j-1))，也就是在这个倍增的倍数情况下，需要把起点往后挪的长度。
maxx[i][j] = max(maxx[i][j-1], max[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); 2、查询的时候反向解析
利用query函数来进行解析：先找到该区间对应的倍数，然后再顺着区间的右边界找到对应的查找区间，可以考虑到这个区间不一定是刚好划分好的二倍的区间，所以可以通过拼接子区间来获取最大的
int k = log2(r-l+1); return max(maxx[l][k], maxx[r-(1&amp;lt;&amp;lt;k)+1][k]); 3、注意数组不要开太大，因为倍增最多也就是21倍，2的21次方这么大的区间长度
#include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 1000010int n, m, a[maxn], maxx[maxn][21], ta, tb; // maxx[i][j]表示[i, i+pow(2, j)-1]的区间的最大值  inline int read() { char c=getchar();int x=0,f=1; while(c&amp;lt;&amp;#39;0&amp;#39;||c&amp;gt;&amp;#39;9&amp;#39;){if(c==&amp;#39;-&amp;#39;)f=-1;c=getchar();} while(c&amp;gt;=&amp;#39;0&amp;#39;&amp;amp;&amp;amp;c&amp;lt;=&amp;#39;9&amp;#39;){x=x*10+c-&amp;#39;0&amp;#39;;c=getchar();} return x*f; } // init maxx数组，通过迭代j来2倍率的速度进行初始化=&amp;gt;填补maxx数组 void init() { for (int i = 1; i &amp;lt;= n; ++i) maxx[i][0] = a[i]; for (int j = 1; j &amp;lt;= 21; ++j) for (int i = 1; i+(1&amp;lt;&amp;lt;j)-1 &amp;lt;= n; ++i) maxx[i][j] = max(maxx[i][j-1], maxx[i+(1&amp;lt;&amp;lt;(j-1))][j-1]); } int query(int l, int r) { int k = log2(r-l+1); return max(maxx[l][k], maxx[r-(1&amp;lt;&amp;lt;k)+1][k]); } int main() { n = read();m = read(); for (int i = 1; i &amp;lt;= n; ++i) a[i] = read(); init(); while (m--) { ta = read();tb = read(); printf(&amp;#34;%d\n&amp;#34;, query(ta, tb)); } return 0; } RMQ模版-最大和最小都有 【类似https://www.</description>
    </item>
    
    <item>
      <title>Algorithm18 数据结构 树状数组</title>
      <link>https://www.skyzh.dev/posts/acm/algorithm18-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Feb 2021 19:03:55 +0800</pubDate>
      
      <guid>https://www.skyzh.dev/posts/acm/algorithm18-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      <description>数据结构 树状数组 https://www.luogu.com.cn/problem/P3374
模版-区间求和(查询)、单点修改(操作) 0、lowbit()看当前节点的归属情况/看当前节点所管辖的节点的个数
eg：8(10) &amp;amp; -8(10) = 8 =&amp;gt; 根据树状数组结构图，就是8个节点
eg：4(10) &amp;amp; -4(10) = 4 =&amp;gt; 根据树状数组结构图，就是4个节点
eg：6(10) &amp;amp; -6(10) = 2 =&amp;gt; 根据树状数组结构图，就是2个节点
![image-20210308181959879](/Users/aczy156/Library/Application Support/typora-user-images/image-20210308181959879.png)
1、单点修改
=&amp;gt; 自下而上修改 =&amp;gt; c数组的索引pos从1开始往上找，但是要限定永远≤n =&amp;gt; 从下往上找的话，看当前的节点归属那个父节点范围，则需要pos+=lowbit(pos)，此时就可以直接爬升到父节点。
void single_add(int pos, int k) { while(pos &amp;lt;= n) { c[pos] += k; pos += lowbit(pos); } } 2、区间求和「注意这个区间求的是前缀和，也就是1到pos的和。如果区间和的话，可以通过两个前缀和相减得到」
=&amp;gt; 自上而下累加 =&amp;gt; c数组的索引pos从target目标开始往下找，但是要限定下限，不能让下限爆掉，pos≥1 =&amp;gt; 从上往下累加的话，看当前的节点归属那个的子节点，则需要pos-=lowbit(pos)，此时就可以直接下降到子节点。
int getsum(int pos) { int ans = 0; while(pos &amp;gt;= 1) { ans += c[pos]; pos -= lowbit(pos); } } #include &amp;lt;iostream&amp;gt;using namespace std; #define maxn 500010int n, m, tm, tp, ta, tb, c[maxn]; int lowbit(int x) {return x &amp;amp; (-x);} void single_add(int pos, int k) { while (pos &amp;lt;= n) { c[pos] += k; pos += lowbit(pos); } } int getsum(int pos) { int ans = 0; while (pos &amp;gt;= 1) { ans += c[pos]; pos -= lowbit(pos); } return ans; } int main() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;tm);single_add(i, tm);} while (m--) { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;tp, &amp;amp;ta, &amp;amp;tb); if (tp-1) printf(&amp;#34;%d\n&amp;#34;, getsum(tb)-getsum(ta-1)); else single_add(ta, tb); } return 0; } 模版-区间修改(操作)、单点求和(查询) 区间修改+单点求和 模版：https://www.</description>
    </item>
    
  </channel>
</rss>