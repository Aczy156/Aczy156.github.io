<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Algorithm14.1 最短路 - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Algorithm14.1 最短路 | Aczy156" />
	<meta name="twitter:title" content="Algorithm14.1 最短路 | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Algorithm14.1 最短路 | Aczy156" />
	<meta name="application-name" content="Algorithm14.1 最短路 | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Algorithm14.1 最短路" />
<meta property="og:description" content="[TOC]
最短路 三大思路  Basic：Floyd Greedy：Dijkstra DP：Bellman-Ford、SPFA      Greedy DP Basic     代表方法 Dijkstra Bellman-Ford Floyd   数据结构 d[i]表示到起点的最小距离 d[i]表示到起点的最小距离 d[i][j]表示i、j两点之间的最小距离   思路
(V为点，E为边) 1. 从所有其他点中找到距离起点最小的点argmin{d[i])}
2. 用距离起点最小的点和当前点来更新所有其他点
3. 复杂度$O(V^2)$ 1. 用所有其他点来更新当前点
2. 复杂度$O(V^2)$ 1. 选取起点i、中间点k、终点j三个点。
2. 用d[i][k]和d[k][j]来更新d[i][j]
3. 复杂度$O(V^3)$   优化思路 1. 寻找当前距离最小的点过程：优化从所有其他点中找到距离起点最小的点 =&gt; 利用优先队列/堆来不断选取距离最小的d
2. 刷新其他点距离的点集过程：将所有其他点缩小为相邻的点集 =&gt; 通过邻接表、链式前向星找相邻点 SPFA
1. 优化所有其他点：将所有其他点缩小为相邻的点集 =&gt; 通过邻接表、链式前向星找相邻点
2. 优化当前点：维护队列，所有接触到的、没进队列的点都需要进队列被更新一次，从而逐步筛选出所有需要被更新的当前点。    优化方法详细 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chenranfei.site/posts/acm/%E5%9B%BE%E8%AE%BA/algorithm14.1.1-dijkstra/" />
<meta property="article:published_time" content="2021-02-01T19:03:55+08:00" />
<meta property="article:modified_time" content="2021-02-01T19:03:55+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm14.1 最短路"/>
<meta name="twitter:description" content="[TOC]
最短路 三大思路  Basic：Floyd Greedy：Dijkstra DP：Bellman-Ford、SPFA      Greedy DP Basic     代表方法 Dijkstra Bellman-Ford Floyd   数据结构 d[i]表示到起点的最小距离 d[i]表示到起点的最小距离 d[i][j]表示i、j两点之间的最小距离   思路
(V为点，E为边) 1. 从所有其他点中找到距离起点最小的点argmin{d[i])}
2. 用距离起点最小的点和当前点来更新所有其他点
3. 复杂度$O(V^2)$ 1. 用所有其他点来更新当前点
2. 复杂度$O(V^2)$ 1. 选取起点i、中间点k、终点j三个点。
2. 用d[i][k]和d[k][j]来更新d[i][j]
3. 复杂度$O(V^3)$   优化思路 1. 寻找当前距离最小的点过程：优化从所有其他点中找到距离起点最小的点 =&gt; 利用优先队列/堆来不断选取距离最小的d
2. 刷新其他点距离的点集过程：将所有其他点缩小为相邻的点集 =&gt; 通过邻接表、链式前向星找相邻点 SPFA
1. 优化所有其他点：将所有其他点缩小为相邻的点集 =&gt; 通过邻接表、链式前向星找相邻点
2. 优化当前点：维护队列，所有接触到的、没进队列的点都需要进队列被更新一次，从而逐步筛选出所有需要被更新的当前点。    优化方法详细 1."/>
<script src="https://chenranfei.site/js/feather.min.js"></script>
	
	<link href="https://chenranfei.site/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="https://chenranfei.site/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://chenranfei.site/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<aside>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#最短路">最短路</a>
      <ul>
        <li><a href="#三大思路">三大思路</a></li>
        <li><a href="#my-template">My-Template</a></li>
        <li><a href="#dijkstra邻接矩阵用mpmaxnmaxn二维矩阵储存">Dijkstra+邻接矩阵【用mp[maxn][maxn]二维矩阵储存】</a></li>
        <li><a href="#dijkstra邻接表结构体用vector向量来进行储存">Dijkstra+邻接表【结构体+用vector向量来进行储存】</a></li>
        <li><a href="#dijkstra链式前向星结构体">Dijkstra+链式前向星【结构体】</a></li>
        <li><a href="#dijkstra链式前向星多源最短路">Dijkstra+链式前向星+多源最短路</a></li>
        <li><a href="#dijkstra链式前向星双向建图">Dijkstra+链式前向星+双向建图</a></li>
        <li><a href="#堆优化-结构体-dijkstra提高效率">堆优化-结构体-Dijkstra提高效率</a></li>
        <li><a href="#堆优化-pair进行绑定-dijkstra提高效率">堆优化-pair进行绑定-Dijkstra提高效率</a></li>
        <li><a href="#spfa-负权--无负圈">SPFA 负权 & 无负圈</a></li>
        <li><a href="#bf-负权--检测负圈">BF 负权 & 检测负圈</a></li>
        <li><a href="#反向建图堆优化">反向建图、堆优化</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
	<article>
		<div class="title">
			<h1 class="title">Algorithm14.1 最短路</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="最短路">最短路</h2>
<h3 id="三大思路">三大思路</h3>
<ul>
<li>Basic：Floyd</li>
<li>Greedy：Dijkstra</li>
<li>DP：Bellman-Ford、SPFA</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Greedy</th>
<th>DP</th>
<th>Basic</th>
</tr>
</thead>
<tbody>
<tr>
<td>代表方法</td>
<td>Dijkstra</td>
<td>Bellman-Ford</td>
<td>Floyd</td>
</tr>
<tr>
<td>数据结构</td>
<td><code>d[i]</code>表示到起点的最小距离</td>
<td><code>d[i]</code>表示到起点的最小距离</td>
<td><code>d[i][j]</code>表示i、j两点之间的最小距离</td>
</tr>
<tr>
<td>思路<br />(V为点，E为边)</td>
<td>1. 从所有其他点中找到距离起点最小的点<code>argmin{d[i])}</code><br />2. 用<u>距离起点最小的点</u>和<u>当前点</u>来更新<em><strong>所有其他点</strong></em><br />3. 复杂度$O(V^2)$</td>
<td>1. 用<u>所有其他点</u>来更新<em><strong>当前点</strong></em><br />2. 复杂度$O(V^2)$</td>
<td>1. 选取起点i、中间点k、终点j三个点。<br />2. 用<code>d[i][k]</code>和<code>d[k][j]</code>来更新<code>d[i][j]</code><br />3. 复杂度$O(V^3)$</td>
</tr>
<tr>
<td>优化思路</td>
<td>1. 寻找当前距离最小的点过程：优化从所有其他点中找到距离起点最小的点 =&gt; 利用优先队列/堆来不断选取距离最小的d<br />2. 刷新其他点距离的点集过程：将所有其他点缩小为相邻的点集 =&gt; 通过邻接表、链式前向星找相邻点</td>
<td>SPFA<br />1. 优化所有其他点：将所有其他点缩小为相邻的点集 =&gt; 通过邻接表、链式前向星找相邻点<br />2. 优化当前点：维护队列，所有接触到的、没进队列的点都需要进队列被更新一次，从而逐步筛选出所有需要被更新的当前点。</td>
<td></td>
</tr>
<tr>
<td>优化方法详细</td>
<td>1. 从优先队列中取队首，也即d最小的点。<br />2. 从邻接表中找到这个点的所有邻接点，将值进行更新。<br />3. 复杂度$O(E\log{V})$</td>
<td>1. 把当前点放在队列中（最初放的是起点s）<br />2. 从邻接表中找到这个点的所有邻接点，先松弛，后依据进入次数进入队列。<br />3. 复杂度$O(KE)$，其中K&laquo;E。</td>
<td></td>
</tr>
<tr>
<td>适用情况</td>
<td>1. 最短路且存在负权环：在筛选d的时候，负权环会让相同的最小的d不断变小<br />2. 最长路且存在正权环。</td>
<td>对于重复进入队列点，即为存在负权环、正权环</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>博客引流：我的CSDN博客，关于最短路优化历程，洛谷P3379和P4779的优化历程</p>
<p><a href="https://blog.csdn.net/qq_43345204/article/details/115360233?spm=1001.2014.3001.5501">我的CSDN博客 洛谷P3371、P4779 最短路Dijikstra优化历程(邻接矩阵-＞邻接表-＞链式前向星-＞堆优化)</a></p>
</blockquote>
<h3 id="my-template">My-Template</h3>
<p>邻接矩阵 or 链式前向星-普通</p>
<p>邻接矩阵 or 链式前向星-堆优化</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">nd</span> {<span style="color:#66d9ef">int</span> pos, val;}
priority_queue<span style="color:#f92672">&lt;</span>nd<span style="color:#f92672">&gt;</span> pq;
<span style="color:#66d9ef">int</span> d[maxpoint], d1, d2; <span style="color:#75715e">// 用于临时储存两个点到起点的距离，分别是u点到s点的距离以及v点到s点的距离
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> vis[maxpoint];
<span style="color:#66d9ef">int</span> u, v; <span style="color:#75715e">// 用于获取边的两个点的坐标，其中u是承接从优先队列中获得的点的位置，v是通过遍历邻接表获得的
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> e) {
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) d[i] <span style="color:#f92672">=</span> INF;
  dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  pq.push({s, dis[s]});
  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty()) {
    u <span style="color:#f92672">=</span> pq.top().pos, d1 <span style="color:#f92672">=</span> pq.top().val;pq.pop();
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[u]) {
      vis[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> tm : G[u]) {
        v <span style="color:#f92672">=</span> tm.first, d2 <span style="color:#f92672">=</span> tm.second;
        <span style="color:#66d9ef">if</span> (d[v] <span style="color:#f92672">&lt;</span> d1<span style="color:#f92672">+</span>d2) {
          d[v] <span style="color:#f92672">=</span> d1<span style="color:#f92672">+</span>d2;
          <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[v]) pq.push({v, d[v]});
        }
      }
    }
  }
}
</code></pre></div><h3 id="dijkstra邻接矩阵用mpmaxnmaxn二维矩阵储存">Dijkstra+邻接矩阵【用<code>mp[maxn][maxn]</code>二维矩阵储存】</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 10010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ll;
ll n, m, bg, dis[maxn], vis[maxn], mp[maxn][maxn], ta, tb, tc, tem, v;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> INF <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">31</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> mp[bg][i];
    vis[bg] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        tem <span style="color:#f92672">=</span> INF,v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[j] <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> tem) tem <span style="color:#f92672">=</span> dis[v<span style="color:#f92672">=</span>j];
        vis[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[v]<span style="color:#f92672">+</span>mp[v][j] <span style="color:#f92672">&lt;</span> dis[j]) dis[j] <span style="color:#f92672">=</span> dis[v]<span style="color:#f92672">+</span>mp[v][j];
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld </span><span style="color:#e6db74">&#34;</span>, dis[i]);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld%lld%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>bg);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld%lld%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        mp[ta][tb] <span style="color:#f92672">=</span> mp[tb][ta] <span style="color:#f92672">=</span> tc;
    }
    dijkstra();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="dijkstra邻接表结构体用vector向量来进行储存">Dijkstra+邻接表【结构体+用vector向量来进行储存】</h3>
<p>数据结构：（详细的邻接表vector实现见 <a href="http://chenranfei.online/post/algorithm14.0-%E5%9B%BE%E8%AE%BA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F/">Algorithm14.0 图论 数据结构存储形式</a> ）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> edge{<span style="color:#66d9ef">int</span> to, cost;};
vector<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span> gh[maxn];
</code></pre></div><p><a href="https://www.luogu.com.cn/problem/P3371">https://www.luogu.com.cn/problem/P3371</a></p>
<p>题目大意：最短路模版</p>
<p>1、值的初始化=&gt;dis数组除了dis[自身]全部初始化为INF。</p>
<p>2、过程：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-markdown" data-lang="markdown">遍历所有点
	遍历每个点的时候都重新遍历一边dis最短距离数组，从最短距离数组里选出最短的 值-tem 和 索引-v
	利用获取到的这个dis最短距离数组中的最小的，来更新邻接表gh[v]中的所有节点的距离，也就是gh[v]的所有to，更新方式是dis[to] = min(dis[to], dis[v]+cost)来更新
</code></pre></div><p>AC代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 50010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, bg, dis[maxn], vis[maxn], ta, tb, tc, tem, v;
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> edge{
    <span style="color:#66d9ef">int</span> to, cost;
};
vector<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span> gh[maxn];
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">2147483647</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> INF;
    dis[bg] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        tem <span style="color:#f92672">=</span> INF, v <span style="color:#f92672">=</span> bg;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[j] <span style="color:#f92672">&lt;</span> tem) tem <span style="color:#f92672">=</span> dis[v<span style="color:#f92672">=</span>j];
        vis[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> gh[v].size(); <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) {
            <span style="color:#66d9ef">int</span> tg <span style="color:#f92672">=</span> gh[v][j].to;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[tg] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[tg] <span style="color:#f92672">&gt;</span> dis[v]<span style="color:#f92672">+</span>gh[v][j].cost) dis[tg]<span style="color:#f92672">=</span>dis[v]<span style="color:#f92672">+</span>gh[v][j].cost;
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, dis[i]);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>bg);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        edge teme;
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>teme.to, <span style="color:#f92672">&amp;</span>teme.cost);
        gh[ta].push_back(teme);
    }
    dijkstra();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="dijkstra链式前向星结构体">Dijkstra+链式前向星【结构体】</h3>
<p>1、用链式前向星来存储图结构</p>
<p>2、跑裸的Dijkstra</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxpoint 100010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define maxedge 200010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define INF 2147483647</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, s, ta, tb, tc, dis[maxpoint], vis[maxpoint], v, tem<span style="color:#f92672">=</span>INF;
<span style="color:#66d9ef">struct</span> node {
    <span style="color:#66d9ef">int</span> to, next, cost;
}edge[maxedge]; <span style="color:#66d9ef">int</span> head[maxpoint], tot;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to, <span style="color:#66d9ef">int</span> cost) {
    edge[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to;
    edge[tot].next <span style="color:#f92672">=</span> head[from];
    edge[tot].cost <span style="color:#f92672">=</span> cost;
    head[from] <span style="color:#f92672">=</span> tot;
}

<span style="color:#75715e">/*
</span><span style="color:#75715e"> * 非堆优化
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> INF;
    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        tem <span style="color:#f92672">=</span> INF;v <span style="color:#f92672">=</span> s;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[j] <span style="color:#f92672">&lt;</span> tem) tem <span style="color:#f92672">=</span> dis[v<span style="color:#f92672">=</span>j];
        vis[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> head[v]; j; j<span style="color:#f92672">=</span>edge[j].next) {
            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edge[j].to;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[to] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[to] <span style="color:#f92672">&gt;</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost) dis[to] <span style="color:#f92672">=</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost;
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, dis[i]);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>s);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        addedge(ta, tb, tc);
    }
    dijkstra();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="dijkstra链式前向星多源最短路">Dijkstra+链式前向星+多源最短路</h3>
<p>在给dijkstra传参的时候把当前的源头给传进去，这样就可以进行不同源头的最短路计算了。</p>
<p><em>注意：多源最短路要进行多次的Dijkstra，所以在每次跑完了都要刷新vis/dis数组。</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxpoint 1005</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define maxedge 100010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define INF 2147483647</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, ta, tb, tc, dis[maxpoint], vis[maxpoint], v, tem<span style="color:#f92672">=</span>INF, ans;
<span style="color:#66d9ef">struct</span> node {
    <span style="color:#66d9ef">int</span> to, next, cost;
}edge[maxedge];<span style="color:#66d9ef">int</span> head[maxpoint], tot;
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define cl(a, b) memset(a, b, sizeof(a))</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to, <span style="color:#66d9ef">int</span> cost) {
    edge[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to;
    edge[tot].next <span style="color:#f92672">=</span> head[from];
    edge[tot].cost <span style="color:#f92672">=</span> cost;
    head[from] <span style="color:#f92672">=</span> tot;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> s) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> INF;
    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    vis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        v<span style="color:#f92672">=</span>s;tem<span style="color:#f92672">=</span>INF;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> tem <span style="color:#f92672">&gt;</span> dis[j]) tem <span style="color:#f92672">=</span> dis[v<span style="color:#f92672">=</span>j];
        vis[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> head[v]; j; j<span style="color:#f92672">=</span>edge[j].next) {
            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edge[j].to;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[to] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[to] <span style="color:#f92672">&gt;</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost) dis[to] <span style="color:#f92672">=</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost;
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        addedge(ta, tb, tc);
    }
    dijkstra(<span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dis[i];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        cl(vis, <span style="color:#ae81ff">0</span>);
        dijkstra(i);
        ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dis[<span style="color:#ae81ff">1</span>];
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="dijkstra链式前向星双向建图">Dijkstra+链式前向星+双向建图</h3>
<p>【双向建图限制于有向图，无向图就没有双向建图一说了】</p>
<p><a href="https://www.luogu.com.cn/problem/P1629">https://www.luogu.com.cn/problem/P1629</a></p>
<p>题目大意：从固定点去其他所有点，然后从所有去过的点返回。</p>
<p>1、反向建图：【类似于：并查集里边的反集=&gt;通过把范围增大到二倍来实现反集；】</p>
<ul>
<li>声明的数据结构规模扩大2倍，<code>edge[maxpoint&lt;&lt;1]</code> <code>head[maxponit&lt;&lt;1]</code> <code>dis[maxpoint&lt;&lt;1]</code></li>
<li>反向建图的时候，在1~n的数组范围内正向建图，在n+1~n&laquo;1范围内反向建图</li>
<li>在跑裸的dijkstra注意索引。正向是1～n，反向n+1~n&laquo;1</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * 正反方向两面建图
</span><span style="color:#75715e"> */</span>
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxpoint 1005</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define maxedge 100010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define INF 2147483647</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, ta, tb, tc, dis[maxpoint<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>], vis[maxpoint<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>], v, tem<span style="color:#f92672">=</span>INF, ans;
<span style="color:#66d9ef">struct</span> node {
    <span style="color:#66d9ef">int</span> to, next, cost;
}edge[maxedge<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>];<span style="color:#66d9ef">int</span> head[maxpoint<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>], tot;
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define cl(a, b) memset(a, b, sizeof(a))</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to, <span style="color:#66d9ef">int</span> cost) {
    edge[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to;
    edge[tot].next <span style="color:#f92672">=</span> head[from];
    edge[tot].cost <span style="color:#f92672">=</span> cost;
    head[from] <span style="color:#f92672">=</span> tot;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> s) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> INF;
    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    vis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        v<span style="color:#f92672">=</span>s;tem<span style="color:#f92672">=</span>INF;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> tem <span style="color:#f92672">&gt;</span> dis[j]) tem <span style="color:#f92672">=</span> dis[v<span style="color:#f92672">=</span>j];
        vis[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> head[v]; j; j<span style="color:#f92672">=</span>edge[j].next) {
            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edge[j].to;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[to] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[to] <span style="color:#f92672">&gt;</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost) dis[to] <span style="color:#f92672">=</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost;
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse_dijkstra</span>(<span style="color:#66d9ef">int</span> s) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> INF;
    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    vis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        v<span style="color:#f92672">=</span>s;tem<span style="color:#f92672">=</span>INF;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> tem <span style="color:#f92672">&gt;</span> dis[j]) tem <span style="color:#f92672">=</span> dis[v<span style="color:#f92672">=</span>j];
        vis[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> head[v]; j; j<span style="color:#f92672">=</span>edge[j].next) {
            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edge[j].to;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[to] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dis[to] <span style="color:#f92672">&gt;</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost) dis[to] <span style="color:#f92672">=</span> dis[v]<span style="color:#f92672">+</span>edge[j].cost;
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        addedge(ta, tb, tc);
        addedge(tb<span style="color:#f92672">+</span>n, ta<span style="color:#f92672">+</span>n, tc); <span style="color:#75715e">// 反向建图
</span><span style="color:#75715e"></span>    }
    dijkstra(<span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dis[i];
    cl(vis, <span style="color:#ae81ff">0</span>);
    reverse_dijkstra(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>n; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dis[i];
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="堆优化-结构体-dijkstra提高效率">堆优化-结构体-Dijkstra提高效率</h3>
<p>解决题目：数据增强的最短路，洛谷P4779</p>
<p><a href="https://www.luogu.com.cn/problem/P4779">https://www.luogu.com.cn/problem/P4779</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxpoint 100010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define maxedge 200010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define INF 2147483647</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, s, ta, tb, tc, dis[maxpoint], vis[maxpoint], v, tem<span style="color:#f92672">=</span>INF;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> to, next, cost;
}edge[maxedge]; <span style="color:#66d9ef">int</span> head[maxpoint], tot;
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">nd</span> {
    <span style="color:#66d9ef">int</span> dis, pos;
    nd(<span style="color:#66d9ef">int</span> dis, <span style="color:#66d9ef">int</span> pos)<span style="color:#f92672">:</span> dis(dis), pos(pos) {}
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> nd n) <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> dis <span style="color:#f92672">&gt;</span> n.dis;}
};
priority_queue<span style="color:#f92672">&lt;</span>nd<span style="color:#f92672">&gt;</span> pq;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to, <span style="color:#66d9ef">int</span> cost) {
    edge[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to;
    edge[tot].next <span style="color:#f92672">=</span> head[from];
    edge[tot].cost <span style="color:#f92672">=</span> cost;
    head[from] <span style="color:#f92672">=</span> tot;
}

<span style="color:#75715e">/*
</span><span style="color:#75715e"> * 堆优化
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> INF;
    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    pq.push(nd(<span style="color:#ae81ff">0</span>, s));
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty()) {
        nd nw <span style="color:#f92672">=</span> pq.top();pq.pop();
        <span style="color:#66d9ef">int</span> from <span style="color:#f92672">=</span> nw.pos;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[from]) {
            vis[from] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[from]; i; i<span style="color:#f92672">=</span>edge[i].next) {
                <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edge[i].to;
                <span style="color:#66d9ef">if</span> (dis[to] <span style="color:#f92672">&gt;</span> dis[from]<span style="color:#f92672">+</span>edge[i].cost) {
                    dis[to] <span style="color:#f92672">=</span> dis[from]<span style="color:#f92672">+</span>edge[i].cost;
                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[to]) pq.push(nd(dis[to], to));
                }
            }
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, dis[i]);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>s);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        addedge(ta, tb, tc);
    }
    dijkstra();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="堆优化-pair进行绑定-dijkstra提高效率">堆优化-pair进行绑定-Dijkstra提高效率</h3>
<ul>
<li>利用make_pair来进行优化结构体，不要写一个新的结构体，也不需要重载运算符，直接利用pair，pair+priority_queue默认按照第一个元素进行排序</li>
<li><strong>注意</strong>：在声明优先队列的时候要声明小顶堆<code>priority_queue&lt;pair&lt;ll, ll&gt;, vector&lt;pair&lt;ll, ll&gt;&gt;, greater&lt;pair&lt;ll, ll&gt;&gt;&gt; pq;</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>priority_queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span>ll, ll<span style="color:#f92672">&gt;</span>, vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span>ll, ll<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span>ll, ll<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> pq;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> s) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) d[i] <span style="color:#f92672">=</span> inf;
    d[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    pq.push(make_pair(<span style="color:#ae81ff">0</span>, s));
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty()) {
        ll nw <span style="color:#f92672">=</span> pq.top().second;pq.pop();
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[nw]) {
            vis[nw] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[nw]; i; i<span style="color:#f92672">=</span>edges[i].nt) {
                <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[i].to;
                <span style="color:#66d9ef">if</span> (d[to] <span style="color:#f92672">&gt;</span> d[nw]<span style="color:#f92672">+</span>edges[i].val) {
                    d[to] <span style="color:#f92672">=</span> d[nw]<span style="color:#f92672">+</span>edges[i].val;
                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[to]) pq.push(make_pair(d[to], to));
                }
            }
        }
    }
}
</code></pre></div><p>堆优化Dijkstra：</p>
<p><a href="https://www.luogu.com.cn/problem/P1339">https://www.luogu.com.cn/problem/P1339</a></p>
<p>核心模块：数据结构和非堆优化的一样，都是<code>dis[], tem, vis[], v</code>,只不过在堆优化运用priority_queue优化的过程中，需要首先push进一个两端为bg-bg且长度为0的一条边</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> bg, <span style="color:#66d9ef">int</span> ed) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dis[i] <span style="color:#f92672">=</span> inf;
    dis[bg] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    pq.push({bg, <span style="color:#ae81ff">0</span>});
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty()) {
        <span style="color:#66d9ef">int</span> nw <span style="color:#f92672">=</span> pq.top().idx;pq.pop();
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[nw]) {
            vis[nw] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[nw]; i; i<span style="color:#f92672">=</span>edges[i].next) {
                <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[i].to;
                <span style="color:#66d9ef">if</span> (dis[to] <span style="color:#f92672">&gt;</span> dis[nw]<span style="color:#f92672">+</span>edges[i].val) {
                    dis[to] <span style="color:#f92672">=</span> dis[nw]<span style="color:#f92672">+</span>edges[i].val;
                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[to]) pq.push({to, dis[to]});
                }
            }
        }
    }
    <span style="color:#66d9ef">return</span> dis[ed];
}
</code></pre></div><h3 id="spfa-负权--无负圈">SPFA 负权 &amp; 无负圈</h3>
<h3 id="bf-负权--检测负圈">BF 负权 &amp; 检测负圈</h3>
<h3 id="反向建图堆优化">反向建图、堆优化</h3>
<blockquote>
<p>给出若干个点，得到每个点到指定点的最短来回距离</p>
<ul>
<li>所有点到指定点的来路距离=》单终点最短路 =》反向建图</li>
<li>指定点往其他所有点的去的距离=》单源（头）最短路</li>
</ul>
</blockquote>
<p>注意：用堆优化的时候</p>
<ul>
<li>也是要两层的判断是否扫过了<code>!vis</code></li>
<li>初始化的时候也是要将d数组按照inf与0进行初始化。</li>
</ul>

		</section>

		<div class="meta">Posted on Feb 1, 2021</div>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/acm">ACM</a></li>
					
					<li><a href="/tags/%E7%AE%97%E6%B3%95">算法</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
	
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2023  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
