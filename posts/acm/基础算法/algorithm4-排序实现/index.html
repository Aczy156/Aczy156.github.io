<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Algorithm4 十种排序 - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Algorithm4 十种排序 | Aczy156" />
	<meta name="twitter:title" content="Algorithm4 十种排序 | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Algorithm4 十种排序 | Aczy156" />
	<meta name="application-name" content="Algorithm4 十种排序 | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Algorithm4 十种排序" />
<meta property="og:description" content="[TOC]
排序 排序时间复杂度中的 $log_x^n$ 中以x为底n的对数通常x是取2的。 详细计算：通过k-叉树的计算次数，可以得到，最底层想覆盖n个数，那么就要$k^{depth}=n$ 然后也就得到$depth=log_k^n$ 也就是要depth次搜索，才能从最上层搜到最下层，所以log的值是和k叉树是有关系的，如果k叉越大，那么搜到最底层的速度也就越快  暴力遍历：
 冒泡排序【稳定】：$O(n^2)$ 最大的往后冒泡，保证「每次提取最大」的，然后「放到最后」 选择排序【不稳定】：$O(n^2)$ 「拿到合适的然后放置」选择出最值以及最值的索引，然后进行交换。 插入排序三种：「拿到然后找合适的地方放置一个/多个」  直接插入【稳定】：$O(n^2)$ 对每次拿到的数，从一端到另一端暴力查找，找到合适的位置插入进去 折半插入【稳定】：$O(nlog_2^n)$ 在选择合适的位置的时候，会进行二分折半查找，找到合适位置插入进去 希尔插入【不稳定】：$O(n^{1.3})\sim O(n^2)$ 更复杂的插入排序过程，三大步，首先对半分，两半一对一匹配进行插入排序；然后对半分的两类内部分别进行插入，然后对整体进行插入排序。    递归 二分与合并：$O(n*log_2^n)$
 快速排序【不稳定】：首先移动，然后「合理的分割」 归并排序【稳定】：「分割」，然后「合理的合并」  递归 桶 多分与合并：
 计数排序：n个数n个桶，然后把n个桶再合并 桶排序：n个数k个桶，k个桶各自进行排序，然后再把k个桶合并 基数排序【稳定】：n个数10个桶，10个桶为首位/尾位的是个数字对应的数。  思路一：先合并，然后再根据首位/尾位的下面一位接着入桶 思路二：对每一个桶分别根据下一位再重新进小小桶，然后对小小桶进行合并，再对大桶进行合并    其他： $$ O(n*log_n2) $$
 锦标赛排序/堆排序【不稳定】：利用类似于堆/树的log2n的结构来提取最大/最小，然后放在首/尾。  利用最小堆：递增排序   利用最大堆：递减排序   归并排序 两个易错点：
1、递归完了回来将要排序的时候，两个范围注意，左边小于等于mid，右边小于等于r，然后右边的起点也是mid&#43;1。
2、******递归
快速排序 题目链接：https://www.luogu.com.cn/problem/P1177
1、所有排序算法的函数形式都是可以写成sort_algorithm(int[] arr, int l,int r){}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://chenranfei.site/posts/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/algorithm4-%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/" />
<meta property="article:published_time" content="2021-02-01T19:03:55+08:00" />
<meta property="article:modified_time" content="2021-02-01T19:03:55+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm4 十种排序"/>
<meta name="twitter:description" content="[TOC]
排序 排序时间复杂度中的 $log_x^n$ 中以x为底n的对数通常x是取2的。 详细计算：通过k-叉树的计算次数，可以得到，最底层想覆盖n个数，那么就要$k^{depth}=n$ 然后也就得到$depth=log_k^n$ 也就是要depth次搜索，才能从最上层搜到最下层，所以log的值是和k叉树是有关系的，如果k叉越大，那么搜到最底层的速度也就越快  暴力遍历：
 冒泡排序【稳定】：$O(n^2)$ 最大的往后冒泡，保证「每次提取最大」的，然后「放到最后」 选择排序【不稳定】：$O(n^2)$ 「拿到合适的然后放置」选择出最值以及最值的索引，然后进行交换。 插入排序三种：「拿到然后找合适的地方放置一个/多个」  直接插入【稳定】：$O(n^2)$ 对每次拿到的数，从一端到另一端暴力查找，找到合适的位置插入进去 折半插入【稳定】：$O(nlog_2^n)$ 在选择合适的位置的时候，会进行二分折半查找，找到合适位置插入进去 希尔插入【不稳定】：$O(n^{1.3})\sim O(n^2)$ 更复杂的插入排序过程，三大步，首先对半分，两半一对一匹配进行插入排序；然后对半分的两类内部分别进行插入，然后对整体进行插入排序。    递归 二分与合并：$O(n*log_2^n)$
 快速排序【不稳定】：首先移动，然后「合理的分割」 归并排序【稳定】：「分割」，然后「合理的合并」  递归 桶 多分与合并：
 计数排序：n个数n个桶，然后把n个桶再合并 桶排序：n个数k个桶，k个桶各自进行排序，然后再把k个桶合并 基数排序【稳定】：n个数10个桶，10个桶为首位/尾位的是个数字对应的数。  思路一：先合并，然后再根据首位/尾位的下面一位接着入桶 思路二：对每一个桶分别根据下一位再重新进小小桶，然后对小小桶进行合并，再对大桶进行合并    其他： $$ O(n*log_n2) $$
 锦标赛排序/堆排序【不稳定】：利用类似于堆/树的log2n的结构来提取最大/最小，然后放在首/尾。  利用最小堆：递增排序   利用最大堆：递减排序   归并排序 两个易错点：
1、递归完了回来将要排序的时候，两个范围注意，左边小于等于mid，右边小于等于r，然后右边的起点也是mid&#43;1。
2、******递归
快速排序 题目链接：https://www.luogu.com.cn/problem/P1177
1、所有排序算法的函数形式都是可以写成sort_algorithm(int[] arr, int l,int r){}"/>
<script src="http://chenranfei.site/js/feather.min.js"></script>
	
	<link href="http://chenranfei.site/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="http://chenranfei.site/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://chenranfei.site/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<aside>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#排序">排序</a>
      <ul>
        <li><a href="#归并排序">归并排序</a></li>
        <li><a href="#快速排序">快速排序</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
	<article>
		<div class="title">
			<h1 class="title">Algorithm4 十种排序</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="排序">排序</h2>
<p>排序时间复杂度中的 $log_x^n$ 中以x为底n的对数通常x是取2的。
详细计算：通过k-叉树的计算次数，可以得到，最底层想覆盖n个数，那么就要$k^{depth}=n$ 然后也就得到$depth=log_k^n$ 也就是要depth次搜索，才能从最上层搜到最下层，所以log的值是和k叉树是有关系的，如果k叉越大，那么搜到最底层的速度也就越快
<img src="https://i1.wp.com/i.stack.imgur.com/spHFh.png" alt="height of a binary tree" style="zoom:80%;" /></p>
<blockquote>
<p>暴力遍历：</p>
<ul>
<li>冒泡排序【稳定】：$O(n^2)$ 最大的往后冒泡，保证「每次提取最大」的，然后「放到最后」</li>
<li>选择排序【不稳定】：$O(n^2)$ 「拿到合适的然后放置」选择出最值以及最值的索引，然后进行交换。</li>
<li>插入排序三种：「拿到然后找合适的地方放置一个/多个」
<ul>
<li>直接插入【稳定】：$O(n^2)$ 对每次拿到的数，从一端到另一端暴力查找，找到合适的位置插入进去</li>
<li>折半插入【稳定】：$O(nlog_2^n)$ 在选择合适的位置的时候，会进行二分折半查找，找到合适位置插入进去</li>
<li>希尔插入【不稳定】：$O(n^{1.3})\sim O(n^2)$ 更复杂的插入排序过程，三大步，首先对半分，两半一对一匹配进行插入排序；然后对半分的两类内部分别进行插入，然后对整体进行插入排序。</li>
</ul>
</li>
</ul>
<p>递归 二分与合并：$O(n*log_2^n)$</p>
<ul>
<li>快速排序【不稳定】：首先移动，然后「合理的分割」</li>
<li>归并排序【稳定】：「分割」，然后「合理的合并」</li>
</ul>
<p>递归 桶 多分与合并：</p>
<ul>
<li>计数排序：n个数n个桶，然后把n个桶再合并</li>
<li>桶排序：n个数k个桶，k个桶各自进行排序，然后再把k个桶合并</li>
<li>基数排序【稳定】：n个数10个桶，10个桶为首位/尾位的是个数字对应的数。
<ul>
<li>思路一：先合并，然后再根据首位/尾位的下面一位接着入桶</li>
<li>思路二：对每一个桶分别根据下一位再重新进小小桶，然后对小小桶进行合并，再对大桶进行合并</li>
</ul>
</li>
</ul>
<p>其他：
$$
O(n*log_n2)
$$</p>
<ul>
<li>锦标赛排序/堆排序【不稳定】：利用类似于堆/树的log2n的结构来提取最大/最小，然后放在首/尾。
<ul>
<li>利用最小堆：递增排序</li>
</ul>
</li>
<li>利用最大堆：递减排序</li>
</ul>
</blockquote>
<h3 id="归并排序">归并排序</h3>
<p>两个易错点：</p>
<p>1、递归完了回来将要排序的时候，两个范围注意，左边小于等于mid，右边小于等于r，然后右边的起点也是mid+1。</p>
<p>2、******递归</p>
<h3 id="快速排序">快速排序</h3>
<p>题目链接：https://www.luogu.com.cn/problem/P1177</p>
<p>1、所有排序算法的函数形式都是可以写成<code>sort_algorithm(int[] arr, int l,int r){}</code></p>
<p>2、<del>找分块的标准数的部分</del>快排的核心思想就是<strong>找一个数，来作为分块标准</strong>，而<strong>不是找一个分割的数的索引</strong>，因为索引的话，会随着<code>swap()</code>变换而导致本来已经确定的数变化。</p>
<p>3、<del>分块的部分</del>，可以通过前后遍历，碰到一对分别小于、大于的，直接<code>swap()</code>掉即可。但是会引发一个问题，就是如果碰到了一边刚好完全都是符合那个标准的，然后另一边存在不符合标准的，此时就需要把标准和不符合标准的换位置了。</p>
<p>4、<del>递归的部分</del>，<strong>边界的设定问题</strong>，存在有刚好极端情况也就是分块的标准数刚好是最大或者最小的，那就不用再递归他了。所以要判断<code>l &lt; j</code>或者<code>i &lt; r</code>也就是排除了最大最小两种极端情况，其他的次大次小=&gt;都要老老实实的把长度为2的给往下递归</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quicksort</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){
    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> a[(l<span style="color:#f92672">+</span>r)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>], i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> r;
    <span style="color:#66d9ef">do</span>{
        <span style="color:#66d9ef">while</span> (a[i] <span style="color:#f92672">&lt;</span> mid) i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">while</span> (a[j] <span style="color:#f92672">&gt;</span> mid) j<span style="color:#f92672">-</span><span style="color:#f92672">-</span>;
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> j) {swap(a[i], a[j]);i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;j<span style="color:#f92672">-</span><span style="color:#f92672">-</span>;}
    }<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> j);
    <span style="color:#75715e">// recursion left and right
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">&lt;</span> j) quicksort(l, j);
    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> r) quicksort(i, r);
}
</code></pre></div>
		</section>

		<div class="meta">Posted on Feb 1, 2021</div>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/acm">ACM</a></li>
					
					<li><a href="/tags/%E7%AE%97%E6%B3%95">算法</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
	
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2022  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
