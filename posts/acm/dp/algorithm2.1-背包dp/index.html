<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Algorithm2.1 背包dp - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Algorithm2.1 背包dp | Aczy156" />
	<meta name="twitter:title" content="Algorithm2.1 背包dp | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Algorithm2.1 背包dp | Aczy156" />
	<meta name="application-name" content="Algorithm2.1 背包dp | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Algorithm2.1 背包dp" />
<meta property="og:description" content="[TOC]
背包dp 背包问题总结   01背包：每种物品仅一个
 最大化所有物品的总价值：基础01背包 组成当前容量的物品组合数：装配组合问题、路径问题    完全背包：每种物品有无限个
  多重背包：每种物品有具体个数
  分组背包：每种物品仅一个，且不同物品有自己所属的组别
  多维代价背包：每种物品不仅占用空间，而且占用金钱
  多维目的背包：每种物品不仅具有价值1，而且具有价值2
  01背包 固定容量 最大价值 题目一
https://www.luogu.com.cn/problem/P1048
题目大意：给定背包容量，将价值总和最大化。
思路：dp[j]表示容量为j的最大价值。将当前dp[0]~dp[j]这j个容量/状态/问题，通过第i个商品转移到dp[-w[i]]~dp[j-w[i]]，n个商品就有n次刷新j个状态的过程。
#include &lt;iostream&gt;using namespace std; #define maxn 1005int t, m, val[maxn], c[maxn], dp[maxn]; // dp[j]代表在容量为j的最大价值  int main() { scanf(&#34;%d%d&#34;, &amp;t, &amp;m); for (int i = 0; i &lt; m; &#43;&#43;i) scanf(&#34;%d%d&#34;, &amp;c[i], &amp;val[i]); for (int i = 0; i &lt; m; &#43;&#43;i) for (int j = t; j &gt;= c[i] ; --j) dp[j] = max(dp[j], dp[j-c[i]]&#43;val[i]); printf(&#34;%d\n&#34;, dp[t]); return 0; } 题目二" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://chenranfei.xyz/posts/acm/dp/algorithm2.1-%E8%83%8C%E5%8C%85dp/" />
<meta property="article:published_time" content="2021-02-01T19:03:55+08:00" />
<meta property="article:modified_time" content="2021-02-01T19:03:55+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm2.1 背包dp"/>
<meta name="twitter:description" content="[TOC]
背包dp 背包问题总结   01背包：每种物品仅一个
 最大化所有物品的总价值：基础01背包 组成当前容量的物品组合数：装配组合问题、路径问题    完全背包：每种物品有无限个
  多重背包：每种物品有具体个数
  分组背包：每种物品仅一个，且不同物品有自己所属的组别
  多维代价背包：每种物品不仅占用空间，而且占用金钱
  多维目的背包：每种物品不仅具有价值1，而且具有价值2
  01背包 固定容量 最大价值 题目一
https://www.luogu.com.cn/problem/P1048
题目大意：给定背包容量，将价值总和最大化。
思路：dp[j]表示容量为j的最大价值。将当前dp[0]~dp[j]这j个容量/状态/问题，通过第i个商品转移到dp[-w[i]]~dp[j-w[i]]，n个商品就有n次刷新j个状态的过程。
#include &lt;iostream&gt;using namespace std; #define maxn 1005int t, m, val[maxn], c[maxn], dp[maxn]; // dp[j]代表在容量为j的最大价值  int main() { scanf(&#34;%d%d&#34;, &amp;t, &amp;m); for (int i = 0; i &lt; m; &#43;&#43;i) scanf(&#34;%d%d&#34;, &amp;c[i], &amp;val[i]); for (int i = 0; i &lt; m; &#43;&#43;i) for (int j = t; j &gt;= c[i] ; --j) dp[j] = max(dp[j], dp[j-c[i]]&#43;val[i]); printf(&#34;%d\n&#34;, dp[t]); return 0; } 题目二"/>
<script src="http://chenranfei.xyz/js/feather.min.js"></script>
	
	<link href="http://chenranfei.xyz/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="http://chenranfei.xyz/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://chenranfei.xyz/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<aside>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#背包dp">背包dp</a>
      <ul>
        <li><a href="#背包问题总结">背包问题总结</a></li>
        <li><a href="#01背包">01背包</a></li>
        <li><a href="#多重背包">多重背包</a></li>
        <li><a href="#01背包--完全背包--多重背包混合">01背包 & 完全背包 & 多重背包混合</a></li>
        <li><a href="#组合背包">组合背包</a></li>
        <li><a href="#多维代价--多维目的----背包">多维代价 // 多维目的 &ndash; 背包</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
	<article>
		<div class="title">
			<h1 class="title">Algorithm2.1 背包dp</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="背包dp">背包dp</h2>
<h3 id="背包问题总结">背包问题总结</h3>
<ul>
<li>
<p>01背包：每种物品仅一个</p>
<ul>
<li>最大化所有物品的总价值：基础01背包</li>
<li>组成当前容量的物品组合数：装配组合问题、路径问题</li>
</ul>
</li>
<li>
<p>完全背包：每种物品有无限个</p>
</li>
<li>
<p>多重背包：每种物品有具体个数</p>
</li>
<li>
<p>分组背包：每种物品仅一个，且不同物品有自己所属的组别</p>
</li>
<li>
<p>多维代价背包：每种物品不仅占用空间，而且占用金钱</p>
</li>
<li>
<p>多维目的背包：每种物品不仅具有价值1，而且具有价值2</p>
</li>
</ul>
<h3 id="01背包">01背包</h3>
<h4 id="固定容量-最大价值">固定容量 最大价值</h4>
<p><strong>题目一</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P1048">https://www.luogu.com.cn/problem/P1048</a></p>
<p>题目大意：给定背包容量，将价值总和最大化。</p>
<p>思路：<code>dp[j]</code>表示容量为j的最大价值。将当前<code>dp[0]~dp[j]</code>这j个容量/状态/问题，通过第i个商品转移到<code>dp[-w[i]]~dp[j-w[i]]</code>，n个商品就有n次刷新j个状态的过程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 1005</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> t, m, val[maxn], c[maxn], dp[maxn]; <span style="color:#75715e">// dp[j]代表在容量为j的最大价值
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>t, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>c[i], <span style="color:#f92672">&amp;</span>val[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> t; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i] ; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[t]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><strong>题目二</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P1802">https://www.luogu.com.cn/problem/P1802</a></p>
<p>题目大意：给定容量和经验，其中付出固定容量得到胜利的经验，不付出（或者付出部分）容量都得到失败的经验。使最终经验最大化。</p>
<p>思路：首先优化题目，失败的情况下，无论如何都不付出任何容量。转化为最基础的01背包。用<code>dp[j]</code>表示容量为j的最大经验。将当前<code>dp[0]~dp[j]</code>这j个容量/状态/问题，通过第i个商品转移到<code>dp[-w[i]]~dp[j-w[i]]</code>。单独拿出一个状态<code>dp[j]</code>，在转换的时候用第i个商品，要么用容量去买，得到胜利的经验；要么直接不用，容量没损耗，经验加上失败的经验。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 1005</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, x, l[maxn], w[maxn], c[maxn], dp[maxn]; <span style="color:#75715e">// dp[j]表示在药水瓶数为j时所获得的最大经验
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>x);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">&amp;</span>l[i], <span style="color:#f92672">&amp;</span>w[i], <span style="color:#f92672">&amp;</span>c[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> x; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>w[i], dp[j]<span style="color:#f92672">+</span>l[i]);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[x]<span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><strong>01背包内圈遍历方向问题</strong></p>
<p>关键：<code>dp[0]</code>和<code>dp[m]</code>的赋值是否为1的问题。</p>
<p>理解：从大容量往小容量遍历，因为最后一位<code>dp[m]</code>没有被赋值为1，那么就没办法往前累加，每隔当前第i个商品的容量就要累加一次。反之从小往大遍历，第一位<code>dp[0]</code>是1，那么就会像滚雪球往后累计，每攒够第i个商品的容量，就要累加上一次。</p>
<h4 id="装配组合路径问题">装配组合//路径问题</h4>
<p><strong>题目一</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P1164">https://www.luogu.com.cn/problem/P1164</a></p>
<p>题目大意：给定若干数，数值相同的数在组合中视作不同。问最大组合数（仅限加法的组合）。</p>
<p>思路：<code>dp[j]</code>表示组合成j时候的组合数。用第i个数来更改容量/状态为<code>dp[0]~dp[j]</code>的这些状态，通过<code>dp[-w[i]]~dp[j-w[i]]</code>进行转移。也就是这些状态之前的组合结果。将n个数，每次更改完的<code>dp[j]</code>都累加功效。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 102</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define maxm 10010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, a[maxn], dp[maxm]; <span style="color:#75715e">// dp[i]表示容量为i的到达种类
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);
    <span style="color:#75715e">// init
</span><span style="color:#75715e"></span>    dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> a[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dp[j<span style="color:#f92672">-</span>a[i]];
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[m]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><strong>题目二</strong></p>
<p>题目大意：和题目一区别在于，组合不仅可以加进去，也可以通过减法一块运算进去。</p>
<p>思路：将题目进行转换，就得到了纯加法进行组合的结果。</p>
<h4 id="能否填充--dp属性挑选与选取">能否填充 // dp属性挑选与选取</h4>
<p><a href="https://www.luogu.com.cn/problem/P1510">https://www.luogu.com.cn/problem/P1510</a></p>
<p>题目大意：</p>
<p>1、如果dp属性选择到<strong>最大总容积</strong>上，dp[i]表示在容积为i时所需要的最小代价，再去比较代价 =&gt; 容积太大，不合适</p>
<p>2、如果dp属性选择到<strong>最大总代价</strong>上，dp[i]表示在代价为i时所呈现的最大容积，再去比较容积 =&gt; 合适</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 10005</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> vtotal, n, ctotal, val[maxn], c[maxn], dp[maxn]; <span style="color:#75715e">// dp[i]表示在总代价为i时所获得的最大体积
</span><span style="color:#75715e"></span><span style="color:#75715e">// 初始化：
</span><span style="color:#75715e"></span><span style="color:#75715e">// 状态转移方程：dp[j] = max(dp[j], dp[j-c[i]]+val[i]);
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>vtotal, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>ctotal);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>val[i], <span style="color:#f92672">&amp;</span>c[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> ctotal; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
    <span style="color:#66d9ef">if</span> (dp[ctotal] <span style="color:#f92672">&lt;</span> vtotal) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Impossible</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">else</span>{
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ctotal; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
            <span style="color:#66d9ef">if</span> (dp[ctotal<span style="color:#f92672">-</span>i] <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> vtotal) <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">else</span> {printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#66d9ef">break</span>;}
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="最小剩余容量--最大填充">最小剩余容量 // 最大填充</h4>
<p><a href="https://www.luogu.com.cn/problem/P1049">https://www.luogu.com.cn/problem/P1049</a></p>
<p>题目大意：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 32</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ct, n, c[maxn], dp[maxn]; <span style="color:#75715e">// dp[j]表示容量为j时所能凑出的最大容量。最后输出dp[j]即可
</span><span style="color:#75715e"></span><span style="color:#75715e">// 初始化：
</span><span style="color:#75715e"></span><span style="color:#75715e">// 状态转移方程：dp[j] = max(dp[j], dp[j-c[i]]+c[i]); // 根据能不能放进去，而获得的最大体积
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ct, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>c[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> ct; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>c[i]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ct<span style="color:#f92672">-</span>dp[ct]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="多重背包">多重背包</h3>
<h4 id="模版">模版</h4>
<p>1、内核还是可以看成是乘倍数的01背包，所以中间遍历容量的时候要反向遍历，也就是从max_m往c[i]去刷新dp值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> w; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> num[i] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> k<span style="color:#f92672">*</span>c[i]<span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span>j; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>c[i]]<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>val[i]);
</code></pre></div><h4 id="二进制优化">二进制优化</h4>
<p><a href="https://www.luogu.com.cn/problem/P1776">https://www.luogu.com.cn/problem/P1776</a></p>
<p>思路：通过二进制来将k这个可能的值用二进制给分解开，数据的两增加到了原来的logn倍，从原来的n^3的遍历缩减成了n^2的遍历加上logn的数据规模扩大。所以最后总的时间复杂度为n^2*logn</p>
<p>【二进制优化的思路很像快速幂，通过任何整数都可以通过2^0，2^1……的时候选取来拟合出来，2的多少次方，相乘也就是上面的指数2的0，2的1这样往后相加，所以也就优化成了最后的logn的复杂度凑出】</p>
<p>1、将原来的多重背包val，c，num拍平，成为一个二维的val，c。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> tc; j<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) {
        c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tb<span style="color:#f92672">*</span>j; val[idx] <span style="color:#f92672">=</span> ta<span style="color:#f92672">*</span>j;
        tc<span style="color:#f92672">-</span><span style="color:#f92672">=</span>j;
    }
    <span style="color:#66d9ef">if</span> (tc) {c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tb<span style="color:#f92672">*</span>tc;val[idx] <span style="color:#f92672">=</span> ta<span style="color:#f92672">*</span>tc;}
}
</code></pre></div><p>2、将多重背包拍成了01背包之后，直接进行01背包的模版</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> idx; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
        dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
</code></pre></div><p>完整AC代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 1000100</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m ,ta, tb ,tc, c[maxn], val[maxn], idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dp[maxn];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> tc; j<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) {
            c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tb<span style="color:#f92672">*</span>j; val[idx] <span style="color:#f92672">=</span> ta<span style="color:#f92672">*</span>j;
            tc<span style="color:#f92672">-</span><span style="color:#f92672">=</span>j;
        }
        <span style="color:#66d9ef">if</span> (tc) {c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tb<span style="color:#f92672">*</span>tc;val[idx] <span style="color:#f92672">=</span> ta<span style="color:#f92672">*</span>tc;}
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> idx; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[m]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="单调队列优化">单调队列优化</h4>
<p>？？？ waiting</p>
<h3 id="01背包--完全背包--多重背包混合">01背包 &amp; 完全背包 &amp; 多重背包混合</h3>
<p><a href="https://www.luogu.com.cn/problem/P1833">https://www.luogu.com.cn/problem/P1833</a></p>
<p>1、思路1:在遍历的时候，遍历到哪种种类背包就进行哪种遍历 =&gt; 完全背包直接完全遍历，01背包和多重背包直接用多重背包去解。（误</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[i])
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> c[i]; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> num[i] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> k<span style="color:#f92672">*</span>c[i]; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
                    dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>c[i]]<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>val[i]);
</code></pre></div><p>2、思路2:直接利用<strong>二进制优化</strong>，把完全背包和多重背包拍成01背包，原理就是通过完全背包看成一个无穷大的，例如99999等。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tc) tc <span style="color:#f92672">=</span> <span style="color:#ae81ff">9999999</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> tc; j<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) {
        c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> j<span style="color:#f92672">*</span>ta; val[idx] <span style="color:#f92672">=</span> j<span style="color:#f92672">*</span>tb;
        tc <span style="color:#f92672">-</span><span style="color:#f92672">=</span> j;
    }
    <span style="color:#66d9ef">if</span> (tc) {c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tc<span style="color:#f92672">*</span>ta; val[idx] <span style="color:#f92672">=</span> tc<span style="color:#f92672">*</span>tb;}
}
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> idx; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
        dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
</code></pre></div><p>完整AC代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 1000100</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> bgh, bgm, edh, edm, m, n, ta, tb, tc, val[maxn], c[maxn], idx, dp[maxn];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d:%d %d:%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>bgh, <span style="color:#f92672">&amp;</span>bgm, <span style="color:#f92672">&amp;</span>edh, <span style="color:#f92672">&amp;</span>edm);
    <span style="color:#66d9ef">if</span> (bgm <span style="color:#f92672">&gt;</span> edm) {edm <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">60</span>; edh<span style="color:#f92672">-</span><span style="color:#f92672">-</span>;}
    m <span style="color:#f92672">=</span> (edh<span style="color:#f92672">-</span>bgh)<span style="color:#f92672">*</span><span style="color:#ae81ff">60</span><span style="color:#f92672">+</span>(edm<span style="color:#f92672">-</span>bgm);
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tc) tc <span style="color:#f92672">=</span> <span style="color:#ae81ff">9999999</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> tc; j<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) {
            c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> j<span style="color:#f92672">*</span>ta; val[idx] <span style="color:#f92672">=</span> j<span style="color:#f92672">*</span>tb;
            tc <span style="color:#f92672">-</span><span style="color:#f92672">=</span> j;
        }
        <span style="color:#66d9ef">if</span> (tc) {c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tc<span style="color:#f92672">*</span>ta; val[idx] <span style="color:#f92672">=</span> tc<span style="color:#f92672">*</span>tb;}
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> idx; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[m]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><a href="https://www.luogu.com.cn/problem/P2623">https://www.luogu.com.cn/problem/P2623</a></p>
<blockquote>
<ul>
<li>01背包（价值由体积的函数值决定的背包）</li>
<li>完全背包</li>
<li>多重背包混合</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">2e3</span><span style="color:#f92672">+</span><span style="color:#ae81ff">9</span>;
<span style="color:#66d9ef">int</span> n, m, dp[maxn], tp[maxn], val[maxn], c[maxn], num[maxn];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, tp<span style="color:#f92672">+</span>i);
        <span style="color:#66d9ef">if</span> (tp[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, val<span style="color:#f92672">+</span>i, c<span style="color:#f92672">+</span>i, num<span style="color:#f92672">+</span>i);
        <span style="color:#66d9ef">else</span> scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, val<span style="color:#f92672">+</span>i, c<span style="color:#f92672">+</span>i);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        <span style="color:#66d9ef">if</span> (tp[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j) dp[j] <span style="color:#f92672">=</span> max(dp[j], val[i]<span style="color:#f92672">*</span>j<span style="color:#f92672">*</span>j<span style="color:#f92672">-</span>c[i]<span style="color:#f92672">*</span>j);
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (tp[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> num[i] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> k<span style="color:#f92672">*</span>c[i] <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> j; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
                    dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>c[i]]<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>val[i]);
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> c[i]; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
        }
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[m]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="组合背包">组合背包</h3>
<p><a href="https://www.luogu.com.cn/problem/P1757">https://www.luogu.com.cn/problem/P1757</a></p>
<blockquote>
<p>题目大意：就是普通01背包，但是给每个物品都添加了自己所属的组别。</p>
</blockquote>
<p>1、此时遍历所有物品的话，就要按照组别-&gt;每个组别所包含的物品来遍历。</p>
<p>2、组别的目的就是加约束，每一组最多多少个，限制一个的话，可以通过把最内层遍历为该组别的遍历，中间设置为容量的遍历</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">for 所有组别
	for 容量从最大到0
		for 该组别中的所有物品
			if 当前容量大于该物品的容量
</code></pre></div><p>AC代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1010</span>;
<span style="color:#66d9ef">int</span> dp[maxn], c[maxn], v[maxn], grp[maxn][maxn], cnt[maxn]; <span style="color:#75715e">// grp[i][j]表示第i组，第j个商品在总的索引里边的位次
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ctotal, n, tc, tval, tgrp, grpmax;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ctotal, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, c<span style="color:#f92672">+</span>i, v<span style="color:#f92672">+</span>i, <span style="color:#f92672">&amp;</span>tgrp);
        grpmax <span style="color:#f92672">=</span> max(grpmax, tgrp);
        cnt[tgrp]<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        grp[tgrp][cnt[tgrp]] <span style="color:#f92672">=</span> i;
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> grpmax; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> ctotal; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> cnt[i]; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
                <span style="color:#66d9ef">if</span> (j<span style="color:#f92672">-</span>c[grp[i][k]]<span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[grp[i][k]]]<span style="color:#f92672">+</span>v[grp[i][k]]);
            printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[ctotal]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h3 id="多维代价--多维目的----背包">多维代价 // 多维目的 &ndash; 背包</h3>
<h4 id="二维代价一个目的">二维代价，一个目的</h4>
<p><a href="https://www.luogu.com.cn/problem/P1855">https://www.luogu.com.cn/problem/P1855</a></p>
<blockquote>
<p>多（2）维代价，所以各自的dp数组都是2个维度</p>
<p>一个目的，所以只需要开一个dp数组来作为目的</p>
</blockquote>
<p>1、dp[]数组遍历的就是代价元素，所以有几个代价，就增加几个维度，二维就是<code>dp[代价1][代价2]</code>，三维就是<code>dp[代价1][代价2][代价3]</code></p>
<p>2、本题<code>dp[i][j]</code>表示在代价1为i，代价2位j的时候，所获的的最大的数量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 205</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, t, c_m[maxn], c_t[maxn], dp[maxn][maxn];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>t);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>c_m[i], <span style="color:#f92672">&amp;</span>c_t[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c_m[i] ; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> t; k <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c_t[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>k)
                dp[j][k] <span style="color:#f92672">=</span> max(dp[j][k], dp[j<span style="color:#f92672">-</span>c_m[i]][k<span style="color:#f92672">-</span>c_t[i]]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
            printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[m][t]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><a href="https://www.luogu.com.cn/problem/P1507">https://www.luogu.com.cn/problem/P1507</a></p>
<p>同上，只不过通过添加了val来求最大值，而上面只是最大数量，val默认是1.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>v, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>n);
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>c_v[i], <span style="color:#f92672">&amp;</span>c_m[i], <span style="color:#f92672">&amp;</span>val[i]);
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> v; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c_v[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> m; k <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c_m[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>k)
            dp[j][k] <span style="color:#f92672">=</span> max(dp[j][k], dp[j<span style="color:#f92672">-</span>c_v[i]][k<span style="color:#f92672">-</span>c_m[i]]<span style="color:#f92672">+</span>val[i]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[v][m]);
</code></pre></div><h4 id="二维代价两个目的">二维代价，两个目的</h4>
<p><a href="https://www.luogu.com.cn/problem/P1509">https://www.luogu.com.cn/problem/P1509</a></p>
<blockquote>
<p>多（2）维代价，所以各自的dp数组都是2个维度</p>
<p>两个目的，要开两个dp数组来作为目的</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
<span style="color:#66d9ef">int</span> n, rmb[maxn], rp[maxn], tim[maxn], totalRmb, totalRp; <span style="color:#75715e">// 两个代价
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dpNum[maxn][maxn], dpTime[maxn][maxn]; <span style="color:#75715e">// 两个目的
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, rmb<span style="color:#f92672">+</span>i, rp<span style="color:#f92672">+</span>i, tim<span style="color:#f92672">+</span>i);
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>totalRmb, <span style="color:#f92672">&amp;</span>totalRp);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> totalRmb; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> rmb[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> totalRp; k <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> rp[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>k)
                <span style="color:#66d9ef">if</span> (dpNum[j][k] <span style="color:#f92672">&lt;</span> dpNum[j<span style="color:#f92672">-</span>rmb[i]][k<span style="color:#f92672">-</span>rp[i]]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) {
                    dpNum[j][k] <span style="color:#f92672">=</span> dpNum[j<span style="color:#f92672">-</span>rmb[i]][k<span style="color:#f92672">-</span>rp[i]]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
                    dpTime[j][k] <span style="color:#f92672">=</span> dpTime[j<span style="color:#f92672">-</span>rmb[i]][k<span style="color:#f92672">-</span>rp[i]]<span style="color:#f92672">+</span>tim[i];
                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (dpNum[j][k] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> dpNum[j<span style="color:#f92672">-</span>rmb[i]][k<span style="color:#f92672">-</span>rp[i]]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
                    dpTime[j][k] <span style="color:#f92672">=</span> min(dpTime[j][k], dpTime[j<span style="color:#f92672">-</span>rmb[i]][k<span style="color:#f92672">-</span>rp[i]]<span style="color:#f92672">+</span>tim[i]);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dpTime[totalRmb][totalRp]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
		</section>

		<div class="meta">Posted on Feb 1, 2021</div>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/acm">ACM</a></li>
					
					<li><a href="/tags/%E7%AE%97%E6%B3%95">算法</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
	
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2023  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
