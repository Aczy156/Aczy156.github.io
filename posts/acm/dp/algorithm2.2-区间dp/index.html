<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Algorithm2.2 区间dp - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Algorithm2.2 区间dp | Aczy156" />
	<meta name="twitter:title" content="Algorithm2.2 区间dp | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Algorithm2.2 区间dp | Aczy156" />
	<meta name="application-name" content="Algorithm2.2 区间dp | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Algorithm2.2 区间dp" />
<meta property="og:description" content="[TOC]
区间dp 区间基本提取 https://www.luogu.com.cn/problem/P2426
题目大意：删除一段数组的数，代价为这个区间的左右端点值的差的绝对值*长度，求全部删去的最大代价。
区间DP的水题，维护一个dp二维数组，然后三层遍历左右端点&#43;中间割点，利用状态转移方程dp[i][j] = max(dp[i][j], dp[i][k]&#43;dp[k&#43;1][j])即可。
注意：要上来初始化一下，初始化的值就是运算法则算出来的，而dp所做的就是排列组合来搜索组合。
#include &lt;iostream&gt;using namespace std; const int maxn = 105; int n, a[maxn], dp[maxn][maxn]; // dp[i][j] 表示区间[i, j]所获得的最大价值 // dp[i][j] = max(dp[i][j], dp[i][k]&#43;dp[k&#43;1][j]);  int main() { scanf(&#34;%d&#34;, &amp;n); for (int i = 1; i &lt;= n; &#43;&#43;i) scanf(&#34;%d&#34;, a&#43;i); for (int i = 1; i &lt;= n; &#43;&#43;i) for (int l = 0; l&#43;i &lt;= n; &#43;&#43;l) if (l == 0) dp[i][i&#43;l] = a[i]; else dp[i][i&#43;l] = abs(a[i]-a[i&#43;l])*(l&#43;1); for (int i = 1; i &lt;= n; &#43;&#43;i) for (int j = i&#43;1; j &lt;= n; &#43;&#43;j) for (int k = i; k &lt;= j; &#43;&#43;k) dp[i][j] = max(dp[i][j], dp[i][k]&#43;dp[k&#43;1][j]); printf(&#34;%d\n&#34;, dp[1][n]); return 0; } 石子合并（线型） 石子合并（环形） https://www." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.chenranfei.online/posts/acm/dp/algorithm2.2-%E5%8C%BA%E9%97%B4dp/" />
<meta property="article:published_time" content="2021-02-01T19:03:55+08:00" />
<meta property="article:modified_time" content="2021-02-01T19:03:55+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm2.2 区间dp"/>
<meta name="twitter:description" content="[TOC]
区间dp 区间基本提取 https://www.luogu.com.cn/problem/P2426
题目大意：删除一段数组的数，代价为这个区间的左右端点值的差的绝对值*长度，求全部删去的最大代价。
区间DP的水题，维护一个dp二维数组，然后三层遍历左右端点&#43;中间割点，利用状态转移方程dp[i][j] = max(dp[i][j], dp[i][k]&#43;dp[k&#43;1][j])即可。
注意：要上来初始化一下，初始化的值就是运算法则算出来的，而dp所做的就是排列组合来搜索组合。
#include &lt;iostream&gt;using namespace std; const int maxn = 105; int n, a[maxn], dp[maxn][maxn]; // dp[i][j] 表示区间[i, j]所获得的最大价值 // dp[i][j] = max(dp[i][j], dp[i][k]&#43;dp[k&#43;1][j]);  int main() { scanf(&#34;%d&#34;, &amp;n); for (int i = 1; i &lt;= n; &#43;&#43;i) scanf(&#34;%d&#34;, a&#43;i); for (int i = 1; i &lt;= n; &#43;&#43;i) for (int l = 0; l&#43;i &lt;= n; &#43;&#43;l) if (l == 0) dp[i][i&#43;l] = a[i]; else dp[i][i&#43;l] = abs(a[i]-a[i&#43;l])*(l&#43;1); for (int i = 1; i &lt;= n; &#43;&#43;i) for (int j = i&#43;1; j &lt;= n; &#43;&#43;j) for (int k = i; k &lt;= j; &#43;&#43;k) dp[i][j] = max(dp[i][j], dp[i][k]&#43;dp[k&#43;1][j]); printf(&#34;%d\n&#34;, dp[1][n]); return 0; } 石子合并（线型） 石子合并（环形） https://www."/>
<script src="http://www.chenranfei.online/js/feather.min.js"></script>
	
	<link href="http://www.chenranfei.online/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="http://www.chenranfei.online/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://www.chenranfei.online/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<aside>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#区间dp">区间dp</a>
      <ul>
        <li><a href="#区间基本提取">区间基本提取</a></li>
        <li><a href="#石子合并线型">石子合并（线型）</a></li>
        <li><a href="#石子合并环形">石子合并（环形）</a></li>
        <li><a href="#能量项链环形">能量项链（环形）</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
	<article>
		<div class="title">
			<h1 class="title">Algorithm2.2 区间dp</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="区间dp">区间dp</h2>
<h3 id="区间基本提取">区间基本提取</h3>
<p><a href="https://www.luogu.com.cn/problem/P2426">https://www.luogu.com.cn/problem/P2426</a></p>
<p>题目大意：删除一段数组的数，代价为这个区间的左右端点值的差的绝对值*长度，求全部删去的最大代价。</p>
<p>区间DP的水题，维护一个dp二维数组，然后三层遍历左右端点+中间割点，利用状态转移方程<code>dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])</code>即可。</p>
<p>注意：要上来初始化一下，初始化的值就是运算法则算出来的，而dp所做的就是排列组合来搜索组合。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
<span style="color:#66d9ef">int</span> n, a[maxn], dp[maxn][maxn]; <span style="color:#75715e">// dp[i][j] 表示区间[i, j]所获得的最大价值
</span><span style="color:#75715e"></span><span style="color:#75715e">// dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]);
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; l<span style="color:#f92672">+</span>i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>l)
            <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) dp[i][i<span style="color:#f92672">+</span>l] <span style="color:#f92672">=</span> a[i];
            <span style="color:#66d9ef">else</span> dp[i][i<span style="color:#f92672">+</span>l] <span style="color:#f92672">=</span> abs(a[i]<span style="color:#f92672">-</span>a[i<span style="color:#f92672">+</span>l])<span style="color:#f92672">*</span>(l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> j; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
                dp[i][j] <span style="color:#f92672">=</span> max(dp[i][j], dp[i][k]<span style="color:#f92672">+</span>dp[k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[<span style="color:#ae81ff">1</span>][n]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="石子合并线型">石子合并（线型）</h3>
<h3 id="石子合并环形">石子合并（环形）</h3>
<p><a href="https://www.luogu.com.cn/problem/P1880">https://www.luogu.com.cn/problem/P1880</a></p>
<p>题目大意：环形的一圈石子，合并相邻的两个，得到最大的和最小的合并代价。</p>
<p>1、不可以用贪心，因为贪心出来的话，不能确定选取的那最小的两个是相邻的，因为题目要求只能合并最小的两个</p>
<p>2、把环形拆解成链状，也就是转换成了第一个问题，线性的问题。 =&gt; 通过延长到2倍的长度。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);a[i<span style="color:#f92672">+</span>n] <span style="color:#f92672">=</span> a[i];}
</code></pre></div><p>思路类似于原来的并查集的对立集，也是将数组长度延长到了两倍</p>
<p>3、遍历次序：通过先遍历长度，然后再遍历左索引i，从而得到右索引j，就得到一个区间<code>(i, i+len-1)</code>，然后再在区间中遍历k，也就是分割点即可。<code>dp_max[i][j] = max(dp_max[i][j], dp_max[i][k]+dp_max[k+1][j]+cost(i, j));</code></p>
<p>4、代价计算：通过前缀和来维护，或者直接用区间来算出来。<code>sum[i][j]</code>表示合并区间的代价</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;climits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 210</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define INF INT_MAX</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, a[maxn], sum[maxn][maxn], dp_min[maxn][maxn], dp_max[maxn][maxn], ans_min <span style="color:#f92672">=</span> INF, ans_max;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);a[i<span style="color:#f92672">+</span>n] <span style="color:#f92672">=</span> a[i];}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> j; k<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
                sum[i][j] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> a[k];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dp_min[i][i] <span style="color:#f92672">=</span> dp_max[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; len <span style="color:#f92672">&lt;</span> n; len<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>len; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>, j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> len) {
            dp_min[i][j] <span style="color:#f92672">=</span> INF;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span> j; k<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
                dp_max[i][j] <span style="color:#f92672">=</span> max(dp_max[i][j], dp_max[i][k] <span style="color:#f92672">+</span> dp_max[k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> sum[i][j]);
                dp_min[i][j] <span style="color:#f92672">=</span> min(dp_min[i][j], dp_min[i][k] <span style="color:#f92672">+</span> dp_min[k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> sum[i][j]);
            }
        }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {ans_min <span style="color:#f92672">=</span> min(ans_min, dp_min[i][i<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);ans_max <span style="color:#f92672">=</span> max(ans_max, dp_max[i][i<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);}
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans_min, ans_max);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="能量项链环形">能量项链（环形）</h3>
<p><a href="https://www.luogu.com.cn/problem/P1063">https://www.luogu.com.cn/problem/P1063</a></p>
<p>题意和石子归并类似，只不过在计算cost成本的时候略有区别</p>
<p>1、区分和石子归并不同的遍历方式：石子归并是先枚举长度，然后再枚举左端点 =&gt; 通过第一层的长度和第二层的左端点，得到右端点 =&gt; 通过第二层的左端点和第二层推出来的右端点获得区间 =&gt; 进而枚举分割点</p>
<p>2、通过先枚举右端点，然后再枚举左端点，=&gt; 获得区间，再枚举分割点</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 305</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, a[maxn], dp[maxn][maxn], ans;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);a[i<span style="color:#f92672">+</span>n]<span style="color:#f92672">=</span>a[i];}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> i<span style="color:#f92672">-</span>j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> j; k <span style="color:#f92672">&lt;</span> i; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k) {
                dp[j][i] <span style="color:#f92672">=</span> max(dp[j][i], dp[j][k]<span style="color:#f92672">+</span>dp[k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][i]<span style="color:#f92672">+</span>a[j]<span style="color:#f92672">*</span>a[k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>a[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
                ans <span style="color:#f92672">=</span> max(ans, dp[j][i]);
            }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
		</section>

		<div class="meta">Posted on Feb 1, 2021</div>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/acm">ACM</a></li>
					
					<li><a href="/tags/%E7%AE%97%E6%B3%95">算法</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
	
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2021  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
