<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Algorithm11.2 数据结构 堆与堆优化 - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Algorithm11.2 数据结构 堆与堆优化 | Aczy156" />
	<meta name="twitter:title" content="Algorithm11.2 数据结构 堆与堆优化 | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Algorithm11.2 数据结构 堆与堆优化 | Aczy156" />
	<meta name="application-name" content="Algorithm11.2 数据结构 堆与堆优化 | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Algorithm11.2 数据结构 堆与堆优化" />
<meta property="og:description" content="[TOC]
数据结构 堆 &amp; 手写堆  堆：
 分类：最大堆、最小堆 过程：首先按照完全二叉树的形式，将序列填补到初始的堆中  （堆-附加：利用堆的性质来判断是否是堆：「PAT1147」，判断方法就是直接对给定的层次遍历的序列来判断，是否满足a[i] &gt; a[2&lt;&lt;i] &amp;&amp; a[i] &gt; a[2&lt;&lt;i|1]或者a[i] &lt; a[2&lt;&lt;i] &amp;&amp; a[i] &lt; a[2&lt;&lt;i|1] ，来查看是否是最大堆或者最小堆
用到堆优化的思路不一定是用堆，也可能是通过利用优先队列进行优化【堆的优化的应用场景：解决重复排序问题，每添加一个新的元素【在线更新】，都要重新排一次序 =&gt; 可以用堆进行优化】
用到堆的方式：
 手写堆：「例如下面的P3378手写堆 // P1631RMQ问题」的up/down方法来维护堆 直接利用优先队列来优化复杂度，优化的方式就是直接拿堆顶，进而取堆顶得到最大最小 或者 堆结构带来的排序「P2085取前最小」的每次拿堆顶，然后在线插入新的元素之后重新自动排序获取下一次的堆顶。   判断堆是否为最大堆、最小堆 https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648
1、判断是否是最大堆最小堆：直接判断父节点与两个子节点的的大小关系。
可以通过维护两个变量is_max = 1 / is_min = 1，当存在有子节点小于父节点=&gt;不满足最小堆了把is_min = 0；当存在有子节点大于父节点=&gt;不满足最小堆了把is_max = 0
最后看is_max和is_min两个变量，是否是最大最小堆。
// 从底部往上遍历 for (int j = 2; j &lt;= m; &#43;&#43;j) { if (a[j] &gt; a[j/2]) is_big = 0; else is_small = 0; } https://www." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.chenranfei.online/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/" />
<meta property="article:published_time" content="2021-02-01T19:03:55+08:00" />
<meta property="article:modified_time" content="2021-02-01T19:03:55+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm11.2 数据结构 堆与堆优化"/>
<meta name="twitter:description" content="[TOC]
数据结构 堆 &amp; 手写堆  堆：
 分类：最大堆、最小堆 过程：首先按照完全二叉树的形式，将序列填补到初始的堆中  （堆-附加：利用堆的性质来判断是否是堆：「PAT1147」，判断方法就是直接对给定的层次遍历的序列来判断，是否满足a[i] &gt; a[2&lt;&lt;i] &amp;&amp; a[i] &gt; a[2&lt;&lt;i|1]或者a[i] &lt; a[2&lt;&lt;i] &amp;&amp; a[i] &lt; a[2&lt;&lt;i|1] ，来查看是否是最大堆或者最小堆
用到堆优化的思路不一定是用堆，也可能是通过利用优先队列进行优化【堆的优化的应用场景：解决重复排序问题，每添加一个新的元素【在线更新】，都要重新排一次序 =&gt; 可以用堆进行优化】
用到堆的方式：
 手写堆：「例如下面的P3378手写堆 // P1631RMQ问题」的up/down方法来维护堆 直接利用优先队列来优化复杂度，优化的方式就是直接拿堆顶，进而取堆顶得到最大最小 或者 堆结构带来的排序「P2085取前最小」的每次拿堆顶，然后在线插入新的元素之后重新自动排序获取下一次的堆顶。   判断堆是否为最大堆、最小堆 https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648
1、判断是否是最大堆最小堆：直接判断父节点与两个子节点的的大小关系。
可以通过维护两个变量is_max = 1 / is_min = 1，当存在有子节点小于父节点=&gt;不满足最小堆了把is_min = 0；当存在有子节点大于父节点=&gt;不满足最小堆了把is_max = 0
最后看is_max和is_min两个变量，是否是最大最小堆。
// 从底部往上遍历 for (int j = 2; j &lt;= m; &#43;&#43;j) { if (a[j] &gt; a[j/2]) is_big = 0; else is_small = 0; } https://www."/>
<script src="http://www.chenranfei.online/js/feather.min.js"></script>
	
	<link href="http://www.chenranfei.online/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="http://www.chenranfei.online/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://www.chenranfei.online/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Algorithm11.2 数据结构 堆与堆优化</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="数据结构-堆--手写堆">数据结构 堆 &amp; 手写堆</h2>
<blockquote>
<p>堆：</p>
<ul>
<li>分类：最大堆、最小堆</li>
<li>过程：首先按照完全二叉树的形式，将序列填补到初始的堆中</li>
</ul>
<p>（堆-附加：利用堆的性质来判断是否是堆：「PAT1147」，判断方法就是直接对给定的层次遍历的序列来判断，是否满足<code>a[i] &gt; a[2&lt;&lt;i] &amp;&amp; a[i] &gt; a[2&lt;&lt;i|1]</code>或者<code>a[i] &lt; a[2&lt;&lt;i] &amp;&amp; a[i] &lt; a[2&lt;&lt;i|1]</code> ，来查看是否是最大堆或者最小堆</p>
<p>用到堆优化的思路不一定是用堆，也可能是通过利用优先队列进行优化【堆的优化的应用场景：解决重复排序问题，每添加一个新的元素【在线更新】，都要重新排一次序 =&gt; 可以用堆进行优化】</p>
<p>用到堆的方式：</p>
<ul>
<li>手写堆：「例如下面的P3378手写堆 // P1631RMQ问题」的up/down方法来维护堆</li>
<li>直接利用优先队列来优化复杂度，优化的方式就是直接拿堆顶，进而取堆顶得到最大最小 或者 堆结构带来的排序「P2085取前最小」的每次拿堆顶，然后在线插入新的元素之后重新自动排序获取下一次的堆顶。</li>
</ul>
</blockquote>
<h3 id="判断堆是否为最大堆最小堆">判断堆是否为最大堆、最小堆</h3>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648">https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648</a></p>
<p>1、判断是否是最大堆最小堆：直接判断父节点与两个子节点的的大小关系。</p>
<p>可以通过维护两个变量<code>is_max = 1 / is_min = 1</code>，当存在有子节点小于父节点=&gt;不满足最小堆了把<code>is_min = 0</code>；当存在有子节点大于父节点=&gt;不满足最小堆了把<code>is_max = 0</code></p>
<p>最后看<code>is_max</code>和<code>is_min</code>两个变量，是否是最大最小堆。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 从底部往上遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) {
    <span style="color:#66d9ef">if</span> (a[j] <span style="color:#f92672">&gt;</span> a[j<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>]) is_big <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">else</span> is_small <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><a href="https://www.luogu.com.cn/problem/P3378">https://www.luogu.com.cn/problem/P3378</a></p>
<h3 id="手写堆-实现-获取区间前几大最大">手写堆 实现 获取区间前几大/最大</h3>
<p>1、数据结构：一个模拟堆的数组myheap</p>
<p>2、堆的基本操作：</p>
<ul>
<li>insert：插入新的元素</li>
<li>myheap[1]：获取堆顶元素</li>
<li>deletetop：删除堆顶元素</li>
</ul>
<p>3、【下面范例都是小顶堆】</p>
<p>插入新的元素 =&gt; 从堆底往堆顶移动索引</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">while</span> (idx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
  <span style="color:#66d9ef">if</span> (myheap[idx] <span style="color:#f92672">&lt;</span> myheap[idx<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>]) {
    swap(myheap[idx], myheap[idx<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>]);
    idx <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
  }
}
</code></pre></div><p>删除堆顶元素 =&gt; 从堆顶网堆底移动索引</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> son <span style="color:#f92672">=</span> idx<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">while</span> (son <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> size) {
  <span style="color:#66d9ef">if</span> (son <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> myheap[son] <span style="color:#f92672">&gt;</span> myheap[son<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) son<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
  <span style="color:#66d9ef">if</span> (myheap[son] <span style="color:#f92672">&lt;</span> myheap[idx]) {
    swap(myheap[son], myheap[idx]);
    idx <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
  }
}
</code></pre></div><p>完整代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 1000010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> t, myheap[maxn], size, tp, ta;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up</span>(<span style="color:#66d9ef">int</span> idx) {
    <span style="color:#66d9ef">while</span> (idx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> (myheap[idx] <span style="color:#f92672">&lt;</span> myheap[idx<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>]) {
            swap(myheap[idx], myheap[idx<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>]);
            idx <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x) {
    myheap[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>size] <span style="color:#f92672">=</span> x;
    up(size);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down</span>(<span style="color:#66d9ef">int</span> idx) {
    <span style="color:#66d9ef">int</span> son <span style="color:#f92672">=</span> idx<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (son <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> size) {
        <span style="color:#66d9ef">if</span> (son <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> myheap[son] <span style="color:#f92672">&gt;</span> myheap[son<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) son<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">if</span> (myheap[son] <span style="color:#f92672">&lt;</span> myheap[idx]) {
            swap(myheap[son], myheap[idx]);
            idx <span style="color:#f92672">=</span> son; son <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deletetop</span>() {
    myheap[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> myheap[size<span style="color:#f92672">-</span><span style="color:#f92672">-</span>];
    down(<span style="color:#ae81ff">1</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>t);
    <span style="color:#66d9ef">while</span> (t<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tp);
        <span style="color:#66d9ef">if</span> (tp <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
            scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta);
            insert(ta);
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (tp <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, myheap[<span style="color:#ae81ff">1</span>]);
        <span style="color:#66d9ef">else</span> deletetop();
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><p><strong>用STL库中的堆</strong></p>
<p><strong>用优先队列模拟堆的最大</strong></p>
<p>声明一个小顶堆即可。<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> pq;
<span style="color:#66d9ef">int</span> m, op, t;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>op);
        <span style="color:#66d9ef">switch</span> (op) {
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>t);pq.push(t);<span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span> printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pq.top());<span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span> pq.pop();<span style="color:#66d9ef">break</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="限定长度的堆--类似于滑动窗口">限定长度的堆 =&gt; 类似于滑动窗口</h3>
<p>(RMQ问题，也可用于解决类似于滑动窗口，单调队列)</p>
<p><a href="https://www.luogu.com.cn/problem/P1631">https://www.luogu.com.cn/problem/P1631</a></p>
<p>1、注意：选取最小的几个的话，不能用最小堆，需要用最大堆，然后每次再来新的元素之后，判断此元素和堆顶的大小关系：如果大于堆顶=&gt;直接忽略；小于堆顶，把堆顶替换，然后往下down即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 100010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, myheap[maxn], size, a[maxn], b[maxn], ans[maxn];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up</span>(<span style="color:#66d9ef">int</span> idx) {
    <span style="color:#66d9ef">while</span> (idx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> (myheap[idx] <span style="color:#f92672">&gt;</span> myheap[idx<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>]) {
            swap(myheap[idx], myheap[idx<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>]);
            idx <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x) {
    myheap[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>size] <span style="color:#f92672">=</span> x;
    up(size);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down</span>(<span style="color:#66d9ef">int</span> idx) {
    <span style="color:#66d9ef">int</span> son <span style="color:#f92672">=</span> idx<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (son <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> size) {
        <span style="color:#66d9ef">if</span> (son<span style="color:#f92672">&lt;</span>size <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> myheap[son]<span style="color:#f92672">&lt;</span>myheap[son<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) son<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">if</span> (myheap[idx] <span style="color:#f92672">&lt;</span> myheap[son]) {
            swap(myheap[idx], myheap[son]);
            idx<span style="color:#f92672">=</span>son;son<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deletetop</span>(){
    myheap[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> myheap[size<span style="color:#f92672">-</span><span style="color:#f92672">-</span>];
    down(<span style="color:#ae81ff">1</span>);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">change</span>(<span style="color:#66d9ef">int</span> x) {
    myheap[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> x;
    down(<span style="color:#ae81ff">1</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>b[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) insert(a[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>b[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) {
            <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">+</span> b[j] <span style="color:#f92672">&gt;</span> myheap[<span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">break</span>;
            change(a[i]<span style="color:#f92672">+</span>b[j]);
        }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        ans[i] <span style="color:#f92672">=</span> myheap[<span style="color:#ae81ff">1</span>];
        deletetop();
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>i) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, ans[i]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="取前最小---复杂的题意">取前最小 - 复杂的题意</h3>
<p><a href="https://www.luogu.com.cn/problem/P2085">https://www.luogu.com.cn/problem/P2085</a></p>
<p>1、最小值可能是某一个函数一直往后取x，也有可能是不同的函数各自往后延伸，因此至于延伸哪个，每次都要排序，然后在线排序 =&gt; <em>堆型</em>数据结构优化</p>
<p>2、用结构体来储存每个单元，然后在每次优先队列取top的，留下id和xx的值，然后往后拓展。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxn 10010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> node {
    <span style="color:#66d9ef">int</span> val, id, xx;
    node(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> id, <span style="color:#66d9ef">int</span> xx)<span style="color:#f92672">:</span> val(val), id(id), xx(xx){}
    <span style="color:#66d9ef">bool</span> operator <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> node n) <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> val <span style="color:#f92672">&gt;</span> n.val;}
};
<span style="color:#66d9ef">int</span> n, m, a[maxn], b[maxn], c[maxn];
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>priority_queue<span style="color:#f92672">&lt;</span>node, vector<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span>, less<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> pq;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i], <span style="color:#f92672">&amp;</span>b[i], <span style="color:#f92672">&amp;</span>c[i]);
        pq.push(node(a[i]<span style="color:#f92672">+</span>b[i]<span style="color:#f92672">+</span>c[i], i, <span style="color:#ae81ff">1</span>));
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        node nw <span style="color:#f92672">=</span> pq.top();pq.pop();
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, nw.val);
        <span style="color:#66d9ef">int</span> nid <span style="color:#f92672">=</span> nw.id, nxx <span style="color:#f92672">=</span> nw.xx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        pq.push(node(a[nid]<span style="color:#f92672">*</span>nxx<span style="color:#f92672">*</span>nxx<span style="color:#f92672">+</span>b[nid]<span style="color:#f92672">*</span>nxx<span style="color:#f92672">+</span>c[nid], nid, nxx));
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
		</section>

		<div class="meta">Posted on Feb 1, 2021</div>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/acm">ACM</a></li>
					
					<li><a href="/tags/%E7%AE%97%E6%B3%95">算法</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2021  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
