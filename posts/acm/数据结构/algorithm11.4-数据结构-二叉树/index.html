<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历 - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历 | Aczy156" />
	<meta name="twitter:title" content="Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历 | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历 | Aczy156" />
	<meta name="application-name" content="Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历 | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历" />
<meta property="og:description" content="[TOC]
数据结构 树 二叉树 性质 建树、前中后序遍历  树相关 遍历操作：
 【递归】先根遍历、后根遍历。看所有儿子节点和根节点的遍历顺序 【非递归】也是用队列先进先出作为数据结构来存    二叉树相关 两种实现方式：（基本的树结构是两种，如果转换为图进行储存也是可以的）
  「顺序表」结构体数组实现
  「链接表」二叉链表实现
  拓展方法：通过图方式进行存储
  树结构性质：
  对于各种二叉树都有的性质：各种类型的节点个数之间的关系
 叶子结点个数=度为2的节点个数&#43;1（推导：连线个数=2*n2&#43;1*n1&#43;0*n0，节点个数=n2&#43;n1&#43;n0，连线个数&#43;1=节点个数 =&gt; n2&#43;1 = n0）    对于完全二叉树：高度相关，pow(2, k-1) &lt; n &lt; pow(2, k)，这样可以反推出k的范围。
  遍历操作：
 基本的三种前中后序「主要根据碰到根节点的三个时机，分出了前中后序遍历」  【递归实现】 【非递归实现】通过 栈 模拟函数调用栈先进后出 来 模拟 递归前中后序遍历   【非递归】层次遍历：通过维护一个先进先出  遍历性质：
 前序 中序 后序 dfs序 相关性质 给出两个，推第三个  给出前&#43;后【不带中】 =&gt; 中序不一定唯一 给出中&#43;前【带中】 =&gt; 后序唯一 给出中&#43;后【带中】 =&gt; 前序唯一      树与二叉树之间转换 兄弟节点法，把当前节点的同层的右边节点按次顺到右儿子，一直这样下去。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.chenranfei.online/posts/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/algorithm11.4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/" />
<meta property="article:published_time" content="2021-02-01T19:03:55+08:00" />
<meta property="article:modified_time" content="2021-02-01T19:03:55+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历"/>
<meta name="twitter:description" content="[TOC]
数据结构 树 二叉树 性质 建树、前中后序遍历  树相关 遍历操作：
 【递归】先根遍历、后根遍历。看所有儿子节点和根节点的遍历顺序 【非递归】也是用队列先进先出作为数据结构来存    二叉树相关 两种实现方式：（基本的树结构是两种，如果转换为图进行储存也是可以的）
  「顺序表」结构体数组实现
  「链接表」二叉链表实现
  拓展方法：通过图方式进行存储
  树结构性质：
  对于各种二叉树都有的性质：各种类型的节点个数之间的关系
 叶子结点个数=度为2的节点个数&#43;1（推导：连线个数=2*n2&#43;1*n1&#43;0*n0，节点个数=n2&#43;n1&#43;n0，连线个数&#43;1=节点个数 =&gt; n2&#43;1 = n0）    对于完全二叉树：高度相关，pow(2, k-1) &lt; n &lt; pow(2, k)，这样可以反推出k的范围。
  遍历操作：
 基本的三种前中后序「主要根据碰到根节点的三个时机，分出了前中后序遍历」  【递归实现】 【非递归实现】通过 栈 模拟函数调用栈先进后出 来 模拟 递归前中后序遍历   【非递归】层次遍历：通过维护一个先进先出  遍历性质：
 前序 中序 后序 dfs序 相关性质 给出两个，推第三个  给出前&#43;后【不带中】 =&gt; 中序不一定唯一 给出中&#43;前【带中】 =&gt; 后序唯一 给出中&#43;后【带中】 =&gt; 前序唯一      树与二叉树之间转换 兄弟节点法，把当前节点的同层的右边节点按次顺到右儿子，一直这样下去。"/>
<script src="http://www.chenranfei.online/js/feather.min.js"></script>
	
	<link href="http://www.chenranfei.online/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="http://www.chenranfei.online/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://www.chenranfei.online/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<aside>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#数据结构-树-二叉树-性质-建树前中后序遍历">数据结构 树 二叉树 性质 建树、前中后序遍历</a>
      <ul>
        <li><a href="#树相关">树相关</a></li>
        <li><a href="#二叉树相关">二叉树相关</a></li>
        <li><a href="#树与二叉树之间转换">树与二叉树之间转换</a></li>
        <li><a href="#二叉链表实现---利用链表来链接起树的结构">二叉链表实现 - 利用链表来链接起树的结构</a></li>
        <li><a href="#二叉树建树---节点值做索引表示">二叉树建树 - 节点值做索引表示</a></li>
        <li><a href="#二叉树----节点值做索引-搜索深度">二叉树 -  节点值做索引 搜索深度</a></li>
        <li><a href="#二叉树的前序-中序-后序-dfs序等性质--给出前后求中序">二叉树的前序 中序 后序 dfs序等性质 // 【给出前后，求中序】</a></li>
        <li><a href="#二叉树的前序-中序-后序-dfs序等性质--给出中序前后中的一个求另一个">二叉树的前序 中序 后序 dfs序等性质 // 【给出中序+前后中的一个，求另一个】</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
	<article>
		<div class="title">
			<h1 class="title">Algorithm11.4 数据结构 树 二叉树 性质 建树 前中后序遍历</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="数据结构-树-二叉树-性质-建树前中后序遍历">数据结构 树 二叉树 性质 建树、前中后序遍历</h2>
<blockquote>
<h3 id="树相关">树相关</h3>
<p>遍历操作：</p>
<ul>
<li>【递归】先根遍历、后根遍历。看所有儿子节点和根节点的遍历顺序</li>
<li>【非递归】也是用队列<strong>先进先出</strong>作为数据结构来存</li>
</ul>
</blockquote>
<blockquote>
<h3 id="二叉树相关">二叉树相关</h3>
<p>两种实现方式：（基本的树结构是两种，如果转换为图进行储存也是可以的）</p>
<ul>
<li>
<p>「顺序表」结构体数组实现</p>
</li>
<li>
<p>「链接表」二叉链表实现</p>
</li>
<li>
<p>拓展方法：通过图方式进行存储</p>
</li>
</ul>
<p>树结构性质：</p>
<ul>
<li>
<p>对于各种二叉树都有的性质：各种类型的节点个数之间的关系</p>
<ul>
<li>叶子结点个数=度为2的节点个数+1（推导：连线个数=2<code>*</code>n2+1<code>*</code>n1+0<code>*</code>n0，节点个数=n2+n1+n0，连线个数+1=节点个数 =&gt; n2+1 = n0）</li>
</ul>
</li>
<li>
<p>对于完全二叉树：高度相关，pow(2, k-1) &lt; n &lt; pow(2, k)，这样可以反推出k的范围。</p>
</li>
</ul>
<p>遍历操作：</p>
<ul>
<li>基本的三种前中后序「主要根据碰到根节点的三个时机，分出了前中后序遍历」
<ul>
<li>【递归实现】</li>
<li>【非递归实现】通过 栈 模拟函数调用栈<strong>先进后出</strong> 来 模拟 递归前中后序遍历</li>
</ul>
</li>
<li>【非递归】层次遍历：通过维护一个<strong>先进先出</strong></li>
</ul>
<p>遍历性质：</p>
<ul>
<li>前序 中序 后序 dfs序 相关性质</li>
<li>给出两个，推第三个
<ul>
<li>给出前+后【不带中】 =&gt; 中序不一定唯一</li>
<li>给出中+前【带中】 =&gt; 后序唯一</li>
<li>给出中+后【带中】 =&gt; 前序唯一</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h3 id="树与二叉树之间转换">树与二叉树之间转换</h3>
<p>兄弟节点法，把当前节点的同层的右边节点按次顺到右儿子，一直这样下去。</p>
<p>转换回去，通过把右节点往上一直连接</p>
</blockquote>
<h3 id="二叉链表实现---利用链表来链接起树的结构">二叉链表实现 - 利用链表来链接起树的结构</h3>
<p>1、节点中有两个指向叶子结点的指针。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span>(){
  <span style="color:#66d9ef">int</span> data;
  node <span style="color:#f92672">*</span> lchild;
  node <span style="color:#f92672">*</span> rchild;
  node(){}
  node(<span style="color:#66d9ef">int</span> data)<span style="color:#f92672">:</span> data(data){}
  node(<span style="color:#66d9ef">int</span> data, node <span style="color:#f92672">*</span> lchild, node <span style="color:#f92672">*</span> rchild)<span style="color:#f92672">:</span> data(data), lchild(lchild), rchild(rchild){}
}
</code></pre></div><p>2、要给出的数据，是一串字符串，然后通过递归建树的过程中，逐渐输入scanf进去</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">// 两组测试用例
// A B D # # E # # C F # # G # #
// 1 2 4 # # 5 # # 3 6 # # 7 # #

// A B C # # D E # G # # F # # #
// 1 2 3 # # 4 5 # 6 # # 7 # # #
</code></pre></div><p>3、思路：由于是二叉链表，实质上是指针指向的，所以就写一个<em>递归的返回指针的函数</em>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">node <span style="color:#f92672">*</span> <span style="color:#a6e22e">build</span>() {
  <span style="color:#66d9ef">char</span> ch;
  cin<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>ch;
  <span style="color:#66d9ef">if</span> (ch <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">#</span><span style="color:#e6db74">&#39;</span>) <span style="color:#66d9ef">return</span> NULL;
  <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e">// 声明出当前指向结构体的指针
</span><span style="color:#75715e"></span>    node <span style="color:#f92672">*</span> n <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
    n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data <span style="color:#f92672">=</span> ch<span style="color:#f92672">-</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">0</span><span style="color:#e6db74">&#39;</span>;
    n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild <span style="color:#f92672">=</span> build();
    n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild <span style="color:#f92672">=</span> build();
  }
}

<span style="color:#75715e">// main函数里 =&gt; 先创建一个指向根节点的指针，然后就可以开始给这个指针build了
</span><span style="color:#75715e"></span>node <span style="color:#f92672">*</span> tree <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
tree <span style="color:#f92672">=</span> build();
</code></pre></div><p>4、前周后序遍历，都只需要将指向根节点的指针传入即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> data;
    <span style="color:#75715e">// 指向左右子叶
</span><span style="color:#75715e"></span>    node <span style="color:#f92672">*</span> lchild;
    node <span style="color:#f92672">*</span> rchild;
    <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>    node(){}
    node(<span style="color:#66d9ef">int</span> data)<span style="color:#f92672">:</span> data(data){}
    node(<span style="color:#66d9ef">int</span> data, node <span style="color:#f92672">*</span> lchild, node <span style="color:#f92672">*</span> rchild)<span style="color:#f92672">:</span> data(data), lchild(lchild), rchild(rchild){}
};
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 构造二叉树
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> ch;
node <span style="color:#f92672">*</span> <span style="color:#a6e22e">build</span>(){
    cin<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>ch;
    <span style="color:#66d9ef">if</span> (ch <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">#</span><span style="color:#e6db74">&#39;</span>) <span style="color:#66d9ef">return</span> NULL;
    <span style="color:#66d9ef">else</span> {
        node <span style="color:#f92672">*</span> n <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
        n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data <span style="color:#f92672">=</span> ch<span style="color:#f92672">-</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">0</span><span style="color:#e6db74">&#39;</span>;
        n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild <span style="color:#f92672">=</span> build();
        n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild <span style="color:#f92672">=</span> build();
        <span style="color:#66d9ef">return</span> n;
    }
}

<span style="color:#75715e">// 前序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pre_traverse</span>(node <span style="color:#f92672">*</span> n) {
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) pre_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild);
    <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) pre_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);
}

<span style="color:#75715e">// 中序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">in_traverse</span>(node <span style="color:#f92672">*</span> n) {
    <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) in_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) in_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);
}

<span style="color:#75715e">// 后序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">post_traverse</span>(node <span style="color:#f92672">*</span> n) {
    <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) post_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild);
    <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) post_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#75715e">// 非递归遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> cnt_node, cnt_1, cnt_2, cnt_leaf, val_min<span style="color:#f92672">=</span>INT_MAX, val_max;
queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> q1;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">non_recursive_traverse</span>(node <span style="color:#f92672">*</span> n) {
    q1.push(n);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q1.empty()) {
        node <span style="color:#f92672">*</span> nw <span style="color:#f92672">=</span> q1.front();q1.pop();
        cnt_node<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        val_min <span style="color:#f92672">=</span> min(val_min, nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data); val_max <span style="color:#f92672">=</span> max(val_max, nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data);
        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) cnt_2<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild<span style="color:#f92672">=</span><span style="color:#f92672">=</span>NULL <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild<span style="color:#f92672">=</span><span style="color:#f92672">=</span>NULL) cnt_leaf<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">else</span> cnt_1<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) q1.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild);
        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) q1.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);
    }
}

<span style="color:#75715e">// 选做内容：bfs 层次遍历
</span><span style="color:#75715e"></span>queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> q2;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(node <span style="color:#f92672">*</span> n) {
    q2.push(n);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q2.empty()) {
        node <span style="color:#f92672">*</span> nw <span style="color:#f92672">=</span> q2.front();q2.pop();
        cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) q2.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild);
        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) q2.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    node <span style="color:#f92672">*</span> tree <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
    <span style="color:#75715e">// 建树
</span><span style="color:#75715e"></span>    tree <span style="color:#f92672">=</span> build();
    <span style="color:#75715e">// 前中后序遍历
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">前序遍历: </span><span style="color:#e6db74">&#34;</span>; pre_traverse(tree);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">中序遍历: </span><span style="color:#e6db74">&#34;</span>; in_traverse(tree);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">后序遍历: </span><span style="color:#e6db74">&#34;</span>; post_traverse(tree);
    <span style="color:#75715e">// 非递归遍历
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">非递归遍历: </span><span style="color:#e6db74">&#34;</span>; non_recursive_traverse(tree);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_node<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  度为1的节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_1<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  度为2的节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_2<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  叶子节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_leaf<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">最大值:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>val_max<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  最小值:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>val_min;
    <span style="color:#75715e">// bfs
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">层次遍历(bfs): </span><span style="color:#e6db74">&#34;</span>; bfs(tree); cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二叉树建树---节点值做索引表示">二叉树建树 - 节点值做索引表示</h3>
<p><a href="https://www.luogu.com.cn/problem/P1305">https://www.luogu.com.cn/problem/P1305</a></p>
<p>1、节点值做索引的数据结构</p>
<p>结构体中不需要当前节点的值，因为这个节点的值已经在做数据结构的索引了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> node {
  <span style="color:#66d9ef">int</span> left, right;
}tree[maxnode];
</code></pre></div><p>要求给出的数据（节点的顺序必须为对应的，不然这样匹配是有问题的）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 读入字符串abc，得到a为根节点，bc分别为两个子节点 (注意读取单个字符的时候，要给空格来冲刷掉回车的影响)
</span><span style="color:#75715e"></span>scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ch);
scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c%c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tree[ch].left, <span style="color:#f92672">&amp;</span>tree[ch].right);
</code></pre></div><p>2、前中后序的遍历</p>
<ul>
<li>前：根-&gt;左-&gt;右</li>
<li>中：左-&gt;根-&gt;右</li>
<li>后：右-&gt;根-&gt;左</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">front_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
  printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">左</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) front_traverse(tree[ch].left);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">右</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) front_traverse(tree[ch].right);
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mid_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">左</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) mid_traverse(tree[ch].left);
  printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">右</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) mid_traverse(tree[ch].right);
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">back_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">左</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) back_traverse(tree[ch].left);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">右</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) back_traverse(tree[ch].right);
  printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
}
</code></pre></div><p>AC代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">struct</span> node {
    <span style="color:#66d9ef">char</span> left, right;
}tree[<span style="color:#ae81ff">1000</span>];
<span style="color:#66d9ef">char</span> ch, root;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">front_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
    <span style="color:#75715e">// front traverse =&gt; root, left, right
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
    <span style="color:#66d9ef">if</span> (tree[ch].left <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">*</span><span style="color:#e6db74">&#39;</span>) front_traverse(tree[ch].left);
    <span style="color:#66d9ef">if</span> (tree[ch].right <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">*</span><span style="color:#e6db74">&#39;</span>) front_traverse(tree[ch].right);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ch);
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) root <span style="color:#f92672">=</span> ch;
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c%c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tree[ch].left, <span style="color:#f92672">&amp;</span>tree[ch].right);
    }
    front_traverse(root);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二叉树----节点值做索引-搜索深度">二叉树 -  节点值做索引 搜索深度</h3>
<p><a href="https://www.luogu.com.cn/problem/P4913">https://www.luogu.com.cn/problem/P4913</a></p>
<p>1、遍历的过程中就筛选出最大的深度，通过维护一个ans来提取。</p>
<p>第一种，通过在dfs深搜到儿子节点之前来判断是否要搜他。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> depth) {
  ans <span style="color:#f92672">=</span> max(ans, depth);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tree[val].left) dfs(tree[val].left, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tree[val].right) dfs(tree[val].right, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>第二种，通过在搜到之后，判断这个搜到的点是否符合搜的要求。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> depth) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>val) <span style="color:#66d9ef">return</span>;
  ans <span style="color:#f92672">=</span> max(ans, depth);
  dfs(tree[val].left, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
  dfs(tree[val].right, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>AC代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxnode 1000010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> node{
    <span style="color:#66d9ef">int</span> left, right;
}tree[maxnode];
<span style="color:#66d9ef">int</span> n, ans;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> depth) {
    ans <span style="color:#f92672">=</span> max(ans, depth);
    <span style="color:#66d9ef">if</span> (tree[val].left) dfs(tree[val].left, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> (tree[val].right) dfs(tree[val].right, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tree[i].left, <span style="color:#f92672">&amp;</span>tree[i].right);
    dfs(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二叉树的前序-中序-后序-dfs序等性质--给出前后求中序">二叉树的前序 中序 后序 dfs序等性质 // 【给出前后，求中序】</h3>
<p><a href="https://www.luogu.com.cn/problem/P1229">https://www.luogu.com.cn/problem/P1229</a></p>
<p>题目：给出前序后序，不给中序，求这棵树有多少种形态。【中序有多少种】</p>
<p>分析：前序：根左右，中序：左根右，后序：左右根</p>
<p>性质：一个树有多少种形态，取决于儿子节点只有1个的节点的个数。【形态数 = pow(2, 儿子节点为1的节点个数)】</p>
<ul>
<li>如果一棵树没有只有一个儿子节点的节点=》也就是是一个完满二叉树，只要有儿子节点，就是两个，要不就没有儿子节点。
<ul>
<li>此时树形态已经被确定了，例如前序abc后序bca，那这就是一个a-&gt;(b,c)的完满二叉树，在例如前序abdecfg后序debfgca，那就是一个a-&gt;(b-&gt;(d,e), c-&gt;(f,g))的完满二叉树</li>
</ul>
</li>
<li>如果一个棵树的节点都只有一个儿子节点=》和一根线一样，就例如如果就是abc往下排列的一根线，那么可以计算得到两个节点满足只有一个儿子节点，那么总共有4种，分别为左左，左右，右左，右右。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
string pre, post;
<span style="color:#66d9ef">int</span> ans;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>pre<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>post;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pre.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> post.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            <span style="color:#66d9ef">if</span> (pre[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> post[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> post[j] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> pre[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) ans<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二叉树的前序-中序-后序-dfs序等性质--给出中序前后中的一个求另一个">二叉树的前序 中序 后序 dfs序等性质 // 【给出中序+前后中的一个，求另一个】</h3>
<p><a href="https://www.luogu.com.cn/problem/P1030">https://www.luogu.com.cn/problem/P1030</a> 该题是由中序+后序求前序</p>
<p><a href="https://www.luogu.com.cn/problem/P1827">https://www.luogu.com.cn/problem/P1827</a> 该题是由中序+前序求后序</p>
<p>思路：首先明确前：根左右   中：左根右     后：左右根</p>
<p>然后整体思路就是通过前或者后的根在一边的特性，直接从对应的一段提取出根，然后再在中序中找到根，根左边的就是左子树，根右边的就是右子树，然后再递归两颗子树即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
string pre, in, post;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transform_pre</span>(string i, string p) {
    <span style="color:#66d9ef">if</span> (i.length() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">char</span> root <span style="color:#f92672">=</span> p[p.length() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
        cout <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> root;
        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> i.find(root);
        transform_pre(i.substr(<span style="color:#ae81ff">0</span>, pos), p.substr(<span style="color:#ae81ff">0</span>, pos));
        transform_pre(i.substr(pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), p.substr(pos, i.size() <span style="color:#f92672">-</span> pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transform_post</span>(string pr, string i) {
    <span style="color:#66d9ef">if</span> (i.length() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">char</span> root <span style="color:#f92672">=</span> pr[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> i.find(root);
        transform_post(pr.substr(<span style="color:#ae81ff">1</span>, pos), i.substr(<span style="color:#ae81ff">0</span>, pos));
        transform_post(pr.substr(pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), i.substr(pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
        cout <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> root;
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#75715e">//    cin &gt;&gt; in &gt;&gt; post;
</span><span style="color:#75715e"></span><span style="color:#75715e">//    transform_pre(in, post);
</span><span style="color:#75715e"></span>    cin <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> in <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> pre;
    transform_post(pre, in);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}



<span style="color:#75715e">//1 2 3 4 5 6 7
</span><span style="color:#75715e"></span><span style="color:#75715e">//中序遍历: 3256471
</span><span style="color:#75715e"></span><span style="color:#75715e">//后序遍历: 3657421
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//1 2 4 5 3 6 7
</span><span style="color:#75715e"></span><span style="color:#75715e">//中序遍历: 4251637
</span><span style="color:#75715e"></span><span style="color:#75715e">//后序遍历: 4526731
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 1245367 4251637 4526731
</span></code></pre></div>
		</section>

		<div class="meta">Posted on Feb 1, 2021</div>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/acm">ACM</a></li>
					
					<li><a href="/tags/%E7%AE%97%E6%B3%95">算法</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
	
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2021  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
