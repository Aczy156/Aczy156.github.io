<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Java Web Spring - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Java Web Spring | Aczy156" />
	<meta name="twitter:title" content="Java Web Spring | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Java Web Spring | Aczy156" />
	<meta name="application-name" content="Java Web Spring | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Java Web Spring" />
<meta property="og:description" content="[TOC]
Java Web Spring IOC [依赖注入/控制反转] 1、例子：class A中引入class B，两种方法：
 传统方法：在A中new一个class B的类。这样是A控制着B。 IOC：在A的构造函数中注入一个已经提前new好的class B的类。这样B还是B，不受A的控制。  2、在Spring中的使用：消除所有依赖关系 and 工厂模式
a）消除所有依赖关系：通过控制反转提前new出需要new的类。
b）工厂模式：用一个工厂来提前把所有需要new的类给new出来。供所有需要注入的类去注入。其中有两种工厂模式来进行对象的映射
 简单工厂：静态，单个唯一的工厂 工厂方法：动态，一个抽象的、产生工厂的唯一工厂&#43;有多少个产品就有多少个具体工厂的具体工厂（这些工厂是有抽象工厂挨个产生的）。  AOP [面向切面编程] 最简单的理解：为目标对象创建一个代理对象，通过代理对象调用目标对象，并且可以在目标对象前后进行切面编程
单例模式 Spring依赖注入的Bean实例是单例的。
每一个类都仅有一个实例，并且提供了一个全局访问点，也就是BeanFactory，只能通过这个访问点来获取实例。（创建则是在每次初始化运行的时候创建的）
Spring MVC [Spring 的 Handler接口] 利用适配器模式，每每需要新增/扩展一个Controller来处理请求，就直接实现接口，implement Controller，然后直接实现返回值为ModelAndView的handleRequest方法即可。
配置文件   Maven：只要用maven进行包管理，那么必定有pom.xml，里边写了各种需要的依赖
  Spring MVC：
 整个项目，命名空间、schema设置-&gt;applicationContext.xml； servlet之间映射关系，URL与Controller，请求与处理请求-&gt;dispatcher-servlet.xml； 其他URL的映射关系-&gt;web.xml    Spring Boot：唯一的application.properties配置文件。（配置包括JDBC、Mybatis、logging等等各种都可以在这唯一的配置文件中配置）
  运行项目 myPetStore - 利用Spring boot的jpetsotre 项目地址：https://github.com/Aczy156/myPetStore
 clone之后，运行的时候需要注意：resource目录的目录类型没有同步为resource root，导致运行项目的时候spring容器无法识别，导致application.properties中的很多属性无法被正常提取，所以无法运行。参考博客  运行项目 NewPetStore - 前后端分离 Nuxt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://chenranfei.site/posts/project/java-spring/" />
<meta property="article:published_time" content="2020-04-08T20:42:26+08:00" />
<meta property="article:modified_time" content="2020-04-08T20:42:26+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java Web Spring"/>
<meta name="twitter:description" content="[TOC]
Java Web Spring IOC [依赖注入/控制反转] 1、例子：class A中引入class B，两种方法：
 传统方法：在A中new一个class B的类。这样是A控制着B。 IOC：在A的构造函数中注入一个已经提前new好的class B的类。这样B还是B，不受A的控制。  2、在Spring中的使用：消除所有依赖关系 and 工厂模式
a）消除所有依赖关系：通过控制反转提前new出需要new的类。
b）工厂模式：用一个工厂来提前把所有需要new的类给new出来。供所有需要注入的类去注入。其中有两种工厂模式来进行对象的映射
 简单工厂：静态，单个唯一的工厂 工厂方法：动态，一个抽象的、产生工厂的唯一工厂&#43;有多少个产品就有多少个具体工厂的具体工厂（这些工厂是有抽象工厂挨个产生的）。  AOP [面向切面编程] 最简单的理解：为目标对象创建一个代理对象，通过代理对象调用目标对象，并且可以在目标对象前后进行切面编程
单例模式 Spring依赖注入的Bean实例是单例的。
每一个类都仅有一个实例，并且提供了一个全局访问点，也就是BeanFactory，只能通过这个访问点来获取实例。（创建则是在每次初始化运行的时候创建的）
Spring MVC [Spring 的 Handler接口] 利用适配器模式，每每需要新增/扩展一个Controller来处理请求，就直接实现接口，implement Controller，然后直接实现返回值为ModelAndView的handleRequest方法即可。
配置文件   Maven：只要用maven进行包管理，那么必定有pom.xml，里边写了各种需要的依赖
  Spring MVC：
 整个项目，命名空间、schema设置-&gt;applicationContext.xml； servlet之间映射关系，URL与Controller，请求与处理请求-&gt;dispatcher-servlet.xml； 其他URL的映射关系-&gt;web.xml    Spring Boot：唯一的application.properties配置文件。（配置包括JDBC、Mybatis、logging等等各种都可以在这唯一的配置文件中配置）
  运行项目 myPetStore - 利用Spring boot的jpetsotre 项目地址：https://github.com/Aczy156/myPetStore
 clone之后，运行的时候需要注意：resource目录的目录类型没有同步为resource root，导致运行项目的时候spring容器无法识别，导致application.properties中的很多属性无法被正常提取，所以无法运行。参考博客  运行项目 NewPetStore - 前后端分离 Nuxt."/>
<script src="http://chenranfei.site/js/feather.min.js"></script>
	
	<link href="http://chenranfei.site/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="http://chenranfei.site/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://chenranfei.site/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<aside>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#java-web-spring">Java Web Spring</a>
      <ul>
        <li><a href="#ioc-依赖注入控制反转">IOC [依赖注入/控制反转]</a></li>
        <li><a href="#aop-面向切面编程">AOP [面向切面编程]</a></li>
        <li><a href="#单例模式">单例模式</a></li>
        <li><a href="#spring-mvc-spring-的-handler接口">Spring MVC [Spring 的 Handler接口]</a></li>
        <li><a href="#配置文件">配置文件</a></li>
        <li><a href="#运行项目-mypetstore---利用spring-boot的jpetsotre">运行项目 myPetStore - 利用Spring boot的jpetsotre</a></li>
        <li><a href="#运行项目-newpetstore---前后端分离-nuxtjsspring-boot">运行项目 NewPetStore - 前后端分离 Nuxt.js+Spring boot</a></li>
        <li><a href="#运行项目-unifit---前后端分离-nuxtjsspring-boot">运行项目 Unifit - 前后端分离 Nuxt.js+Spring boot</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
	<article>
		<div class="title">
			<h1 class="title">Java Web Spring</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="java-web-spring">Java Web Spring</h2>
<h3 id="ioc-依赖注入控制反转">IOC [依赖注入/控制反转]</h3>
<p>1、例子：class A中引入class B，两种方法：</p>
<ul>
<li>传统方法：在A中new一个class B的类。这样是A控制着B。</li>
<li>IOC：在A的构造函数中注入一个已经提前new好的class B的类。这样B还是B，不受A的控制。</li>
</ul>
<p>2、在Spring中的使用：<code>消除所有依赖关系</code> and <code>工厂模式</code></p>
<p>a）消除所有依赖关系：通过控制反转提前new出需要new的类。</p>
<p>b）工厂模式：用一个工厂来提前把所有需要new的类给new出来。供所有需要注入的类去注入。其中有两种工厂模式来进行对象的映射</p>
<ul>
<li>简单工厂：静态，单个唯一的工厂</li>
<li>工厂方法：动态，一个抽象的、产生工厂的唯一工厂+有多少个产品就有多少个具体工厂的具体工厂（这些工厂是有抽象工厂挨个产生的）。</li>
</ul>
<h3 id="aop-面向切面编程">AOP [面向切面编程]</h3>
<p>最简单的理解：为目标对象创建一个代理对象，通过代理对象调用目标对象，并且可以在目标对象前后进行切面编程</p>
<h3 id="单例模式">单例模式</h3>
<p>Spring依赖注入的Bean实例是单例的。</p>
<p>每一个类都仅有一个实例，并且提供了一个全局访问点，也就是BeanFactory，只能通过这个访问点来获取实例。（创建则是在每次初始化运行的时候创建的）</p>
<h3 id="spring-mvc-spring-的-handler接口">Spring MVC [Spring 的 Handler接口]</h3>
<p>利用适配器模式，每每需要新增/扩展一个Controller来处理请求，就直接实现接口，implement Controller，然后直接实现返回值为ModelAndView的handleRequest方法即可。</p>
<p><img src="/Users/aczy156/Library/Application Support/typora-user-images/image-20220113165427573.png" alt="image-20220113165427573" style="zoom:50%;" /></p>
<h3 id="配置文件">配置文件</h3>
<ul>
<li>
<p>Maven：只要用maven进行包管理，那么必定有pom.xml，里边写了各种需要的依赖</p>
</li>
<li>
<p>Spring MVC：</p>
<ul>
<li>整个项目，命名空间、schema设置-&gt;applicationContext.xml；</li>
<li>servlet之间映射关系，URL与Controller，请求与处理请求-&gt;dispatcher-servlet.xml；</li>
<li>其他URL的映射关系-&gt;web.xml</li>
</ul>
</li>
<li>
<p>Spring Boot：唯一的application.properties配置文件。（配置包括JDBC、Mybatis、logging等等各种都可以在这唯一的配置文件中配置）</p>
</li>
</ul>
<h3 id="运行项目-mypetstore---利用spring-boot的jpetsotre">运行项目 myPetStore - 利用Spring boot的jpetsotre</h3>
<p>项目地址：https://github.com/Aczy156/myPetStore</p>
<ul>
<li>clone之后，运行的时候需要注意：resource目录的目录类型没有同步为resource root，导致运行项目的时候spring容器无法识别，导致application.properties中的很多属性无法被正常提取，所以无法运行。<a href="https://blog.csdn.net/weixin_43433898/article/details/118053332">参考博客</a></li>
</ul>
<h3 id="运行项目-newpetstore---前后端分离-nuxtjsspring-boot">运行项目 NewPetStore - 前后端分离 Nuxt.js+Spring boot</h3>
<p>前端项目地址：https://github.com/junyussh/newpetstore_frontend</p>
<p>后端项目地址：https://github.com/junyussh/New-JPetstore</p>
<ul>
<li>出现问题：查看某个product的时候在数据库中找不到这个内容=&gt;出现‘【MYSQL】java.sql.SQLSyntaxErrorException: Unknown column ‘id‘ in ‘where clause‘’，也就是在product列表，点击一个对应的product</li>
</ul>
<h3 id="运行项目-unifit---前后端分离-nuxtjsspring-boot">运行项目 Unifit - 前后端分离 Nuxt.js+Spring boot</h3>
<p>前端项目地址：https://github.com/junyussh/UniFit_frontend</p>
<p>后端项目地址：https://github.com/junyussh/UniFit</p>
<ul>
<li>出现问题：在配置Nuxt.js的时候，在<code>npm install</code>，报错lodash安装不成功，通过<code>npm install lodash</code>，然后再执行<code>npm install</code>，最后<code>npm run dev</code>即可</li>
</ul>

		</section>

		<div class="meta">Posted on Apr 8, 2020</div>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/java">Java</a></li>
					
					<li><a href="/tags/web">Web</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
	
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2022  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
