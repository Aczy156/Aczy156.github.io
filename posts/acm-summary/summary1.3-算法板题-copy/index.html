<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Summary1.3 算法板题 - Aczy156</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta property="og:description" content="" />
	<meta name="twitter:description" content="" />
	<meta name="description" content="" />
	<meta name="description" content="" />

	<meta property="og:title" content="Summary1.3 算法板题 | Aczy156" />
	<meta name="twitter:title" content="Summary1.3 算法板题 | Aczy156" />

	<meta property="og:image" content=""/>
	<meta itemprop="name" content="Summary1.3 算法板题 | Aczy156" />
	<meta name="application-name" content="Summary1.3 算法板题 | Aczy156" />
	<meta property="og:site_name" content="" />
	<meta property="og:title" content="Summary1.3 算法板题" />
<meta property="og:description" content="[TOC]
算法模版 背包DP-01背包 for (int i = 0; i &lt; m; &#43;&#43;i) for (int j = t; j &gt;= c[i] ; --j) dp[j] = max(dp[j], dp[j-c[i]]&#43;val[i]); 背包DP-多重背包 for (int i = 1; i &lt;= n; &#43;&#43;i) for (int j = w; j &gt;= c[i]; --j) for (int k = 1; k &lt;= num[i] &amp;&amp; k*c[i]&lt;=j; &#43;&#43;k) dp[j] = max(dp[j], dp[j-k*c[i]]&#43;k*val[i]); 背包DP-多重背包二进制加速 类似于快速幂的思路，对首先将多重背包拍平成01背包，然后再跑01，将跑01的过程用快速幂加速。
int n, m ,ta, tb ,tc, c[maxn], val[maxn], idx = 0, dp[maxn]; int main() { scanf(&#34;%d%d&#34;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; &#43;&#43;i) { scanf(&#34;%d%d%d&#34;, &amp;ta, &amp;tb, &amp;tc); for (int j = 1; j &lt;= tc; j&lt;&lt;=1) { c[&#43;&#43;idx] = tb*j; val[idx] = ta*j; tc-=j; } if (tc) {c[&#43;&#43;idx] = tb*tc;val[idx] = ta*tc;} } for (int i = 1; i &lt;= idx; &#43;&#43;i) for (int j = m; j &gt;= c[i]; --j) dp[j] = max(dp[j], dp[j-c[i]]&#43;val[i]); printf(&#34;%d\n&#34;, dp[m]);} 区间DP-区间合并代价 题目大意：删除一段数组的数，代价为这个区间的左右端点值的差的绝对值*长度，求全部删去的最大代价。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://chenranfei.xyz/posts/acm-summary/summary1.3-%E7%AE%97%E6%B3%95%E6%9D%BF%E9%A2%98-copy/" />
<meta property="article:published_time" content="2020-02-04T16:12:46+08:00" />
<meta property="article:modified_time" content="2020-02-04T16:12:46+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Summary1.3 算法板题"/>
<meta name="twitter:description" content="[TOC]
算法模版 背包DP-01背包 for (int i = 0; i &lt; m; &#43;&#43;i) for (int j = t; j &gt;= c[i] ; --j) dp[j] = max(dp[j], dp[j-c[i]]&#43;val[i]); 背包DP-多重背包 for (int i = 1; i &lt;= n; &#43;&#43;i) for (int j = w; j &gt;= c[i]; --j) for (int k = 1; k &lt;= num[i] &amp;&amp; k*c[i]&lt;=j; &#43;&#43;k) dp[j] = max(dp[j], dp[j-k*c[i]]&#43;k*val[i]); 背包DP-多重背包二进制加速 类似于快速幂的思路，对首先将多重背包拍平成01背包，然后再跑01，将跑01的过程用快速幂加速。
int n, m ,ta, tb ,tc, c[maxn], val[maxn], idx = 0, dp[maxn]; int main() { scanf(&#34;%d%d&#34;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; &#43;&#43;i) { scanf(&#34;%d%d%d&#34;, &amp;ta, &amp;tb, &amp;tc); for (int j = 1; j &lt;= tc; j&lt;&lt;=1) { c[&#43;&#43;idx] = tb*j; val[idx] = ta*j; tc-=j; } if (tc) {c[&#43;&#43;idx] = tb*tc;val[idx] = ta*tc;} } for (int i = 1; i &lt;= idx; &#43;&#43;i) for (int j = m; j &gt;= c[i]; --j) dp[j] = max(dp[j], dp[j-c[i]]&#43;val[i]); printf(&#34;%d\n&#34;, dp[m]);} 区间DP-区间合并代价 题目大意：删除一段数组的数，代价为这个区间的左右端点值的差的绝对值*长度，求全部删去的最大代价。"/>
<script src="http://chenranfei.xyz/js/feather.min.js"></script>
	
	<link href="http://chenranfei.xyz/css/fonts.css" rel="stylesheet">
	
	<link rel="stylesheet" type="text/css" media="screen" href="http://chenranfei.xyz/css/main.css" />
	
	
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
        messageStyle: "none", // 載入 MathJax 檔案時不要顯示訊息
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} // 搜尋內文 $ 符號
      });
</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://chenranfei.xyz/">Aczy156</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<aside>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#算法模版">算法模版</a>
      <ul>
        <li><a href="#背包dp-01背包">背包DP-01背包</a></li>
        <li><a href="#背包dp-多重背包">背包DP-多重背包</a></li>
        <li><a href="#背包dp-多重背包二进制加速">背包DP-多重背包二进制加速</a></li>
        <li><a href="#区间dp-区间合并代价">区间DP-区间合并代价</a></li>
        <li><a href="#区间dp-环形区间合并代价">区间DP-环形区间合并代价</a></li>
        <li><a href="#树形dp-子树和">树形DP-子树和</a></li>
        <li><a href="#树形dp-依赖关系子树和">树形DP-依赖关系子树和</a></li>
        <li><a href="#树形dp-依赖关系背包和">树形DP-依赖关系背包和</a></li>
        <li><a href="#线性dp-lis-单个序列最大递增子序列">线性DP-LIS 单个序列最大递增子序列</a></li>
        <li><a href="#线性dp-lcs-两个序列之间最长公共相同序列">线性DP-LCS 两个序列之间最长公共相同序列</a></li>
        <li><a href="#回文dp-判断最长回文串">回文DP-判断最长回文串</a></li>
        <li><a href="#回文dp-最小删除次数使字串为回文串">回文DP-最小删除次数使字串为回文串</a></li>
        <li><a href="#二维dp-01坐标系中最大正方形">二维DP-01坐标系中最大正方形</a></li>
        <li><a href="#排序-逆序对数最少相邻交换次数">排序-逆序对数，最少相邻交换次数</a></li>
        <li><a href="#并查集-给定处于相同集合的元素关系元素是否在同一集合有多少集合">并查集-给定处于相同集合的元素关系，元素是否在同一集合，有多少集合</a></li>
        <li><a href="#并查集-给定处于敌对集合的元素关系敌对集合">并查集-给定处于敌对集合的元素关系，敌对集合</a></li>
        <li><a href="#字符串-trie树动态不断查询返回当前查询是否是第一次出现或者重复出现">字符串-trie树，动态不断查询，返回当前查询是否是第一次出现或者重复出现</a></li>
        <li><a href="#bfs-最短步数路径">bfs-最短步数、路径</a></li>
        <li><a href="#dfs-记忆化搜索重复调用函数进行记录防止tle">dfs-记忆化搜索，重复调用函数，进行记录防止tle</a></li>
        <li><a href="#dfs-记忆话搜索固定变量不同的数值组合">dfs-记忆话搜索，固定变量不同的数值组合</a></li>
        <li><a href="#dfs-记忆话搜索前面dfs输出所有组合数">DFS-记忆话搜索，前面DFS输出所有组合数</a></li>
        <li><a href="#dfs-记忆话搜索组合数小于等于4个数平方的和-组合成目标数-的方案总和">DFS-记忆话搜索，组合数【小于等于4个数平方的和 组合成目标数】 的方案总和</a></li>
        <li><a href="#dfs-记忆话搜索组合数不限个数-组合成目标数的方案总和">DFS-记忆话搜索，组合数【不限个数 组合成目标数】的方案总和</a></li>
        <li><a href="#dfs-记忆话搜索地图中最长的路线">DFS-记忆话搜索，地图中最长的路线</a></li>
        <li><a href="#数论-获取唯一的奇数个的不匹配的数--找未配上的对">数论-获取唯一的奇数个的不匹配的数 & 找未配上的对</a></li>
        <li><a href="#数论-获取唯一的出现偶数次数的--找配上对的">数论-获取唯一的出现偶数次数的 & 找配上对的</a></li>
        <li><a href="#数论-区间中可以用平方差计算得到的个数">数论-区间中可以用平方差计算得到的个数</a></li>
        <li><a href="#数论-第二类stirling数">数论-第二类Stirling数</a></li>
        <li><a href="#数论-第二类stirling数的变形">数论-第二类Stirling数的变形</a></li>
        <li><a href="#数论-线性素数筛高效率达标素数">数论-线性素数筛，高效率达标素数</a></li>
        <li><a href="#数据结构-st表rmq区间最小最大值rangeminmaxquery包含最大与最小">数据结构-ST表，RMQ，区间最小最大值RangeMinMaxQuery，包含最大与最小</a></li>
        <li><a href="#数据结构-st表rgcd区间最小公倍数可重复贡献">数据结构-ST表，RGCD，区间最小公倍数，可重复贡献</a></li>
        <li><a href="#二叉树-哈夫曼编码">二叉树-哈夫曼编码</a></li>
        <li><a href="#二叉搜索树">二叉搜索树</a></li>
        <li><a href="#二叉链表">二叉链表</a></li>
        <li><a href="#二叉树建树---节点值做索引表示">二叉树建树 - 节点值做索引表示</a></li>
        <li><a href="#二叉树----节点值做索引-搜索深度">二叉树 -  节点值做索引 搜索深度</a></li>
        <li><a href="#二叉树的前序-中序-后序-dfs序等性质--给出前后求中序">二叉树的前序 中序 后序 dfs序等性质 // 【给出前后，求中序】</a></li>
        <li><a href="#二叉树的前序-中序-后序-dfs序等性质--给出中序前后中的一个求另一个">二叉树的前序 中序 后序 dfs序等性质 // 【给出中序+前后中的一个，求另一个】</a></li>
        <li><a href="#树状数组-模版-区间求和查询单点修改操作">树状数组-模版-区间求和(查询)、单点修改(操作)</a></li>
        <li><a href="#树状数组-模版-区间修改操作单点求和查询">树状数组-模版-区间修改(操作)、单点求和(查询)</a></li>
        <li><a href="#树状数组-模版-区间修改操作区间求和查询">树状数组-模版-区间修改(操作)、区间求和(查询)</a></li>
        <li><a href="#图论-lca最近公公祖先">图论-LCA最近公公祖先</a></li>
        <li><a href="#图论-起终点一样权值和为0floyd算法">图论-起终点一样，权值和为0，floyd算法</a></li>
        <li><a href="#图论-floyd---传递闭包">图论-Floyd - 传递闭包</a></li>
        <li><a href="#heading"></a></li>
        <li><a href="#heading-1"></a></li>
      </ul>
    </li>
  </ul>
</nav>
    </aside>
	<article>
		<div class="title">
			<h1 class="title">Summary1.3 算法板题</h1>
		</div>
		

		<section class="body">
			<p>[TOC]</p>
<h2 id="算法模版">算法模版</h2>
<h3 id="背包dp-01背包">背包DP-01背包</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> t; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i] ; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
</code></pre></div><h3 id="背包dp-多重背包">背包DP-多重背包</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> w; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> num[i] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> k<span style="color:#f92672">*</span>c[i]<span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span>j; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>c[i]]<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>val[i]);
</code></pre></div><h3 id="背包dp-多重背包二进制加速">背包DP-多重背包二进制加速</h3>
<p>类似于快速幂的思路，对首先将多重背包拍平成01背包，然后再跑01，将跑01的过程用快速幂加速。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, m ,ta, tb ,tc, c[maxn], val[maxn], idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dp[maxn];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> tc; j<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) {
            c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tb<span style="color:#f92672">*</span>j; val[idx] <span style="color:#f92672">=</span> ta<span style="color:#f92672">*</span>j;
            tc<span style="color:#f92672">-</span><span style="color:#f92672">=</span>j;
        }
        <span style="color:#66d9ef">if</span> (tc) {c[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>idx] <span style="color:#f92672">=</span> tb<span style="color:#f92672">*</span>tc;val[idx] <span style="color:#f92672">=</span> ta<span style="color:#f92672">*</span>tc;}
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> idx; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> m; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> c[i]; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>c[i]]<span style="color:#f92672">+</span>val[i]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[m]);}
</code></pre></div><h3 id="区间dp-区间合并代价">区间DP-区间合并代价</h3>
<p>题目大意：删除一段数组的数，代价为这个区间的左右端点值的差的绝对值*长度，求全部删去的最大代价。</p>
<p>区间DP的水题，维护一个dp二维数组，然后三层遍历左右端点+中间割点，利用状态转移方程<code>dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])</code>即可。</p>
<p>注意：要上来初始化一下，初始化的值就是运算法则算出来的，而dp所做的就是排列组合来搜索组合。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
<span style="color:#66d9ef">int</span> n, a[maxn], dp[maxn][maxn]; <span style="color:#75715e">// dp[i][j] 表示区间[i, j]所获得的最大价值
</span><span style="color:#75715e"></span><span style="color:#75715e">// dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]);
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; l<span style="color:#f92672">+</span>i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>l)
            <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) dp[i][i<span style="color:#f92672">+</span>l] <span style="color:#f92672">=</span> a[i];
            <span style="color:#66d9ef">else</span> dp[i][i<span style="color:#f92672">+</span>l] <span style="color:#f92672">=</span> abs(a[i]<span style="color:#f92672">-</span>a[i<span style="color:#f92672">+</span>l])<span style="color:#f92672">*</span>(l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> j; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
                dp[i][j] <span style="color:#f92672">=</span> max(dp[i][j], dp[i][k]<span style="color:#f92672">+</span>dp[k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[<span style="color:#ae81ff">1</span>][n]);}
</code></pre></div><h3 id="区间dp-环形区间合并代价">区间DP-环形区间合并代价</h3>
<p>题目大意：环形的一圈石子，合并相邻的两个，得到最大的和最小的合并代价。</p>
<p>1、不可以用贪心，因为贪心出来的话，不能确定选取的那最小的两个是相邻的，因为题目要求只能合并最小的两个</p>
<p>2、把环形拆解成链状，也就是转换成了第一个问题，线性的问题。 =&gt; 通过延长到2倍的长度。思路类似于原来的并查集的对立集，也是将数组长度延长到了两倍</p>
<p>3、遍历次序：通过先遍历长度，然后再遍历左索引i，从而得到右索引j，就得到一个区间<code>(i, i+len-1)</code>，然后再在区间中遍历k，也就是分割点即可。<code>dp_max[i][j] = max(dp_max[i][j], dp_max[i][k]+dp_max[k+1][j]+cost(i, j));</code></p>
<p>4、代价计算：通过前缀和来维护，或者直接用区间来算出来。<code>sum[i][j]</code>表示合并区间的代价</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, a[maxn], sum[maxn][maxn], dp_min[maxn][maxn], dp_max[maxn][maxn], ans_min <span style="color:#f92672">=</span> INF, ans_max;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);a[i<span style="color:#f92672">+</span>n] <span style="color:#f92672">=</span> a[i];}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> j; k<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
                sum[i][j] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> a[k];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) dp_min[i][i] <span style="color:#f92672">=</span> dp_max[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; len <span style="color:#f92672">&lt;</span> n; len<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>len; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>, j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> len) {
            dp_min[i][j] <span style="color:#f92672">=</span> INF;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span> j; k<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
                dp_max[i][j] <span style="color:#f92672">=</span> max(dp_max[i][j], dp_max[i][k] <span style="color:#f92672">+</span> dp_max[k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> sum[i][j]);
                dp_min[i][j] <span style="color:#f92672">=</span> min(dp_min[i][j], dp_min[i][k] <span style="color:#f92672">+</span> dp_min[k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> sum[i][j]);
            }
        }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {ans_min <span style="color:#f92672">=</span> min(ans_min, dp_min[i][i<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);ans_max <span style="color:#f92672">=</span> max(ans_max, dp_max[i][i<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);}
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans_min, ans_max); }
</code></pre></div><h3 id="树形dp-子树和">树形DP-子树和</h3>
<p>题目大意：获取该棵树中最大的子树和</p>
<p>对于该题：数据结构：链式前向星储存，然后通过维护一个<code>dp[i]</code>数组，表示第i个节点为根的子树的最大和。dp状态转移方程：<code>dp[x] = max(dp[x], dp[x]+dp[to]);</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, dp[maxn], in[maxn], ta, tb;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> to, next;
}edges[maxn<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>];<span style="color:#66d9ef">int</span> head[maxn], tot;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to) {
    edges[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to;    edges[tot].next <span style="color:#f92672">=</span> head[from];    head[from] <span style="color:#f92672">=</span> tot;    in[to]<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tree_dp</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i<span style="color:#f92672">=</span>edges[i].next) {
        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[i].to;
        tree_dp(to);
        dp[x] <span style="color:#f92672">=</span> max(dp[x], dp[x]<span style="color:#f92672">+</span>dp[to]);   }}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, dp<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);
        addedge(tb, ta);}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>in[i]) {
            tree_dp(i);
            printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[i]);        }}
</code></pre></div><h3 id="树形dp-依赖关系子树和">树形DP-依赖关系子树和</h3>
<p>题目大意：没有上司的晚会，某个节点出现的条件是上下节点不出现。（在树上体现出来就是上下不相邻），如何挑选树上节点使得快乐值最大</p>
<p>对于该题：数据结构：链式前向星储存，然后通过维护一个<code>dp[i][j]</code>数组，在<code>i=0</code>表示不取当前这个节点的时候所获的的值 <code>i=1</code>表示取这个节点所获得的值；dp状态转移方程：<code>dp[0][x] += max(dp[0][to], dp[1][to]);</code> <code>dp[1][x] += dp[0][to];</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, dp[<span style="color:#ae81ff">5</span>][maxn], in[maxn], ta, tb;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> to, next;
}edges[maxn<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>];<span style="color:#66d9ef">int</span> head[maxn], tot;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to) {
    edges[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to;    edges[tot].next <span style="color:#f92672">=</span> head[from];    head[from] <span style="color:#f92672">=</span> tot;    in[to]<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tree_dp</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i<span style="color:#f92672">=</span>edges[i].next) {
        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[i].to;        tree_dp(to);        dp[<span style="color:#ae81ff">1</span>][x] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>][to];
        dp[<span style="color:#ae81ff">0</span>][x] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> max(dp[<span style="color:#ae81ff">1</span>][to], dp[<span style="color:#ae81ff">0</span>][to]);    }}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>dp[<span style="color:#ae81ff">1</span>][i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);
        addedge(tb, ta);}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>in[i]) {tree_dp(i);printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, max(dp[<span style="color:#ae81ff">0</span>][i],dp[<span style="color:#ae81ff">1</span>][i]));}}
</code></pre></div><h3 id="树形dp-依赖关系背包和">树形DP-依赖关系背包和</h3>
<p>题目大意：有先后关系，需要是一条树上的前后关联，然后问最大的和</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, dp[maxn][maxn], ta, tb, q;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> to, next;
}edges[maxn];<span style="color:#66d9ef">int</span> head[maxn], tot;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to) {
    edges[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to;    edges[tot].next <span style="color:#f92672">=</span> head[from];    head[from] <span style="color:#f92672">=</span> tot;}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tree_dp</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i<span style="color:#f92672">=</span>edges[i].next) {
        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[i].to;
        tree_dp(to);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> q<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>j)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> j; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
                dp[j][x] <span style="color:#f92672">=</span> max(dp[j][x], dp[k][to]<span style="color:#f92672">+</span>dp[j<span style="color:#f92672">-</span>k][x]);}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>q);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);
        dp[<span style="color:#ae81ff">1</span>][i] <span style="color:#f92672">=</span> tb;
        addedge(ta, i);
    }
    tree_dp(<span style="color:#ae81ff">0</span>);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[q<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]);}
</code></pre></div><h3 id="线性dp-lis-单个序列最大递增子序列">线性DP-LIS 单个序列最大递增子序列</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#66d9ef">int</span> n, a[maxn], dp[maxn], ans; <span style="color:#75715e">// dp[i]表示到i之前的最长递增序列 // 状态转移方程：dp[j] = max
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        dp[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> i; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">&gt;</span> a[j]) dp[i] <span style="color:#f92672">=</span> max(dp[i], dp[j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
            ans <span style="color:#f92672">=</span> max(ans, dp[i]);}
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);}
</code></pre></div><h3 id="线性dp-lcs-两个序列之间最长公共相同序列">线性DP-LCS 两个序列之间最长公共相同序列</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, a[maxn], b[maxn], dp[maxn][maxn]; <span style="color:#75715e">//dp[i][j] i是在第一个串中的索引的位置，j是第二个串中的索引的位置
</span><span style="color:#75715e"></span><span style="color:#75715e">// 状态转移方程：dp[i][j] = a[i] == a[j] ? dp[i-1][j-1]:max(dp[i-1][j], dp[i][j-1]);
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>b[i]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            dp[i][j] <span style="color:#f92672">=</span> (a[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> b[j] <span style="color:#f92672">?</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>max(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]));
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dp[n][n]);}
</code></pre></div><h3 id="回文dp-判断最长回文串">回文DP-判断最长回文串</h3>
<ul>
<li><code>bool dp[i][j]</code>表示从[i,j]这一段是否为回文串</li>
<li>状态转移方程：<code>dp[i][j] = (s[i] == s[j] &amp;&amp; (j-i == 1||dp[i+1]dp[j-1]))?true:false   (j &gt; i)</code></li>
<li>j-i == 1 是对aa这种两个字符呈对称形式的情况</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> strlen(s),ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#66d9ef">bool</span> dp[len][len];
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) dp[i][i] <span style="color:#f92672">=</span> true;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> len; j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> j; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> s[j] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> (j<span style="color:#f92672">-</span>i <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])) {dp[i][j] <span style="color:#f92672">=</span> true;ans <span style="color:#f92672">=</span> max(ans,j<span style="color:#f92672">-</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);}
        <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> false;
printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,ans);
</code></pre></div><h3 id="回文dp-最小删除次数使字串为回文串">回文DP-最小删除次数使字串为回文串</h3>
<ul>
<li>dp[i][j]表示区间[i,j]的最少抽取次数</li>
<li>状态转移方程<code> if (s[i] == s[j]) dp[i][j] = (j-i == 1)?1:dp[i+1][j-1]</code>
<code>dp[i][j] = min(dp[i][k]+dp[k+1][j],dp[i][j]) </code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> dp[maxn][maxn],a[maxn];     <span style="color:#75715e">//dp[i][j]表示i-j这段区间合并所需要的次数      a是储存的原来的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n,len,i,j,k;   <span style="color:#75715e">//j是起点加上重点的位置，然后k是这段区间中第一段分割的长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">&amp;</span>n);    cl(dp, INF);
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">&amp;</span>a[i]);dp[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;}
    <span style="color:#66d9ef">for</span> (len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; len <span style="color:#f92672">&lt;</span> n; len<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)   <span style="color:#75715e">//先遍历长度，在遍历起点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">+</span>len <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
            j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>len;
            <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> a[j]) dp[i][j] <span style="color:#f92672">=</span> len <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">?</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">for</span> (k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span> j; k<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) dp[i][j] <span style="color:#f92672">=</span> min(dp[i][k]<span style="color:#f92672">+</span>dp[k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j],dp[i][j]);}   <span style="color:#75715e">//从中间找切断点k
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>dp[<span style="color:#ae81ff">1</span>][n]<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl;}
</code></pre></div><h3 id="二维dp-01坐标系中最大正方形">二维DP-01坐标系中最大正方形</h3>
<p>首先每个坐标都是变长为1的正方形，然后进行状态转换的话要根据i-1,j-1/i,j-1/i-1,j这三个点进行转移（并且需要满足合成正方形的条件才可以转移），从而得到0～当前点范围内的最大正方形。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, m, a[maxn][maxn], dp[maxn][maxn], ans; <span style="color:#75715e">// dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i][j]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            <span style="color:#66d9ef">if</span> (a[i][j]) dp[i][j] <span style="color:#f92672">=</span> min(min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]), dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j])<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) ans <span style="color:#f92672">=</span> max(ans, dp[i][j]);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);}
</code></pre></div><h3 id="排序-逆序对数最少相邻交换次数">排序-逆序对数，最少相邻交换次数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, a[maxn], t[maxn], tidx, lidx, ridx; ll ans;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mergesort</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){
    <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">&gt;</span> l) {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>;        mergesort(l, mid);        mergesort(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, r);
        tidx <span style="color:#f92672">=</span> lidx <span style="color:#f92672">=</span> l, ridx <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> (lidx <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> mid <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> ridx <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> r) {
            <span style="color:#66d9ef">if</span> (a[lidx] <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> a[ridx]) t[tidx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>] <span style="color:#f92672">=</span> a[lidx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>];
            <span style="color:#66d9ef">else</span> t[tidx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>] <span style="color:#f92672">=</span> a[ridx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>], ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> (mid<span style="color:#f92672">-</span>lidx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);        }
        <span style="color:#66d9ef">while</span> (lidx <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> mid) t[tidx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>] <span style="color:#f92672">=</span> a[lidx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>];
        <span style="color:#66d9ef">while</span> (ridx <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> r) t[tidx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>] <span style="color:#f92672">=</span> a[ridx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>];
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> r; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) a[i] <span style="color:#f92672">=</span> t[i];}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a<span style="color:#f92672">+</span>i);
    mergesort(<span style="color:#ae81ff">1</span>, n);    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);}
</code></pre></div><h3 id="并查集-给定处于相同集合的元素关系元素是否在同一集合有多少集合">并查集-给定处于相同集合的元素关系，元素是否在同一集合，有多少集合</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, m, p, fa[maxn], ta, tb;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findfa</span>(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> fa[x] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> x<span style="color:#f92672">?</span>x:findfa(fa[x]);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>p);    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) fa[i]<span style="color:#f92672">=</span>i;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);
        <span style="color:#66d9ef">if</span> (findfa(ta) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> findfa(tb)) fa[findfa(tb)] <span style="color:#f92672">=</span> findfa(ta);}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> p; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);
        <span style="color:#66d9ef">if</span> (findfa(ta) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> findfa(tb)) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">No</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);<span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Yes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);}  
  	<span style="color:#75715e">// 集合个数
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">if</span> (fa[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> i) cnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>; printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cnt<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">// cnt即为集合个数}
</span></code></pre></div><h3 id="并查集-给定处于敌对集合的元素关系敌对集合">并查集-给定处于敌对集合的元素关系，敌对集合</h3>
<p>关键：敌对的敌对是朋友。运用反集解决。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, m, fa[maxn], ta, tb, cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">char</span> ch;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findfa</span>(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> fa[x]<span style="color:#f92672">=</span><span style="color:#f92672">=</span>x<span style="color:#f92672">?</span>x:findfa(fa[x]);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) fa[i] <span style="color:#f92672">=</span> i;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        cin<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>ch<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>ta<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>tb;
        <span style="color:#66d9ef">if</span> (ch <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">F</span><span style="color:#e6db74">&#39;</span>){
            fa[findfa(ta)] <span style="color:#f92672">=</span> findfa(tb);
        } <span style="color:#66d9ef">else</span>{
            fa[findfa(ta<span style="color:#f92672">+</span>n)] <span style="color:#f92672">=</span> findfa(tb);
            fa[findfa(tb<span style="color:#f92672">+</span>n)] <span style="color:#f92672">=</span> findfa(ta);}}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">if</span> (fa[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> i) cnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>; printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, cnt);}
</code></pre></div><h3 id="字符串-trie树动态不断查询返回当前查询是否是第一次出现或者重复出现">字符串-trie树，动态不断查询，返回当前查询是否是第一次出现或者重复出现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">trie</span> {
    <span style="color:#66d9ef">int</span> nex[maxn][<span style="color:#ae81ff">26</span>], cnt; <span style="color:#66d9ef">int</span> exist[maxn]; <span style="color:#75715e">// 0 没出现；1 第一出现；2 重复出现
</span><span style="color:#75715e"></span> 		<span style="color:#66d9ef">int</span> val[maxn]; <span style="color:#75715e">// -1 查不到这个人的对应的值
</span><span style="color:#75715e"></span>  	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s) {
        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, l <span style="color:#f92672">=</span> strlen(s);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> l; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#39;</span>;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nex[p][c]) nex[p][c] <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#f92672">+</span>cnt;
            p <span style="color:#f92672">=</span> nex[p][c];}<span style="color:#75715e">// 修改val数组 }        
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> find(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s) {
        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, l <span style="color:#f92672">=</span> strlen(s);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> l; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#39;</span>;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nex[p][c]) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            p <span style="color:#f92672">=</span> nex[p][c];}
      	<span style="color:#75715e">// 修改exist数组的地方
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>exist[p]) {exist[p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;} <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>; }
  	<span style="color:#66d9ef">int</span> getvalue(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s) {
        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, l <span style="color:#f92672">=</span> strlen(s);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> l; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#39;</span>; <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nex[p][c]) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; p <span style="color:#f92672">=</span> nex[p][c];}
        <span style="color:#66d9ef">return</span> val[p];}
}tree;
<span style="color:#66d9ef">int</span> n, m; <span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">55</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) { scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span>, s); tree.insert(s);}
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span>, s);
        <span style="color:#66d9ef">switch</span> (tree.find(s)) {
        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">WRONG</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);<span style="color:#66d9ef">break</span>; <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);<span style="color:#66d9ef">break</span>; <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span> printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">REPEAT</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);<span style="color:#66d9ef">break</span>;}}}
</code></pre></div><h3 id="bfs-最短步数路径">bfs-最短步数、路径</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> mp[maxn][maxn], vis[maxn][maxn], dir[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}}, ansx[<span style="color:#ae81ff">300</span>], ansy[<span style="color:#ae81ff">300</span>], idx;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span>{<span style="color:#66d9ef">int</span> x, y;node <span style="color:#f92672">*</span> fa;node(){}node(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, node <span style="color:#f92672">*</span> fa)<span style="color:#f92672">:</span> x(x), y(y), fa(fa){}};
queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> q;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printTrace</span>(node nw){
    ansx[idx] <span style="color:#f92672">=</span> nw.x;ansy[idx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>] <span style="color:#f92672">=</span> nw.y;node <span style="color:#f92672">*</span> nt <span style="color:#f92672">=</span> nw.fa;
    <span style="color:#66d9ef">while</span> (nt<span style="color:#f92672">!</span><span style="color:#f92672">=</span>NULL) { ansx[idx] <span style="color:#f92672">=</span> nt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>x;ansy[idx<span style="color:#f92672">+</span><span style="color:#f92672">+</span>] <span style="color:#f92672">=</span> nt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>y; nt <span style="color:#f92672">=</span> nt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>fa;}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> idx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>i) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">(%d, %d)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,ansx[i], ansy[i]);}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    q.push(node(x, y, NULL));
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
        node nw <span style="color:#f92672">=</span> q.front();
        <span style="color:#66d9ef">if</span> (nw.x <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nw.y <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>) {printTrace(nw);<span style="color:#66d9ef">return</span>;}
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
            <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> nw.x<span style="color:#f92672">+</span>dir[i][<span style="color:#ae81ff">0</span>], ny <span style="color:#f92672">=</span> nw.y<span style="color:#f92672">+</span>dir[i][<span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> ny <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>) {printTrace(node(nx, ny, <span style="color:#f92672">&amp;</span>nw));<span style="color:#66d9ef">return</span>;}
            <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> ny <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> <span style="color:#f92672">!</span>mp[nx][ny] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> <span style="color:#f92672">!</span>vis[nx][ny]) {
                vis[nx][ny] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; q.push(node(nx, ny, <span style="color:#f92672">&amp;</span>q.front()));}}
        q.pop();}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>mp[i][j]);
    bfs(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>); }
</code></pre></div><h3 id="dfs-记忆化搜索重复调用函数进行记录防止tle">dfs-记忆化搜索，重复调用函数，进行记录防止tle</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ll ta, tb, tc, dp[maxn][maxn][maxn];
ll <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c) {
    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> b <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> c <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> b <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> c <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">return</span> dfs(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">20</span>);
    <span style="color:#66d9ef">if</span> (dp[a][b][c])  <span style="color:#66d9ef">return</span> dp[a][b][c];
    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&lt;</span> b <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> b <span style="color:#f92672">&lt;</span> c) <span style="color:#66d9ef">return</span> dp[a][b][c] <span style="color:#f92672">=</span> dfs(a, b, c<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> dfs(a, b<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, c<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> dfs(a, b<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, c);
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> dp[a][b][c] <span style="color:#f92672">=</span> dfs(a<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, b, c) <span style="color:#f92672">+</span> dfs(a<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, b<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, c) <span style="color:#f92672">+</span> dfs(a<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, b, c<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> dfs(a<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, b<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, c<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">while</span> (scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld%lld%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc) <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> <span style="color:#f92672">!</span>(ta<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> tb<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> tc<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
      printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">w(%lld, %lld, %lld) = %lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ta, tb, tc, dfs(ta, tb, tc));}
</code></pre></div><h3 id="dfs-记忆话搜索固定变量不同的数值组合">dfs-记忆话搜索，固定变量不同的数值组合</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> a, b, c, na, nb, nc, vis[<span style="color:#ae81ff">25</span>];<span style="color:#66d9ef">int</span> v[<span style="color:#ae81ff">25</span>][<span style="color:#ae81ff">25</span>][<span style="color:#ae81ff">25</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, <span style="color:#66d9ef">int</span> z) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>x <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> <span style="color:#f92672">!</span>vis[z]) vis[z] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;    <span style="color:#66d9ef">if</span> (v[x][y][z]) <span style="color:#66d9ef">return</span>;
    v[x][y][z] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (x) {<span style="color:#66d9ef">if</span> (y <span style="color:#f92672">&lt;</span> b) {
            <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> b<span style="color:#f92672">-</span>y) dfs(x<span style="color:#f92672">-</span>(b<span style="color:#f92672">-</span>y), b, z);
            <span style="color:#66d9ef">else</span> dfs(<span style="color:#ae81ff">0</span>, y<span style="color:#f92672">+</span>x, z);}
        <span style="color:#66d9ef">if</span> (z <span style="color:#f92672">&lt;</span> c) {
          	<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> c<span style="color:#f92672">-</span>z) dfs(x<span style="color:#f92672">-</span>(c<span style="color:#f92672">-</span>z), y, c);
            <span style="color:#66d9ef">else</span> dfs(<span style="color:#ae81ff">0</span>, y, z<span style="color:#f92672">+</span>x);}}
    <span style="color:#66d9ef">if</span> (y) {<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> a) {
            <span style="color:#66d9ef">if</span> (y <span style="color:#f92672">&gt;</span> a<span style="color:#f92672">-</span>x) dfs(a, y<span style="color:#f92672">-</span>(a<span style="color:#f92672">-</span>x), z);
            <span style="color:#66d9ef">else</span> dfs(x<span style="color:#f92672">+</span>y, <span style="color:#ae81ff">0</span>, z);}
        <span style="color:#66d9ef">if</span> (z <span style="color:#f92672">&lt;</span> c) {
            <span style="color:#66d9ef">if</span> (y <span style="color:#f92672">&gt;</span> c<span style="color:#f92672">-</span>z) dfs(x, y<span style="color:#f92672">-</span>(c<span style="color:#f92672">-</span>z), c);
            <span style="color:#66d9ef">else</span> dfs(x, <span style="color:#ae81ff">0</span>, z<span style="color:#f92672">+</span>y);}}
    <span style="color:#66d9ef">if</span> (z) {<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> a) {
            <span style="color:#66d9ef">if</span> (z <span style="color:#f92672">&gt;</span> a<span style="color:#f92672">-</span>x) dfs(a, y, z<span style="color:#f92672">-</span>(a<span style="color:#f92672">-</span>x));
            <span style="color:#66d9ef">else</span> dfs(x<span style="color:#f92672">+</span>z, y, <span style="color:#ae81ff">0</span>);}
        <span style="color:#66d9ef">if</span> (y <span style="color:#f92672">&lt;</span> b) {
            <span style="color:#66d9ef">if</span> (z <span style="color:#f92672">&gt;</span> b<span style="color:#f92672">-</span>y) dfs(x, b, z<span style="color:#f92672">-</span>(b<span style="color:#f92672">-</span>y));
            <span style="color:#66d9ef">else</span> dfs(x, y<span style="color:#f92672">+</span>z, <span style="color:#ae81ff">0</span>);}}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b, <span style="color:#f92672">&amp;</span>c);na <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, nb <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, nc <span style="color:#f92672">=</span> c;vis[c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;dfs(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)<span style="color:#66d9ef">if</span> (vis[i]) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, i);}
</code></pre></div><h3 id="dfs-记忆话搜索前面dfs输出所有组合数">DFS-记忆话搜索，前面DFS输出所有组合数</h3>
<p>通过剪枝的方式，记录上一层的last，然后保证递增可以，也可以通过记忆话搜索给记录下来</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 首先初始化一下
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> total; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#75715e">// 遍历第一维度的时候就不会再涉及到初始化的那个维度，不然会覆盖掉
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> total; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
            dp[k][j] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dp[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>i];
</code></pre></div><h3 id="dfs-记忆话搜索组合数小于等于4个数平方的和-组合成目标数-的方案总和">DFS-记忆话搜索，组合数【小于等于4个数平方的和 组合成目标数】 的方案总和</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">*</span>i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> M; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#75715e">// 遍历第一维度的时候就不会再涉及到初始化的那个维度，不然会覆盖掉
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">*</span>i; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> M; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
            dp[k][j] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> dp[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>i<span style="color:#f92672">*</span>i];
</code></pre></div><h3 id="dfs-记忆话搜索组合数不限个数-组合成目标数的方案总和">DFS-记忆话搜索，组合数【不限个数 组合成目标数】的方案总和</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">dp[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> nn<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">&gt;</span> i) dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span>dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>i];
        <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j];
</code></pre></div><h3 id="dfs-记忆话搜索地图中最长的路线">DFS-记忆话搜索，地图中最长的路线</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> r, c, mp[maxn][maxn], dp[maxn][maxn], ans, dir[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}}; <span style="color:#75715e">// dp[i][j]这个点开始的最长连续下降的长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    <span style="color:#66d9ef">if</span> (dp[x][y]) <span style="color:#66d9ef">return</span> dp[x][y];
    dp[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> x<span style="color:#f92672">+</span>dir[i][<span style="color:#ae81ff">0</span>], ny <span style="color:#f92672">=</span> y<span style="color:#f92672">+</span>dir[i][<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nx <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> ny <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> ny <span style="color:#f92672">&lt;</span> c <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> mp[nx][ny] <span style="color:#f92672">&lt;</span> mp[x][y]){
            dfs(nx, ny);dp[x][y] <span style="color:#f92672">=</span> max(dp[x][y], dp[nx][ny]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);}}
    <span style="color:#66d9ef">return</span> dp[x][y];}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>r, <span style="color:#f92672">&amp;</span>c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> r; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> c; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>mp[i][j]);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> r; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> c; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) ans <span style="color:#f92672">=</span> max(ans, dfs(i, j));
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);}
</code></pre></div><h3 id="数论-获取唯一的奇数个的不匹配的数--找未配上的对">数论-获取唯一的奇数个的不匹配的数 &amp; 找未配上的对</h3>
<ul>
<li>思路一：数组存，然后排序，然后再遍历，两个两个遍历=&gt; 爆内存，爆时间。</li>
<li>思路二：map存，找到配对的删除。一边即过。=&gt; 6个点爆内存</li>
<li>正确思路：直接用一个变量，然后来异或<code>^</code>所有的数，a^a = 0，所以最后剩下的那个数就是没匹配的。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>t); ans <span style="color:#f92672">^</span><span style="color:#f92672">=</span> t;}
printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);    
</code></pre></div><h3 id="数论-获取唯一的出现偶数次数的--找配上对的">数论-获取唯一的出现偶数次数的 &amp; 找配上对的</h3>
<p>这个需要先把所有存在的数都输入进去，得到所有数的异或，然后再异或数组种的所有数，那么出现偶数次的就会显露出来了，出现单次的就会和第一次的异或掉了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>t);ans<span style="color:#f92672">^</span><span style="color:#f92672">=</span>t;}
scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>m);
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>t);ans<span style="color:#f92672">^</span><span style="color:#f92672">=</span>t;}
</code></pre></div><h3 id="数论-区间中可以用平方差计算得到的个数">数论-区间中可以用平方差计算得到的个数</h3>
<blockquote>
<p>题目大意：区间[a, b]中，某个数i，这个数i可以写成c^2-d^2</p>
</blockquote>
<p>正向数学推导：i=(c+d)(c-d)，那么c+d/c-d必定为同奇偶，同奇偶必定乘积要不满足是奇数，要不满足是4的倍数（因为是两个2的倍数相乘）。</p>
<p>反推验证：若i为奇数，也就是2k+1，那么可以找到c=k+1, d=k满足c+d=2k+1与c-d=1的乘积为2k+1这个条件。</p>
<p>若i为4的倍数，也就是4k，那么可以找到c=k+1, d=k-1满足c+d=2k与c-d=2的乘积是4k这个条件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> a; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> b; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
    <span style="color:#66d9ef">if</span> (i<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> <span style="color:#f92672">!</span>(i<span style="color:#f92672">%</span><span style="color:#ae81ff">4</span>)) ans<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
</code></pre></div><h3 id="数论-第二类stirling数">数论-第二类Stirling数</h3>
<p>数学意义：把n个数划分成k个集合</p>
<p>实际意义：将n个球分到k个相同的盒子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 递归写法
</span><span style="color:#75715e"></span>ll <span style="color:#a6e22e">stirling</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k){
    <span style="color:#66d9ef">if</span> (k<span style="color:#f92672">=</span><span style="color:#f92672">=</span>n <span style="color:#f92672">|</span><span style="color:#f92672">|</span> k<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (k<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> pow(<span style="color:#ae81ff">2</span>, (n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">1.0</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> stirling(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>stirling(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, k);
}
<span style="color:#75715e">// 非递归写法
</span><span style="color:#75715e"></span>
</code></pre></div><h3 id="数论-第二类stirling数的变形">数论-第二类Stirling数的变形</h3>
<p>数学意义：把n个数划分成k个不同的集合</p>
<p>实际意义：把n个球分到k个不同的盒子里</p>
<p>和第二类Stirling数的区别：就是划分出来的集合再进行容器的匹配，对于不同的集合划分到不同的容器中。匹配原则：Ann</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ll <span style="color:#a6e22e">stirling</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k){
    <span style="color:#66d9ef">if</span> (k<span style="color:#f92672">=</span><span style="color:#f92672">=</span>n <span style="color:#f92672">|</span><span style="color:#f92672">|</span> k<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (k<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> pow(<span style="color:#ae81ff">2</span>, (n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">1.0</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> stirling(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>stirling(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, k);
}
<span style="color:#75715e">// 排列数Ann
</span><span style="color:#75715e"></span>ll <span style="color:#a6e22e">factorial</span>(ll n) {
    ll fc <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (ll i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) fc <span style="color:#f92672">*</span><span style="color:#f92672">=</span> i;
    <span style="color:#66d9ef">return</span> fc;
}
</code></pre></div><h3 id="数论-线性素数筛高效率达标素数">数论-线性素数筛，高效率达标素数</h3>
<p>线性筛：O(n)</p>
<p>prime是质数列表，isprime</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">define maxn 10000010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> vis[maxn], prime[maxn], isprime[maxn];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Prime</span>()
{
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>; i<span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span>b; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
    {
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>vis[i]) prime[cnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>] <span style="color:#f92672">=</span> i, isprime[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>cnt<span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span>i<span style="color:#f92672">*</span>prime[j]<span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span>b; j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        {
            vis[i<span style="color:#f92672">*</span>prime[j]] <span style="color:#f92672">=</span> i;
            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span>prime[j]<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
        }
    }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">b <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>; <span style="color:#75715e">// 设置筛的边界
</span><span style="color:#75715e"></span>LPrime();
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d %d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, prime[i], isprime[i]); <span style="color:#75715e">// prime是按照顺序的素数存放进来， isprime是索引的数是否为质数
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="数据结构-st表rmq区间最小最大值rangeminmaxquery包含最大与最小">数据结构-ST表，RMQ，区间最小最大值<strong>R</strong>ange<strong>M</strong>inMax<strong>Q</strong>uery，包含最大与最小</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, m, a[maxn], maxx[maxn][<span style="color:#ae81ff">21</span>], minn[maxn][<span style="color:#ae81ff">21</span>], ta, tb;
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>() { <span style="color:#75715e">// 快速读取模版
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,f<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#66d9ef">char</span> ch<span style="color:#f92672">=</span>getchar(); <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>isdigit(ch)){<span style="color:#66d9ef">if</span> (ch<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">-</span><span style="color:#e6db74">&#39;</span>) f<span style="color:#f92672">=</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;ch<span style="color:#f92672">=</span>getchar();}
    <span style="color:#66d9ef">while</span> (isdigit(ch)){x<span style="color:#f92672">=</span>x<span style="color:#f92672">*</span><span style="color:#ae81ff">10</span><span style="color:#f92672">+</span>ch<span style="color:#f92672">-</span><span style="color:#ae81ff">48</span>;ch<span style="color:#f92672">=</span>getchar();} <span style="color:#66d9ef">return</span> x<span style="color:#f92672">*</span>f;}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {minn[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a[i]; maxx[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a[i];}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>j)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i){
            maxx[i][j] <span style="color:#f92672">=</span> max(maxx[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], maxx[i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>(j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
            minn[i][j] <span style="color:#f92672">=</span> min(minn[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], minn[i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>(j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query_max</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) { <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> log2(r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>); <span style="color:#66d9ef">return</span> max(maxx[l][k], maxx[r<span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>k)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][k]);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query_min</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) { <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> log2(r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>); <span style="color:#66d9ef">return</span> min(minn[l][k], minn[r<span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>k)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][k]);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    n <span style="color:#f92672">=</span> read();m <span style="color:#f92672">=</span> read(); <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) a[i] <span style="color:#f92672">=</span> read(); init();
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) { ta <span style="color:#f92672">=</span> read();tb <span style="color:#f92672">=</span> read(); printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, query_min(ta, tb), query_max(ta, tb));}}
</code></pre></div><h3 id="数据结构-st表rgcd区间最小公倍数可重复贡献">数据结构-ST表，RGCD，区间最小公倍数，可重复贡献</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, m, a[maxn], gcdd[maxn][<span style="color:#ae81ff">21</span>], ta, tb;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {<span style="color:#66d9ef">return</span> b<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">?</span>gcd(b, a<span style="color:#f92672">%</span>b)<span style="color:#f92672">:</span>a;}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) gcdd[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a[i];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>j)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) gcdd[i][j] <span style="color:#f92672">=</span> gcd(gcdd[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], gcdd[i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>(j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]); }
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query_gcd</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) { <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> log2(r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>); <span style="color:#66d9ef">return</span> gcd(gcdd[l][k], gcdd[r<span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>k)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][k]);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m); <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);init();
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) { scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb); printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, query_gcd(ta, tb));}}
</code></pre></div><h3 id="二叉树-哈夫曼编码">二叉树-哈夫曼编码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {    <span style="color:#66d9ef">int</span> data;    node <span style="color:#f92672">*</span>lchild;    node <span style="color:#f92672">*</span>rchild;} <span style="color:#f92672">*</span>huffmantree, huffman[maxn];
<span style="color:#66d9ef">int</span> n, ll, rr;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">nd</span> {    <span style="color:#66d9ef">int</span> val, idx;    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> nd n) <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> val <span style="color:#f92672">&gt;</span> n.val;}};
priority_queue<span style="color:#f92672">&lt;</span>nd, vector<span style="color:#f92672">&lt;</span>nd<span style="color:#f92672">&gt;</span>, less<span style="color:#f92672">&lt;</span>nd<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> pq;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreOrder</span>(node <span style="color:#f92672">*</span>T) {<span style="color:#66d9ef">if</span> (T) {cout <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>; PreOrder(T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild);PreOrder(T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);}}
node <span style="color:#f92672">*</span> <span style="color:#a6e22e">HuffmanTree</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j) pq.push({huffman[j].data, j});
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        ll <span style="color:#f92672">=</span> pq.top().idx;pq.pop();rr <span style="color:#f92672">=</span> pq.top().idx;pq.pop();
        node <span style="color:#f92672">*</span> lnode <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> node {huffman[ll].data, huffman[ll].lchild, huffman[ll].rchild};
        huffman[ll] <span style="color:#f92672">=</span> {huffman[ll].data <span style="color:#f92672">+</span> huffman[rr].data, lnode, <span style="color:#f92672">&amp;</span>huffman[rr]};
        pq.push({huffman[ll].data, ll});}
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>huffman[ll];}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>huffman[i].data);
    <span style="color:#75715e">// build tree
</span><span style="color:#75715e"></span>    huffmantree <span style="color:#f92672">=</span> HuffmanTree();PreOrder(huffmantree);}
</code></pre></div><h3 id="二叉搜索树">二叉搜索树</h3>
<p>性质情况一：左儿子小于父节点 &amp;&amp; 右儿子大于父节点 =&gt; 中序遍历得到递增序列情况二：左儿子大于父节点 &amp;&amp; 右儿子小于父节点 =&gt; 中序遍历得到递减序列</p>
<p>实现二叉链表实现，每添加一次新的值，就build一次，从根节点往下插入新的值;要插入的数比当前节点的值小=&gt;往左子树插入;要插入的数比当前节点的值大=&gt;往右子树插入;然后如果插到最底部了，当前这个节点直接NULL了，那就重新new一个这个要插入的数对应的节点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">nd</span> {<span style="color:#66d9ef">int</span> val, pri;    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> nd n) <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> pri <span style="color:#f92672">&lt;</span> n.pri;}}a[<span style="color:#ae81ff">35</span>];
<span style="color:#66d9ef">int</span> n, nwval, nwpri;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {    <span style="color:#66d9ef">int</span> val, pri;    node <span style="color:#f92672">*</span> l, <span style="color:#f92672">*</span>r;}<span style="color:#f92672">*</span> root;
node <span style="color:#f92672">*</span> <span style="color:#a6e22e">build</span>(node <span style="color:#f92672">*</span> nw) {
    <span style="color:#66d9ef">if</span> (nw <span style="color:#f92672">=</span><span style="color:#f92672">=</span> NULL) {nw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> node();nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>pri <span style="color:#f92672">=</span> nwpri;nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>val <span style="color:#f92672">=</span> nwval;nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>l <span style="color:#f92672">=</span> nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>r <span style="color:#f92672">=</span> NULL;<span style="color:#66d9ef">return</span> nw;}
    <span style="color:#66d9ef">if</span> (nwval <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>val) nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>l <span style="color:#f92672">=</span> build(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>l);<span style="color:#66d9ef">else</span> nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>r <span style="color:#f92672">=</span> build(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>r);<span style="color:#66d9ef">return</span> nw;}
queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> q;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v_val, v_pri;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">level_traverse</span>(node <span style="color:#f92672">*</span> nw) {
    q.push(nw);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
        node <span style="color:#f92672">*</span> nwnode <span style="color:#f92672">=</span> q.front();q.pop();
        v_val.push_back(nwnode<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>val);v_pri.push_back(nwnode<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>pri);
        <span style="color:#66d9ef">if</span> (nwnode<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>l) q.push(nwnode<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>l);<span style="color:#66d9ef">if</span> (nwnode<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>r) q.push(nwnode<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>r);}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i].val, <span style="color:#f92672">&amp;</span>a[i].pri);sort(a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) { nwval <span style="color:#f92672">=</span> a[i].val, nwpri <span style="color:#f92672">=</span> a[i].pri; root <span style="color:#f92672">=</span> build(root);}
    level_traverse(root);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v_val.size(); <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) { <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>;cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>v_val[i];}
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v_pri.size(); <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) { <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>; cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>v_pri[i];}}
</code></pre></div><h3 id="二叉链表">二叉链表</h3>
<p>由于是二叉链表，实质上是指针指向的，所以就写一个<em>递归的返回指针的函数</em>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">node <span style="color:#f92672">*</span> <span style="color:#a6e22e">build</span>() {  <span style="color:#66d9ef">char</span> ch;  cin<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>ch;
  <span style="color:#66d9ef">if</span> (ch <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">#</span><span style="color:#e6db74">&#39;</span>) <span style="color:#66d9ef">return</span> NULL;  <span style="color:#66d9ef">else</span> {<span style="color:#75715e">// 声明出当前指向结构体的指针
</span><span style="color:#75715e"></span>    node <span style="color:#f92672">*</span> n <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data <span style="color:#f92672">=</span> ch<span style="color:#f92672">-</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">0</span><span style="color:#e6db74">&#39;</span>;n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild <span style="color:#f92672">=</span> build();n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild <span style="color:#f92672">=</span> build();  }}
<span style="color:#75715e">// main函数里 =&gt; 先创建一个指向根节点的指针，然后就可以开始给这个指针build了
</span><span style="color:#75715e"></span>node <span style="color:#f92672">*</span> tree <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node)); tree <span style="color:#f92672">=</span> build();
</code></pre></div><p>4、前周后序遍历，都只需要将指向根节点的指针传入即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> data;    node <span style="color:#f92672">*</span> lchild;    node <span style="color:#f92672">*</span> rchild;
    node(){}    node(<span style="color:#66d9ef">int</span> data)<span style="color:#f92672">:</span> data(data){}
    node(<span style="color:#66d9ef">int</span> data, node <span style="color:#f92672">*</span> lchild, node <span style="color:#f92672">*</span> rchild)<span style="color:#f92672">:</span> data(data), lchild(lchild), rchild(rchild){}};
<span style="color:#66d9ef">char</span> ch;<span style="color:#75715e">// 构造二叉树
</span><span style="color:#75715e"></span>node <span style="color:#f92672">*</span> <span style="color:#a6e22e">build</span>(){
    cin<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>ch; <span style="color:#66d9ef">if</span> (ch <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">#</span><span style="color:#e6db74">&#39;</span>) <span style="color:#66d9ef">return</span> NULL;
    <span style="color:#66d9ef">else</span> {
        node <span style="color:#f92672">*</span> n <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node)); n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data <span style="color:#f92672">=</span> ch<span style="color:#f92672">-</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">0</span><span style="color:#e6db74">&#39;</span>; n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild <span style="color:#f92672">=</span> build(); n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild <span style="color:#f92672">=</span> build();
        <span style="color:#66d9ef">return</span> n;}}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pre_traverse</span>(node <span style="color:#f92672">*</span> n) { cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) pre_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild); <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) pre_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);} <span style="color:#75715e">// 前序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">in_traverse</span>(node <span style="color:#f92672">*</span> n) { <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) in_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild); cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) in_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);} <span style="color:#75715e">// 中序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">post_traverse</span>(node <span style="color:#f92672">*</span> n) {<span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) post_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild); <span style="color:#66d9ef">if</span> (n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) post_traverse(n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>;}<span style="color:#75715e">// 后序遍历
</span><span style="color:#75715e"></span><span style="color:#75715e">// 非递归遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> cnt_node, cnt_1, cnt_2, cnt_leaf, val_min<span style="color:#f92672">=</span>INT_MAX, val_max;
queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> q1;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">non_recursive_traverse</span>(node <span style="color:#f92672">*</span> n) {
    q1.push(n);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q1.empty()) {
        node <span style="color:#f92672">*</span> nw <span style="color:#f92672">=</span> q1.front();q1.pop();cnt_node<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        val_min <span style="color:#f92672">=</span> min(val_min, nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data); val_max <span style="color:#f92672">=</span> max(val_max, nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data);
        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) cnt_2<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild<span style="color:#f92672">=</span><span style="color:#f92672">=</span>NULL <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild<span style="color:#f92672">=</span><span style="color:#f92672">=</span>NULL) cnt_leaf<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">else</span> cnt_1<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) q1.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild);        <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) q1.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);}}
queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> q2;<span style="color:#75715e">// 选做内容：bfs 层次遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(node <span style="color:#f92672">*</span> n) {
    q2.push(n);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q2.empty()) {
        node <span style="color:#f92672">*</span> nw <span style="color:#f92672">=</span> q2.front();q2.pop();
        cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> </span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild) q2.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>lchild); <span style="color:#66d9ef">if</span> (nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild) q2.push(nw<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>rchild);}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    node <span style="color:#f92672">*</span> tree <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
    tree <span style="color:#f92672">=</span> build();
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">前序遍历: </span><span style="color:#e6db74">&#34;</span>; pre_traverse(tree); cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">中序遍历: </span><span style="color:#e6db74">&#34;</span>; in_traverse(tree);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">后序遍历: </span><span style="color:#e6db74">&#34;</span>; post_traverse(tree);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">非递归遍历: </span><span style="color:#e6db74">&#34;</span>; non_recursive_traverse(tree);
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_node<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  度为1的节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_1<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  度为2的节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_2<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  叶子节点个数:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>cnt_leaf<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">最大值:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>val_max<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">  最小值:</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>val_min;
    cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">层次遍历(bfs): </span><span style="color:#e6db74">&#34;</span>; bfs(tree); cout<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>endl;}
</code></pre></div><h3 id="二叉树建树---节点值做索引表示">二叉树建树 - 节点值做索引表示</h3>
<p><a href="https://www.luogu.com.cn/problem/P1305">https://www.luogu.com.cn/problem/P1305</a></p>
<p>1、节点值做索引的数据结构</p>
<p>结构体中不需要当前节点的值，因为这个节点的值已经在做数据结构的索引了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> node {<span style="color:#66d9ef">int</span> left, right;}tree[maxnode];
</code></pre></div><p>要求给出的数据（节点的顺序必须为对应的，不然这样匹配是有问题的）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 读入字符串abc，得到a为根节点，bc分别为两个子节点 (注意读取单个字符的时候，要给空格来冲刷掉回车的影响)
</span><span style="color:#75715e"></span>scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ch); scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c%c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tree[ch].left, <span style="color:#f92672">&amp;</span>tree[ch].right);
</code></pre></div><p>2、前中后序的遍历</p>
<ul>
<li>前：根-&gt;左-&gt;右</li>
<li>中：左-&gt;根-&gt;右</li>
<li>后：右-&gt;根-&gt;左</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">front_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
  printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">左</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) front_traverse(tree[ch].left);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">右</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) front_traverse(tree[ch].right);
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mid_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">左</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) mid_traverse(tree[ch].left);
  printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">右</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) mid_traverse(tree[ch].right);
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">back_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">左</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) back_traverse(tree[ch].left);
  <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">当</span><span style="color:#960050;background-color:#1e0010">前</span><span style="color:#960050;background-color:#1e0010">节</span><span style="color:#960050;background-color:#1e0010">点</span><span style="color:#960050;background-color:#1e0010">的</span><span style="color:#960050;background-color:#1e0010">右</span><span style="color:#960050;background-color:#1e0010">儿</span><span style="color:#960050;background-color:#1e0010">子</span><span style="color:#960050;background-color:#1e0010">不</span><span style="color:#960050;background-color:#1e0010">是</span><span style="color:#960050;background-color:#1e0010">空</span>) back_traverse(tree[ch].right);
  printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
}
</code></pre></div><p>AC代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">struct</span> node {
    <span style="color:#66d9ef">char</span> left, right;
}tree[<span style="color:#ae81ff">1000</span>];
<span style="color:#66d9ef">char</span> ch, root;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">front_traverse</span>(<span style="color:#66d9ef">char</span> ch) {
    <span style="color:#75715e">// front traverse =&gt; root, left, right
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#e6db74">&#34;</span>, ch);
    <span style="color:#66d9ef">if</span> (tree[ch].left <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">*</span><span style="color:#e6db74">&#39;</span>) front_traverse(tree[ch].left);
    <span style="color:#66d9ef">if</span> (tree[ch].right <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">*</span><span style="color:#e6db74">&#39;</span>) front_traverse(tree[ch].right);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ch);
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) root <span style="color:#f92672">=</span> ch;
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74"> %c%c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tree[ch].left, <span style="color:#f92672">&amp;</span>tree[ch].right);
    }
    front_traverse(root);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二叉树----节点值做索引-搜索深度">二叉树 -  节点值做索引 搜索深度</h3>
<p><a href="https://www.luogu.com.cn/problem/P4913">https://www.luogu.com.cn/problem/P4913</a></p>
<p>1、遍历的过程中就筛选出最大的深度，通过维护一个ans来提取。</p>
<p>第一种，通过在dfs深搜到儿子节点之前来判断是否要搜他。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> depth) {
  ans <span style="color:#f92672">=</span> max(ans, depth);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tree[val].left) dfs(tree[val].left, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tree[val].right) dfs(tree[val].right, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>第二种，通过在搜到之后，判断这个搜到的点是否符合搜的要求。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> depth) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>val) <span style="color:#66d9ef">return</span>;
  ans <span style="color:#f92672">=</span> max(ans, depth);
  dfs(tree[val].left, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
  dfs(tree[val].right, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>AC代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;
<span style="color:#75715e">#</span><span style="color:#75715e">define maxnode 1000010</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> node{
    <span style="color:#66d9ef">int</span> left, right;
}tree[maxnode];
<span style="color:#66d9ef">int</span> n, ans;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> val, <span style="color:#66d9ef">int</span> depth) {
    ans <span style="color:#f92672">=</span> max(ans, depth);
    <span style="color:#66d9ef">if</span> (tree[val].left) dfs(tree[val].left, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> (tree[val].right) dfs(tree[val].right, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tree[i].left, <span style="color:#f92672">&amp;</span>tree[i].right);
    dfs(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二叉树的前序-中序-后序-dfs序等性质--给出前后求中序">二叉树的前序 中序 后序 dfs序等性质 // 【给出前后，求中序】</h3>
<p>题目：给出前序后序，不给中序，求这棵树有多少种形态。【中序有多少种】</p>
<p>分析：前序：根左右，中序：左根右，后序：左右根</p>
<p>性质：一个树有多少种形态，取决于儿子节点只有1个的节点的个数。【形态数 = pow(2, 儿子节点为1的节点个数)】</p>
<ul>
<li>如果一棵树没有只有一个儿子节点的节点=》也就是是一个完满二叉树，只要有儿子节点，就是两个，要不就没有儿子节点。
<ul>
<li>此时树形态已经被确定了，例如前序abc后序bca，那这就是一个a-&gt;(b,c)的完满二叉树，在例如前序abdecfg后序debfgca，那就是一个a-&gt;(b-&gt;(d,e), c-&gt;(f,g))的完满二叉树</li>
</ul>
</li>
<li>如果一个棵树的节点都只有一个儿子节点=》和一根线一样，就例如如果就是abc往下排列的一根线，那么可以计算得到两个节点满足只有一个儿子节点，那么总共有4种，分别为左左，左右，右左，右右。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
string pre, post;
<span style="color:#66d9ef">int</span> ans;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>pre<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>post;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pre.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> post.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            <span style="color:#66d9ef">if</span> (pre[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> post[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> post[j] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> pre[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) ans<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二叉树的前序-中序-后序-dfs序等性质--给出中序前后中的一个求另一个">二叉树的前序 中序 后序 dfs序等性质 // 【给出中序+前后中的一个，求另一个】</h3>
<p><a href="https://www.luogu.com.cn/problem/P1030">https://www.luogu.com.cn/problem/P1030</a> 该题是由中序+后序求前序</p>
<p><a href="https://www.luogu.com.cn/problem/P1827">https://www.luogu.com.cn/problem/P1827</a> 该题是由中序+前序求后序</p>
<p>思路：首先明确前：根左右   中：左根右     后：左右根</p>
<p>然后整体思路就是通过前或者后的根在一边的特性，直接从对应的一段提取出根，然后再在中序中找到根，根左边的就是左子树，根右边的就是右子树，然后再递归两颗子树即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">string pre, in, post;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transform_pre</span>(string i, string p) {
    <span style="color:#66d9ef">if</span> (i.length() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">char</span> root <span style="color:#f92672">=</span> p[p.length() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
        cout <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> root;
        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> i.find(root);
        transform_pre(i.substr(<span style="color:#ae81ff">0</span>, pos), p.substr(<span style="color:#ae81ff">0</span>, pos));
        transform_pre(i.substr(pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), p.substr(pos, i.size() <span style="color:#f92672">-</span> pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));}}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transform_post</span>(string pr, string i) {
    <span style="color:#66d9ef">if</span> (i.length() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">char</span> root <span style="color:#f92672">=</span> pr[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> i.find(root);
        transform_post(pr.substr(<span style="color:#ae81ff">1</span>, pos), i.substr(<span style="color:#ae81ff">0</span>, pos));
        transform_post(pr.substr(pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), i.substr(pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
        cout <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> root;}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {    cin <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> in <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> pre;    transform_post(pre, in);}
<span style="color:#75715e">//1 2 3 4 5 6 7//中序遍历: 3256471//后序遍历: 3657421 //1 2 4 5 3 6 7//中序遍历: 4251637//后序遍历: 4526731
</span></code></pre></div><h3 id="树状数组-模版-区间求和查询单点修改操作">树状数组-模版-区间求和(查询)、单点修改(操作)</h3>
<p>0、<code>lowbit()</code>看当前节点的归属情况/看当前节点所管辖的节点的个数 eg：8(10) &amp; -8(10) = 8  =&gt; 根据树状数组结构图，就是8个节点</p>
<p>eg：4(10) &amp; -4(10) = 4  =&gt; 根据树状数组结构图，就是4个节点 eg：6(10) &amp; -6(10) = 2  =&gt; 根据树状数组结构图，就是2个节点</p>
<p>1、单点修改 =&gt; 自下而上修改 =&gt; c数组的索引pos从1开始往上找，但是要限定永远≤n =&gt; 从下往上找的话，看当前的节点归属那个父节点范围，则需要<code>pos+=lowbit(pos)</code>，此时就可以直接爬升到父节点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">single_add</span>(<span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> k) { <span style="color:#66d9ef">while</span>(pos <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n) { c[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> k; pos <span style="color:#f92672">+</span><span style="color:#f92672">=</span> lowbit(pos);}}
</code></pre></div><p>2、区间求和「注意这个区间求的是前缀和，也就是1到pos的和。如果区间和的话，可以通过两个前缀和相减得到」=&gt; 自上而下累加 =&gt; c数组的索引pos从target目标开始往下找，但是要限定下限，不能让下限爆掉，pos≥1 =&gt;  从上往下累加的话，看当前的节点归属那个的子节点，则需要<code>pos-=lowbit(pos)</code>，此时就可以直接下降到子节点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getsum</span>(<span style="color:#66d9ef">int</span> pos) {<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">while</span>(pos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) { ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> c[pos]; pos <span style="color:#f92672">-</span><span style="color:#f92672">=</span> lowbit(pos); } }
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> n, m, tm, tp, ta, tb, c[maxn];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lowbit</span>(<span style="color:#66d9ef">int</span> x) {<span style="color:#66d9ef">return</span> x <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">-</span>x);}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">single_add</span>(<span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> k) { <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n) {c[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> k;pos <span style="color:#f92672">+</span><span style="color:#f92672">=</span> lowbit(pos);}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getsum</span>(<span style="color:#66d9ef">int</span> pos) { <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) { ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> c[pos]; pos <span style="color:#f92672">-</span><span style="color:#f92672">=</span> lowbit(pos);}<span style="color:#66d9ef">return</span> ans;}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tm);single_add(i, tm);}
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tp, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);
        <span style="color:#66d9ef">if</span> (tp<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getsum(tb)<span style="color:#f92672">-</span>getsum(ta<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));<span style="color:#66d9ef">else</span> single_add(ta, tb);}}
</code></pre></div><h3 id="树状数组-模版-区间修改操作单点求和查询">树状数组-模版-区间修改(操作)、单点求和(查询)</h3>
<p>区间修改+单点求和 模版：https://www.luogu.com.cn/problem/P3368</p>
<p>区间修改+单次范围最值 【范围最值也可以看作是所有的点取一遍最值】：https://www.luogu.com.cn/problem/P2367</p>
<p>1、区间修改：考虑到<strong>差分</strong>，之不过是在树上进行差分，利用树状数组进行差分，此时对于树状数组c的修改就只需要修改两头即可了，也就是在l的位置加上k，在r+1的位置减去k，最后再利用树状数组c进行还原即可。</p>
<p>2、此时沿着树状数组进行求和，求的就不是上面的那个区间和了 =&gt; 因为这个树状数组代表的是差分，累加所得到的该索引的数组的值。</p>
<p>P3368模版区间修改+多次查询单个点</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> n, m, a[maxn], c[maxn], tp, ta, tb, tc;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lowbit</span>(<span style="color:#66d9ef">int</span> x) {<span style="color:#66d9ef">return</span> x <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">-</span>x);}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">single_add</span>(<span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> k) {
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n) {
        c[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> k;
        pos <span style="color:#f92672">+</span><span style="color:#f92672">=</span> lowbit(pos);    }}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interval_add</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> k) {    single_add(l, k);    single_add(r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span>k);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getsum</span>(<span style="color:#66d9ef">int</span> pos) {
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
        ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> c[pos];
        pos <span style="color:#f92672">-</span><span style="color:#f92672">=</span> lowbit(pos);
    }    <span style="color:#66d9ef">return</span> ans;}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getval</span>(<span style="color:#66d9ef">int</span> pos) {    <span style="color:#66d9ef">return</span> a[pos] <span style="color:#f92672">+</span> getsum(pos);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tp);
        <span style="color:#66d9ef">if</span> (tp<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta);printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getval(ta));}
        <span style="color:#66d9ef">else</span> {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);interval_add(ta, tb, tc);}}}
</code></pre></div><p>P2367区间修改+最终单次查询所有点</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> n, m, a[maxn], c[maxn], ta, tb, tc, minn <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">31</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// c为树上的差分数组，a为记录原数据的数组
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define lowbit(x) x&amp;(-x)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> k) {
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n) {
        c[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> k;
        pos <span style="color:#f92672">+</span><span style="color:#f92672">=</span> lowbit(pos);    }}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interval_add</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> k) {    add(l, k);    add(r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span>k);}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> pos){
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
        ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> c[pos];
        pos <span style="color:#f92672">-</span><span style="color:#f92672">=</span> lowbit(pos);}
    <span style="color:#66d9ef">return</span> ans;}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);   <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);        interval_add(ta, tb, tc);    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) minn <span style="color:#f92672">=</span> min(a[i]<span style="color:#f92672">+</span>query(i), minn);
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, minn);}
</code></pre></div><h3 id="树状数组-模版-区间修改操作区间求和查询">树状数组-模版-区间修改(操作)、区间求和(查询)</h3>
<p><a href="https://www.luogu.com.cn/problem/P2367">https://www.luogu.com.cn/problem/P2367</a></p>
<p>1、区分上面的单点修改+区间求和 // 区间修改+单点查询，都可以解决尾一类问题，核心代码相似，只不过后者就是前者的基础上增添了差分的思想，根据差分用求和来查单点的值 == 根据累加用单点来查求和的值。</p>
<p>2、区间修改+区间查询需要维护两个数组，sum1数组是求和的数组，sum2数组是乘积的数组。进行区间修改的时候，进行差分来修改 // 进行区间查询的时候，根据前缀和来进行查询。</p>
<p>区间修改：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(ll pos, ll k) {
    ll tem <span style="color:#f92672">=</span> k<span style="color:#f92672">*</span>pos;
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n) {
        sum1[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> k;sum2[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> tem;
        pos <span style="color:#f92672">+</span><span style="color:#f92672">=</span> lowbit(pos);}}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interval_add</span>(ll l, ll r, ll k) {    add(l, k);    add(r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span>k);}
</code></pre></div><p>区间查询</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    ll ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tem <span style="color:#f92672">=</span> pos;
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
        ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> ((tem<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>sum1[pos] <span style="color:#f92672">-</span> sum2[pos]);
        pos <span style="color:#f92672">-</span><span style="color:#f92672">=</span> lowbit(pos);
    }
    <span style="color:#66d9ef">return</span> ans;
}

ll interval_query(ll l, ll r) {
    <span style="color:#66d9ef">return</span> query(r)<span style="color:#f92672">-</span>query(l<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>完整代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ll n, m, tm, last, first_val, sum1[maxn], sum2[maxn], tp, ta, tb, tc;
<span style="color:#75715e">#</span><span style="color:#75715e">define lowbit(x) x&amp;(-x)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(ll pos, ll k) {
    ll tem <span style="color:#f92672">=</span> k<span style="color:#f92672">*</span>pos;
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n) {
        sum1[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> k;sum2[pos] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> tem;
        pos <span style="color:#f92672">+</span><span style="color:#f92672">=</span> lowbit(pos);}}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interval_add</span>(ll l, ll r, ll k)    add(l, k);    add(r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span>k);}
ll query(ll pos) {
    ll ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tem <span style="color:#f92672">=</span> pos;
    <span style="color:#66d9ef">while</span> (pos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
        ans <span style="color:#f92672">+</span><span style="color:#f92672">=</span> ((tem<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>sum1[pos] <span style="color:#f92672">-</span> sum2[pos]);
        pos <span style="color:#f92672">-</span><span style="color:#f92672">=</span> lowbit(pos);}
    <span style="color:#66d9ef">return</span> ans;}
ll interval_query(ll l, ll r) {    <span style="color:#66d9ef">return</span> query(r)<span style="color:#f92672">-</span>query(l<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);}
<span style="color:#66d9ef">int</span> main() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tm);add(i, tm<span style="color:#f92672">-</span>last);last<span style="color:#f92672">=</span>tm;}
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tp);
        <span style="color:#66d9ef">switch</span> (tp) {
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld%lld%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);interval_add(ta, tb, tc);<span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span> scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta);first_val <span style="color:#f92672">+</span><span style="color:#f92672">=</span> ta;<span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span> scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta);first_val <span style="color:#f92672">-</span><span style="color:#f92672">=</span> ta;<span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">:</span> scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld%lld</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, interval_query(ta, tb)<span style="color:#f92672">+</span>(ta<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>first_val);<span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">:</span> printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, query(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>first_val);<span style="color:#66d9ef">break</span>;}}}
</code></pre></div><h3 id="图论-lca最近公公祖先">图论-LCA最近公公祖先</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> n, m, root, ta, tb, depth[maxnode], p[maxnode][<span style="color:#ae81ff">21</span>];
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {    <span style="color:#66d9ef">int</span> to, next;}edge[maxnode<span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>];<span style="color:#66d9ef">int</span> head[maxnode],tot;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addedge</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> to) {edge[<span style="color:#f92672">+</span><span style="color:#f92672">+</span>tot].to <span style="color:#f92672">=</span> to; edge[tot].next <span style="color:#f92672">=</span> head[from];head[from] <span style="color:#f92672">=</span> tot;}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> fa) {
    depth[from] <span style="color:#f92672">=</span> depth[fa]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    p[from][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> fa;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; (<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>i) <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> depth[from]; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) p[from][i] <span style="color:#f92672">=</span> p[p[from][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[from]; i; i<span style="color:#f92672">=</span>edge[i].next) {
        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edge[i].to;        <span style="color:#66d9ef">if</span> (to <span style="color:#f92672">!</span><span style="color:#f92672">=</span> fa) dfs(to, from);}}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lca</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
    <span style="color:#66d9ef">if</span> (depth[a] <span style="color:#f92672">&gt;</span> depth[b]) swap(a, b);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; i <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>i) <span style="color:#66d9ef">if</span> (depth[a] <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> depth[b]<span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span>i)) b <span style="color:#f92672">=</span> p[b][i];
    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">=</span><span style="color:#f92672">=</span> b) <span style="color:#66d9ef">return</span> a;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; i <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">-</span><span style="color:#f92672">-</span>i)
        <span style="color:#66d9ef">if</span> (p[a][i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> p[b][i]) <span style="color:#66d9ef">continue</span>;<span style="color:#66d9ef">else</span> a <span style="color:#f92672">=</span> p[a][i],b<span style="color:#f92672">=</span>p[b][i];
    <span style="color:#66d9ef">return</span> p[a][<span style="color:#ae81ff">0</span>];}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>root);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);addedge(ta, tb);addedge(tb, ta);}
    dfs(root, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> lca(ta, tb);
        <span style="color:#66d9ef">int</span> hh<span style="color:#f92672">=</span>H[a]<span style="color:#f92672">+</span>H[b]<span style="color:#f92672">-</span>H[u]<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>(PZ[u]<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">H</span><span style="color:#e6db74">&#39;</span>);
        <span style="color:#66d9ef">int</span> gg<span style="color:#f92672">=</span>G[a]<span style="color:#f92672">+</span>G[b]<span style="color:#f92672">-</span>G[u]<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>(PZ[u]<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">G</span><span style="color:#e6db74">&#39;</span>);
        <span style="color:#66d9ef">if</span>(c<span style="color:#f92672">=</span><span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">H</span><span style="color:#e6db74">&#39;</span>){<span style="color:#66d9ef">if</span>(hh) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">1</span><span style="color:#e6db74">&#34;</span>);<span style="color:#66d9ef">else</span>   printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">0</span><span style="color:#e6db74">&#34;</span>);}
        <span style="color:#66d9ef">else</span>{<span style="color:#66d9ef">if</span>(gg) printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">1</span><span style="color:#e6db74">&#34;</span>);<span style="color:#66d9ef">else</span>   printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">0</span><span style="color:#e6db74">&#34;</span>);}
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lca(ta, tb));}}
</code></pre></div><h3 id="图论-起终点一样权值和为0floyd算法">图论-起终点一样，权值和为0，floyd算法</h3>
<p>题目大意：给出一个图，有双向边和单向边（其中单向边的权值是负的），问是否存在路径可以满足<strong>起终点一样</strong>，<strong>权值和为0</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> t, n, m, w, mp[maxn][maxn], ta, tb, tc;
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Floyd</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i){<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
                <span style="color:#66d9ef">if</span> (mp[i][k]<span style="color:#f92672">+</span>mp[k][j] <span style="color:#f92672">&lt;</span> mp[i][j]) mp[i][j] <span style="color:#f92672">=</span> mp[i][k]<span style="color:#f92672">+</span>mp[k][j];
            <span style="color:#66d9ef">if</span> (mp[i][i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// 判断负权闭环
</span><span style="color:#75715e"></span>        }    <span style="color:#66d9ef">return</span> false;}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>t);
    <span style="color:#66d9ef">while</span> (t<span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>w);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j){ <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">=</span><span style="color:#f92672">=</span> j) mp[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; mp[i][j] <span style="color:#f92672">=</span> mp[j][i] <span style="color:#f92672">=</span> inf; }
        <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">-</span><span style="color:#f92672">-</span>){
            scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);
            <span style="color:#66d9ef">if</span> (tc <span style="color:#f92672">&lt;</span> mp[ta][tb]) mp[ta][tb] <span style="color:#f92672">=</span> mp[tb][ta] <span style="color:#f92672">=</span> tc;
        }
        <span style="color:#66d9ef">while</span> (w<span style="color:#f92672">-</span><span style="color:#f92672">-</span>){scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb, <span style="color:#f92672">&amp;</span>tc);mp[ta][tb] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>tc;}
        <span style="color:#66d9ef">if</span> (Floyd()) puts(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">YES</span><span style="color:#e6db74">&#34;</span>); <span style="color:#66d9ef">else</span> puts(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">NO</span><span style="color:#e6db74">&#34;</span>);}
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;}
</code></pre></div><h3 id="图论-floyd---传递闭包">图论-Floyd - 传递闭包</h3>
<p>题意：给出已知的大小关系，问可以确定具体排名的个数有多少。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">109</span>;
<span style="color:#66d9ef">int</span> n, m, mp[maxn][maxn], ta, tb, ans;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> m; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>ta, <span style="color:#f92672">&amp;</span>tb);
        mp[ta][tb] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>k)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
                <span style="color:#66d9ef">if</span> (mp[i][k] <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> mp[k][j]) mp[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i) {
        <span style="color:#66d9ef">int</span> tem <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>j)
            <span style="color:#66d9ef">if</span> (mp[i][j] <span style="color:#f92672">|</span><span style="color:#f92672">|</span> mp[j][i]) tem<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
        <span style="color:#66d9ef">if</span> (tem <span style="color:#f92672">=</span><span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) ans<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="heading"></h3>
<h3 id="heading-1"></h3>

		</section>

		<div class="meta">Posted on Feb 4, 2020</div>

		<div class="post-tags">
			
			
			
		</div>
	</article>
	
</main>
<footer>
<hr><a class="soc" href="https://github.com/Aczy156" title="GitHub"><i data-feather="github"></i></a>|⚡️
	2023  © Aczy156 |  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168772474-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>
      feather.replace()
</script></div>
    </body>
</html>
